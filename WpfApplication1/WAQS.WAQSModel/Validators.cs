//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections;
using System.Linq.Expressions;
using System.Text.RegularExpressions;

namespace WCFAsyncQueryableServices.ComponentModel
{
    public partial class Validators
    {
    	public static ErrorInfo ValidateRequiredStringProperty<T>(string value, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (string.IsNullOrWhiteSpace(value))
    		{
    			var errorInfo = new RequiredFieldErrorInfo();
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, RequiredFieldErrorInfo.RequiredFieldErrorCode);
    		return null;
    	}
    		
    	public static ErrorInfo ValidateRequiredProperty<T>(T? value, Expression<Func<T?>> prop, DataErrorInfo dataErrorInfo)
    		where T : struct
    	{
    		if (! value.HasValue)
    		{
    			var errorInfo = new RequiredFieldErrorInfo();
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, RequiredFieldErrorInfo.RequiredFieldErrorCode);
    		return null;
    	}
    	
    	public static ErrorInfo ValidateRequiredObjectProperty<T>(T value, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    		where T : class
    	{
    		if (value == null)
    		{
    			var errorInfo = new RequiredFieldErrorInfo();
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, RequiredFieldErrorInfo.RequiredFieldErrorCode);
    		return null;
    	}
    
    	public static ErrorInfo ValidateStringMinLength<T>(string value, int minLength, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value != null && value.Length < minLength)
    		{
    			var errorInfo = new MinLengthErrorInfo(minLength);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinLengthErrorInfo.MinLengthErrorCode);
    		return null;
    	}
    		
    	public static ErrorInfo ValidateStringMaxLength<T>(string value, int maxLength, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value != null && value.Length > maxLength)
    		{
    			var errorInfo = new MaxLengthErrorInfo(maxLength);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxLengthErrorInfo.MaxLengthErrorCode);
    		return null;
    	}
    
    	public static ErrorInfo ValidateBinaryMaxLength<T>(Byte[] value, int maxLength, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value != null && value.Length > maxLength)
    		{
    			var errorInfo = new MaxLengthErrorInfo(maxLength);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxLengthErrorInfo.MaxLengthErrorCode);
    		return null;
    	}
    
    	public static ErrorInfo ValidateMinValue(byte value, int minValue, Expression<Func<byte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (byte)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(byte value, byte minValue, Expression<Func<byte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<byte>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<byte>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(byte? value, int minValue, Expression<Func<byte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (byte)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(byte? value, byte minValue, Expression<Func<byte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<byte>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<byte?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(DateTime value, DateTime minValue, Expression<Func<DateTime>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<DateTime>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<DateTime>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(DateTime? value, DateTime minValue, Expression<Func<DateTime?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<DateTime>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<DateTime?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(DateTimeOffset value, DateTimeOffset minValue, Expression<Func<DateTimeOffset>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<DateTimeOffset>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<DateTimeOffset>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(DateTimeOffset? value, DateTimeOffset minValue, Expression<Func<DateTimeOffset?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<DateTimeOffset>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<DateTimeOffset?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(TimeSpan value, TimeSpan minValue, Expression<Func<TimeSpan>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<TimeSpan>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<TimeSpan>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(TimeSpan? value, TimeSpan minValue, Expression<Func<TimeSpan?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<TimeSpan>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<TimeSpan?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(decimal value, decimal minValue, Expression<Func<decimal>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<decimal>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<decimal>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(decimal? value, decimal minValue, Expression<Func<decimal?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<decimal>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<decimal?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(double value, double minValue, Expression<Func<double>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<double>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<double>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(double? value, double minValue, Expression<Func<double?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<double>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<double?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(float value, float minValue, Expression<Func<float>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<float>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<float>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(float? value, float minValue, Expression<Func<float?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<float>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<float?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(short value, int minValue, Expression<Func<short>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (short)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(short value, short minValue, Expression<Func<short>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<short>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<short>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(short? value, int minValue, Expression<Func<short?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (short)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(short? value, short minValue, Expression<Func<short?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<short>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<short?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(int value, int minValue, Expression<Func<int>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<int>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<int>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(int? value, int minValue, Expression<Func<int?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<int>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<int?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(long value, long minValue, Expression<Func<long>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<long>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<long>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(long? value, long minValue, Expression<Func<long?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<long>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<long?>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(sbyte value, int minValue, Expression<Func<sbyte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (sbyte)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(sbyte value, sbyte minValue, Expression<Func<sbyte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<sbyte>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<sbyte>.MinValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMinValue(sbyte? value, int minValue, Expression<Func<sbyte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMinValue(value, (sbyte)minValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMinValue(sbyte? value, sbyte minValue, Expression<Func<sbyte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value < minValue)
    		{
    			var errorInfo = new MinValueErrorInfo<sbyte>(minValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MinValueErrorInfo<sbyte?>.MinValueErrorCode);
    		return null;
    	}
    
    	public static ErrorInfo ValidateMaxValue(byte value, int maxValue, Expression<Func<byte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (byte)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(byte value, byte maxValue, Expression<Func<byte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<byte>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<byte>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(byte? value, int maxValue, Expression<Func<byte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (byte)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(byte? value, byte maxValue, Expression<Func<byte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<byte>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<byte?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(DateTime value, DateTime maxValue, Expression<Func<DateTime>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<DateTime>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<DateTime>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(DateTime? value, DateTime maxValue, Expression<Func<DateTime?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<DateTime>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<DateTime?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(DateTimeOffset value, DateTimeOffset maxValue, Expression<Func<DateTimeOffset>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<DateTimeOffset>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<DateTimeOffset>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(DateTimeOffset? value, DateTimeOffset maxValue, Expression<Func<DateTimeOffset?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<DateTimeOffset>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<DateTimeOffset?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(TimeSpan value, TimeSpan maxValue, Expression<Func<TimeSpan>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<TimeSpan>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<TimeSpan>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(TimeSpan? value, TimeSpan maxValue, Expression<Func<TimeSpan?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<TimeSpan>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<TimeSpan?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(decimal value, decimal maxValue, Expression<Func<decimal>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<decimal>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<decimal>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(decimal? value, decimal maxValue, Expression<Func<decimal?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<decimal>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<decimal?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(double value, double maxValue, Expression<Func<double>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<double>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<double>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(double? value, double maxValue, Expression<Func<double?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<double>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<double?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(float value, float maxValue, Expression<Func<float>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<float>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<float>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(float? value, float maxValue, Expression<Func<float?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<float>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<float?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(short value, int maxValue, Expression<Func<short>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (short)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(short value, short maxValue, Expression<Func<short>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<short>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<short>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(short? value, int maxValue, Expression<Func<short?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (short)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(short? value, short maxValue, Expression<Func<short?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<short>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<short?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(int value, int maxValue, Expression<Func<int>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<int>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<int>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(int? value, int maxValue, Expression<Func<int?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<int>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<int?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(long value, long maxValue, Expression<Func<long>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<long>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<long>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(long? value, long maxValue, Expression<Func<long?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<long>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<long?>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(sbyte value, int maxValue, Expression<Func<sbyte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (sbyte)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(sbyte value, sbyte maxValue, Expression<Func<sbyte>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<sbyte>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<sbyte>.MaxValueErrorCode);
    		return null;
    	}
    	public static ErrorInfo ValidateMaxValue(sbyte? value, int maxValue, Expression<Func<sbyte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		return ValidateMaxValue(value, (sbyte)maxValue, prop, dataErrorInfo);
    	}
    	public static ErrorInfo ValidateMaxValue(sbyte? value, sbyte maxValue, Expression<Func<sbyte?>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (value.HasValue && value.Value > maxValue)
    		{
    			var errorInfo = new MaxValueErrorInfo<sbyte>(maxValue);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, MaxValueErrorInfo<sbyte?>.MaxValueErrorCode);
    		return null;
    	}
    	
    	public static ErrorInfo ValidatePattern(string value, string pattern, Expression<Func<string>> prop, DataErrorInfo dataErrorInfo)
    	{
    		if (! (value == null || Regex.IsMatch(value, pattern)))
    		{
    			var errorInfo = new PatternErrorInfo(pattern);
    			dataErrorInfo.AddErrorForProperty(prop, errorInfo);
    			return errorInfo;
    		}
    		dataErrorInfo.RemoveErrorFromProperty(prop, PatternErrorInfo.PatternErrorCode);
    		return null;
    	}
    	
    	public static ErrorInfo DefineErrors<T>(string message, Expression<Func<T>> prop, DataErrorInfo dataErrorInfo)
    	{
    		dataErrorInfo.RemoveErrorFromProperty(prop, ValidateErrorInfo.ValidateErrorCode);
    		if (string.IsNullOrEmpty(message))
    			return null;
    		var value = new ValidateErrorInfo(message);
    		dataErrorInfo.AddErrorForProperty(prop, value);
    		return value;
    	}
    }
}
