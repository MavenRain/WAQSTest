//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Serialization;
using System.Threading;
using WCFAsyncQueryableServices.Common;
using WCFAsyncQueryableServices.SerializableExpressions;
using WCFAsyncQueryableServices.DAL.Interfaces.L2E;

namespace WCFAsyncQueryableServices.Service.L2E
{
    public static partial class SerializableExpressionToL2EExpressionConverter
    {
        public static Expression ToL2EExpression(this SerializableExpression serializableExpression, IEnumerable<string> withSpecificationsProperties, IObjectContext objectContext, ISerializableExpressionConverter serializableExpressionConverter)
        {
            var expressionReference = new Reference<Expression>();
            new Visitor(expressionReference, withSpecificationsProperties, objectContext, serializableExpressionConverter).Visit(serializableExpression);
            Dictionary<Type, int> constructorIndexes = new Dictionary<Type,int>();
            return SerializableExpressionToLINQExpressionConverter.OptimizeSelect(expressionReference.Value, serializableExpressionConverter, type =>
                {
                    if (!serializableExpressionConverter.GetEntityOrComplexTypes().Any(t => t.IsAssignableFrom(type)))
                        return type;
                    int index;
                    if (constructorIndexes.TryGetValue(type, out index))
                        constructorIndexes[type] = ++index;
                    else
                        constructorIndexes.Add(type, index = 0);
                    return Visitor.GetOrBuildNewInheritedType(type, serializableExpressionConverter, index) ?? type;
                });
        }
                                    
        public static object Convert(object obj)
        {
            return Visitor.Convert(obj);
        }
                        
        public static Type GetOriginalType(Type t)
        {
            return Visitor.GetOriginalType(t);
        }
                                    
        public partial class Visitor : SerializableExpressionToLINQExpressionConverter.Visitor
        {
            private IObjectContext _objectContext;
            private static ConcurrentDictionary<Type, BlockingCollection<Type>> _entityToDTOTypeCache = new ConcurrentDictionary<Type, BlockingCollection<Type>>();
            private static ConcurrentDictionary<Type, Type> _dtoToEntityTypeCache = new ConcurrentDictionary<Type, Type>();
            private static ConcurrentDictionary<Type, Func<object, object>> _dtoToEntityCache = new ConcurrentDictionary<Type, Func<object, object>>();
                                    
            public Visitor(Reference<Expression> expressionReference, IEnumerable<string> withSpecificationsProperties, IObjectContext objectContext, ISerializableExpressionConverter serializableExpressionConverter)
                : base(expressionReference, withSpecificationsProperties, serializableExpressionConverter)
            {
                InitVisitorFactory();
                _objectContext = objectContext;
            }
                                
            protected Visitor(Reference<Expression> expressionReference, IEnumerable<string> withSpecificationsProperties, ISerializableExpressionConverter serializableExpressionConverter, Dictionary<string, ParameterExpression> lambdaParameters, bool isEnumerable, Dictionary<Expression, bool> isEnumerableExpressions)
                : base(expressionReference, withSpecificationsProperties, serializableExpressionConverter, lambdaParameters, isEnumerable, isEnumerableExpressions)
            {
                InitVisitorFactory();
            }
                                    
            private void InitVisitorFactory()
            {
                VisitorFactory = (er, wsp, sec, lp, ie, iee) => new Visitor(er, wsp, sec, lp, ie, iee) { _objectContext = _objectContext };
            }
                                    
            protected override Expression GetConstructorExpression(Type type, SerializableConstructorExpression expression)
            {
                if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                {
                    if (expression.Arguments.Count != 1)
                        throw new NotImplementedException();
                    var argumentExpression = new Reference<Expression>();
                    CreateNewVisitor(argumentExpression, _lambdaParameters).Visit(expression.Arguments[0]);
                    return argumentExpression.Value;
                }
                return base.GetConstructorExpression(type, expression);
            }
                                    
            protected override Type GetConstructorType(Type type)
            {
                return GetInheritedType(type, _serializableExpressionConverter) ?? base.GetConstructorType(type);
            }
        
            internal static Type GetInheritedType(Type type, ISerializableExpressionConverter serializableExpressionConverter)
            {
                Type inheritedType = serializableExpressionConverter.GetInheritedType(type);
                if (inheritedType == null)
                    return null;
                _dtoToEntityTypeCache.TryAdd(inheritedType, type);
                _dtoToEntityCache.TryAdd(inheritedType, serializableExpressionConverter.GetBaseObject);
                return inheritedType;
            }
        
            internal static Type GetOrBuildNewInheritedType(Type type, ISerializableExpressionConverter serializableExpressionConverter, int index)
            {
                if (index == 0)
                    return GetInheritedType(type, serializableExpressionConverter);
                BlockingCollection<Type> inheritedTypes;
                if (_entityToDTOTypeCache.TryGetValue(type, out inheritedTypes) && inheritedTypes.Count >= index)
                    return inheritedTypes.ElementAt(index - 1);
                var assemblyName = new AssemblyName(type.Name + Guid.NewGuid().ToString());
                var appDomain = Thread.GetDomain();
                var assemblyBuilder = appDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
                var moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
                var typeBuilder = moduleBuilder.DefineType(type.Name, TypeAttributes.Public, type);
                Type value = typeBuilder.CreateType();
                if (inheritedTypes == null && (!_entityToDTOTypeCache.TryAdd(type, inheritedTypes = new BlockingCollection<Type>()) && !_entityToDTOTypeCache.TryGetValue(type, out inheritedTypes)))
                    throw new InvalidOperationException();
                inheritedTypes.Add(value);
                _dtoToEntityTypeCache.TryAdd(value, type);
                ParameterExpression parameter = Expression.Parameter(typeof(object));
                ParameterExpression parameterCast = Expression.Parameter(value);
                _dtoToEntityCache.TryAdd(value, Expression.Lambda<Func<object, object>>(
                    Expression.Block(
                        new ParameterExpression[] { parameterCast },
                        Expression.Assign(parameterCast, Expression.Convert(parameter, value)),
                        Expression.MemberInit(
                            Expression.New(type),
                            value.GetProperties().Where(p => p.CanRead && p.CanWrite).Select(p => Expression.Bind(p, Expression.MakeMemberAccess(parameterCast, value.GetProperty(p.Name)))))),
                    parameter).Compile());
                return value;
            }
                                    
            protected override Type[] GetLambdaGenericArguments(SerializableLambdaExpression expression, Expression body)
            {
                Type[] genericArgumentTypes = base.GetLambdaGenericArguments(expression, body);
                for (int i = 0; i < genericArgumentTypes.Length; i++)
                {
                    Type type = GetEntityType(genericArgumentTypes[i]);
                    if (type != null)
                        genericArgumentTypes[i] = type;
                }
                return genericArgumentTypes;
            }
                                    
            protected internal override void VisitMethodCall(SerializableMethodCallExpression expression)
            {
                var methodInfo = GetMethodInfo(expression);
                if (methodInfo.IsGenericMethod && (methodInfo.GetGenericMethodDefinition() == typeof(Enumerable).GetMethod("ToList") || methodInfo.GetGenericMethodDefinition() == typeof(Enumerable).GetMethod("ToArray")))
                {
                    CreateNewVisitor(_expressionReference, _lambdaParameters).Visit(expression.Parameters[0]);
                    Type parameterType = methodInfo.GetGenericArguments()[0];
                    var expressionParameter = Expression.Parameter(parameterType);
                    _expressionReference.Value = Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(parameterType, parameterType), _expressionReference.Value, Expression.Lambda(expressionParameter, expressionParameter));
                    return;
                }
                base.VisitMethodCall(expression);
            }
            
            protected override Expression VisitMethodCall(Expression source, MethodInfo method, List<Expression> parameters, List<int> isParametersEnumerable)
            {
                if (method.DeclaringType == typeof(Queryable))
                {
                    switch (method.Name)
                    {
                        case "OrderBy":
                        case "OrderByDescending":
                            if (!isParametersEnumerable.Any())
                            {
                                Expression previousExpression = parameters[0];
                                MethodCallExpression previousMethodCallExpression;
                                MethodInfo previousMethod;
                                while ((previousMethodCallExpression = previousExpression as MethodCallExpression) != null && (previousMethod = previousMethodCallExpression.Method).DeclaringType == typeof(Queryable))
                                {
                                    switch (previousMethod.Name)
                                    {
                                        case "Select":
                                        case "SelectMany":
                                        case "GroupBy":
                                        case "GroupJoin":
                                        case "Join":
                                        case "Reverse":
                                        case "Union":
                                        case "Take":
                                        case "Skip":
                                            return null;
                                        case "OrderBy":
                                        case "OrderByDescending":
                                            return parameters[0].ReplaceMethodCall(previousMethodCallExpression, Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == previousMethod.Name.Replace("OrderBy", "ThenBy") && m.GetParameters().Length == 2).MakeGenericMethod(previousMethod.GetGenericArguments()), Expression.Call(method, previousMethodCallExpression.Arguments[0], parameters[1]), previousMethodCallExpression.Arguments[1]));
                                    }
                                    if ((previousExpression = previousMethodCallExpression.Arguments.FirstOrDefault()) == null)
                                        break;
                                }
                            }
                            break;
                    }
                }
    
                return WAQSL2EExpressionTransformation.TransformMethodCall(source, method, parameters, _objectContext) ?? base.VisitMethodCall(source, method, parameters, isParametersEnumerable); 
            }
                                    
            protected override Expression GetPropertyGetterExpression(Expression source, PropertyInfo property)
            {
                if (property.Name == "Count" && source.Type.IsGenericType && typeof(Collection<>).MakeGenericType(source.Type.GetGenericArguments()[0]).IsAssignableFrom(source.Type))
                    return Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(source.Type.GetGenericArguments()[0]), source);
                return WAQSL2EExpressionTransformation.TransformProperty(source, property, _objectContext) ?? base.GetPropertyGetterExpression(source, property);
            }
                                
            protected override Expression GetSpecificProperty(string propertyName)
            {
                switch (propertyName)
                {
                    case "DbDateTime":
                        return _objectContext.GetDbDateTimeExpression();
                }
                Expression value = null;
                GetSpecificProperty(propertyName, ref value);
                return value ?? base.GetSpecificProperty(propertyName);
            }
            partial void GetSpecificProperty(string propertyName, ref Expression expression);
        
            protected internal override void VisitUnary(SerializableUnaryExpression expression)
            {
                base.VisitUnary(expression);
                var exp = (UnaryExpression)_expressionReference.Value;
                if (exp.NodeType == ExpressionType.Convert && exp.Type.GetCustomAttributes(typeof(DataContractAttribute), false).Any())
                    _expressionReference.Value = Expression.TypeAs(exp.Operand, exp.Type);
            }
                                    
            public Type GetEntityType(Type type)
            {
                return _serializableExpressionConverter.GetBaseType(type) ?? type;
            }
                                    
            public static object Convert(object obj)
            {
                if (obj == null)
                    return null;
                                    
                Func<object, object> convert;
                if (_dtoToEntityCache.TryGetValue(obj.GetType(), out convert))
                    return convert(obj);
                return obj;
            }
                        
            public static Type GetOriginalType(Type type)
            {
                Type value;
                return _dtoToEntityTypeCache.TryGetValue(type, out value) ? value : type;
            }
    
            protected override void MakeBinary(SerializableBinaryExpression source, Expression leftExpression, Expression rightExpression)
            {
                if ((_expressionReference.Value = WAQSL2EExpressionTransformation.TransformBinary(source.NodeType, leftExpression, rightExpression, _objectContext)) == null)
                    base.MakeBinary(source, leftExpression, rightExpression);
            }
        }
    }
}
