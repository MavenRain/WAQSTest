//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using WCFAsyncQueryableServices.EntitiesTracking;

namespace WCFAsyncQueryableServices.ClientContext.Interfaces.ExpressionSerialization
{
    [DataContract(Namespace = "http://WCFAsyncQueryableServices/QuerySerialization", IsReference = true)]
    public partial class SerializableType
    {
        public SerializableType()
        {
        }
        public SerializableType(Type type)
        {
            ReplaceType(ref type);
            Type = type;
        }
        partial void ReplaceType(ref Type type);
        
        private Type GetType(Type type)
        {
            if (typeof(IAsyncQueryableBase).IsAssignableFrom(type))
            {
                if (type.IsGenericType && type.GetGenericArguments().Length == 1)
                {
                    if (type.GetGenericTypeDefinition() == typeof(IAsyncQueryable<>))
                        return typeof(IQueryable<>).MakeGenericType(GetType(type.GetGenericArguments()[0]));
                    else if (type.GetGenericTypeDefinition() == typeof(IAsyncQueryableValue<>))
                        return GetType(type.GetGenericArguments()[0]);
                }
                else if (type == typeof(IAsyncQueryable))
                    return typeof(IQueryable);
                throw new InvalidOperationException();
            }
            return type;
        }
        
        [DataMember]
        public string TypeName { get; set; }
        [DataMember]
        public string NamespaceName { get; set; }
        [DataMember]
        public string WCFNamespaceName { get; set; }
        [DataMember]
        public List<SerializableType> GenericArguments { get; set; }
        [DataMember]
        public SerializableType ArrayOf { get; set; }
        [DataMember]
        public bool IsKnownByServer { get; set; }
        [DataMember]
        public List<SerializablePropertyExpression> Properties { get; set; }
    
        private Type _type;
        public Type Type
        {
            get { return _type; }
            private set 
            { 
                _type = value;
                value = GetType(value);
                GenericArguments = value.GetGenericArguments().Select(a => new SerializableType(a)).ToList();
                TypeName = Regex.Replace(value.Name, @"`(\d+)$", m =>
                {
                    var sb = new StringBuilder();
                    sb.Append("<");
                    for (int i = 1, count = int.Parse(m.Groups[1].Value); i < count; i++)
                        sb.Append(",");
                    sb.Append(">");
                    return sb.ToString();
                });
                NamespaceName = value.Namespace;
                WCFNamespaceName = value.GetCustomAttributes(typeof(DataContractAttribute), true).OfType<DataContractAttribute>().Select(dc => dc.Namespace).FirstOrDefault();
                if (value.IsArray)
                    ArrayOf = new SerializableType(value.GetElementType());
                if (value.Namespace == null || !(IsKnownByServer = WCFNamespaceName != null || typeof(IClientContext).IsAssignableFrom(value) || value.Namespace.StartsWith("System") || ArrayOf != null && ArrayOf.IsKnownByServer || value.GetCustomAttributes(true).OfType<IsKnownByServerAttribute>().Any()))
                    Properties = value.GetProperties().Where(p => p.CanRead && (p.CanWrite || value.Name.StartsWith("<>f__AnonymousType"))).Select(p => new SerializablePropertyExpression(new SerializableType(p.PropertyType), p.Name)).ToList();
            }
        }
    }
}
