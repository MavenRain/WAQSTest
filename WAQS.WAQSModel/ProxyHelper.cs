//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.ServiceModel;
using System.Threading.Tasks;

namespace WCFAsyncQueryableServices.ClientContext
{
    public static class ProxyHelper
    {
        public static async Task<TResult> ExecuteFuncAsync<T, TResult>(Func<T> factory, Func<T, Task<TResult>> action, int nbRetryOnTimeout = 0)
            where T : ICommunicationObject, IDisposable
        {
            for (int tryIndex = 1; ; tryIndex++)
                using (var service = factory())
                {
                    try
                    {
                        var value = await action(service);
                        service.Close();
                        return value;
                    }
                    catch (TimeoutException te)
                    {
                        service.Abort();
                        if (tryIndex > nbRetryOnTimeout)
                            throw te;
                    }
                    catch (Exception e)
                    {
                        service.Abort();
                        throw e;
                    }
                }
        }
    
        public static async Task ExecuteActionAsync<T>(Func<T> factory, Func<T, Task> action, int nbRetryOnTimeout = 0)
            where T : ICommunicationObject, IDisposable
        {
            for (int tryIndex = 1; ; tryIndex++)
                using (var service = factory())
                {
                    try
                    {
                        await action(service);
                        service.Close();
                        return;
                    }
                    catch (TimeoutException te)
                    {
                        service.Abort();
                        if (tryIndex > nbRetryOnTimeout)
                            throw te;
                    }
                    catch (Exception e)
                    {
                        service.Abort();
                        throw e;
                    }
                }
        }
    }
}
