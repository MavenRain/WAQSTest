//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Core;
using System.Data.Entity.Core.Objects;
using System.Linq;
using System.Threading.Tasks;

namespace WCFAsyncQueryableServices.DAL
{
    public partial class ExceptionHandlerObjectContext<T> : ObjectContextCustomizer<ExceptionHandlerObjectContext<T>> where T : ObjectContext, new()
    {
        protected override int SaveChanges(ObjectContext context, SaveOptions options, Func<SaveOptions, int> baseSaveChanges)
        {
            _entities.Clear();
            return SaveChangesInternal(context, options, baseSaveChanges);
        }
        private int SaveChangesInternal(ObjectContext context, SaveOptions options, Func<SaveOptions, int> baseSaveChanges)
        { 
            int value = 0;
            try
            {
                value = baseSaveChanges(options);
            }
            catch (OptimisticConcurrencyException e)
            {
                using (var contextTmp = new T())
                {
                    contextTmp.MetadataWorkspace.LoadFromAssembly(context.GetType().Assembly);
                    if (DetachAlreadyDeletedEntities(e, contextTmp)) 
                        SaveChanges(context, options, baseSaveChanges);
                    else
                        HandleOrReThrow(e);
                }
            }
            catch (Exception e)
            {
                HandleOrReThrow(e);
            }
            return value;
        }
    
        private HashSet<object> _entities = new HashSet<object>();
    
        private bool DetachAlreadyDeletedEntities(OptimisticConcurrencyException e, T contextTmp)
        {
            //rajouter une condition si on a d�j� eu le pb sur l'entit� => throw
            bool canHandle = true;
            return e.StateEntries.Any() && e.StateEntries.Select(se =>
                {
                    if (se.State != EntityState.Deleted)
                        return false;
    
                    object dbEntity;
                    if (contextTmp.TryGetObjectByKey(se.EntityKey, out dbEntity))
                    {
                        if (_entities.Contains(se.Entity))
                            return false;
                        _entities.Add(se.Entity);
                        ObjectContext.ApplyOriginalValues(se.EntitySet.Name, dbEntity); // In case of ConcurrencyMode = fixed
                    }
                    else
                        ObjectContext.Detach(se.Entity);
    
                    return true;
                }).TakeWhile(b => canHandle).Aggregate((b1, b2) => canHandle = b2);// Aggregate for execute select on each of them
        }
    
        private void HandleOrReThrow(Exception e)
        {
            bool handled = false;
            HandleException(e, ref handled);
            if (!handled)
                throw e;
        }
    
        partial void HandleException(Exception e, ref bool handled);
    
        protected async override Task<int> SaveChangesAsync(ObjectContext context, SaveOptions options, Func<SaveOptions, Task<int>> baseSaveChangesAsync)
        {
            _entities.Clear();
            return await SaveChangesAsyncInternal(context, options, baseSaveChangesAsync);
        }
        private async Task<int> SaveChangesAsyncInternal(ObjectContext context, SaveOptions options, Func<SaveOptions, Task<int>> baseSaveChangesAsync)
        {
            int value = 0;
            OptimisticConcurrencyException optimisticConcurrencyException = null;
            try
            {
                value = await baseSaveChangesAsync(options);
            }
            catch (OptimisticConcurrencyException e)
            {
                optimisticConcurrencyException = e;
            }
            catch (Exception e)
            {
                HandleOrReThrow(e);
            }
            if (optimisticConcurrencyException != null)
            {
                using (var contextTmp = new T())
                {
                    contextTmp.MetadataWorkspace.LoadFromAssembly(context.GetType().Assembly);
                    if (DetachAlreadyDeletedEntities(optimisticConcurrencyException, contextTmp))
                        try
                        {
                            value = await SaveChangesAsync(context, options, baseSaveChangesAsync);
                        }
                        catch (Exception e2)
                        {
                            HandleOrReThrow(e2);
                        }
                    else
                        HandleOrReThrow(optimisticConcurrencyException);
                }
            }
            return value;
        }
    }
}
