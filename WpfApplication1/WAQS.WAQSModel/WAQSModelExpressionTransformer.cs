//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using WCFAsyncQueryableServices.ClientContext.Interfaces.ExpressionSerialization;

namespace WpfApplication1.ClientContext
{
    public class WAQSModelExpressionTransformer : IExpressionTransformer
    {
        public Expression TransformExpression(Expression expression)
        {
            var methodCallExpression = expression as MethodCallExpression;
            MethodInfo method;
            if (methodCallExpression != null && (method = methodCallExpression.Method).Name == "Contains" && (method.DeclaringType == typeof(Enumerable) || typeof(IEnumerable).IsAssignableFrom(method.DeclaringType)))
            {
                int argIndex = 0;
                MemberExpression memberExpression;
                if (methodCallExpression.Object == null)
                    memberExpression = methodCallExpression.Arguments[argIndex++] as MemberExpression;
                else
                    memberExpression = methodCallExpression.Object as MemberExpression;
                if (memberExpression != null && memberExpression.Expression is ConstantExpression)
                {
                    if (typeof(IEnumerable<WpfApplication1.Entity1>).IsAssignableFrom(memberExpression.Type))
                    {
                        var entitiesKeys = Expression.Lambda<Func<IEnumerable<WpfApplication1.Entity1>>>(memberExpression).Compile()().Select(e => e.Id);
                        var exp = (Expression<Func<IEnumerable<int>>>)(() => entitiesKeys);
                        return Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(int)), exp.Body, Expression.MakeMemberAccess(methodCallExpression.Arguments[argIndex], typeof(WpfApplication1.Entity1).GetProperty("Id")));
                    }
                }
                else
                {
                    var methodArg = methodCallExpression.Arguments[argIndex] as MemberExpression;
                    if (methodArg != null && methodArg.Expression is ConstantExpression)
                    {
                        if (methodArg.Type == typeof(Entity1))
                        {
                            var entity = Expression.Lambda<Func<Entity1>>(methodArg).Compile()();
                            var exp = (Expression<Func<Entity1, bool>>)(e => e.Id == entity.Id);
                            return Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(Entity1)), memberExpression, exp);
                        }
                    }
                }
            }
            else
            {
                var binaryExpression = expression as BinaryExpression;
                MemberExpression leftMemberExpression, rightMemberExpression;
                if (binaryExpression != null && (binaryExpression.NodeType == ExpressionType.Equal || binaryExpression.NodeType == ExpressionType.NotEqual) && binaryExpression.Left.Type == typeof(Entity1) && ((leftMemberExpression = binaryExpression.Left as MemberExpression) != null && leftMemberExpression.Expression is ConstantExpression || (rightMemberExpression = binaryExpression.Right as MemberExpression) != null && rightMemberExpression.Expression is ConstantExpression))
                {
                    PropertyInfo propertyInfo;
                    return Expression.MakeBinary(binaryExpression.NodeType, Expression.MakeMemberAccess(binaryExpression.Left, propertyInfo = typeof(Entity1).GetProperty("Id")), Expression.MakeMemberAccess(binaryExpression.Right, propertyInfo));
                }
            }
            return expression;
        }
    }
}
