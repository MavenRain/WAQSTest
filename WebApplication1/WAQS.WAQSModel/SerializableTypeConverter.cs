//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Text.RegularExpressions;
using System.Threading;
using WCFAsyncQueryableServices.Entities;

namespace WCFAsyncQueryableServices.SerializableExpressions
{
    public static partial class SerializableTypeConverter
    {
        private static ConcurrentDictionary<long, Lazy<WeakReference>> _anonymousTypesCache;
        private static ConcurrentDictionary<long, Lazy<WeakReference>> AnonymousTypesCache
        {
            get { return _anonymousTypesCache ?? (_anonymousTypesCache = new ConcurrentDictionary<long, Lazy<WeakReference>>()); }
        }
            
        public static Type ToType(this SerializableType serializableType, ISerializableExpressionConverter serializableExpressionConverter, bool getTypeInLinq = true)
        {
            Type value = null;
            ToType(serializableType, serializableExpressionConverter, ref value);
            if (value != null)
                return value;
            
            string typeName = serializableType.TypeName;
            typeName = Regex.Replace(typeName, @"<(,*)>$", m => "`" + (m.Groups[1].Length + 1).ToString());
            typeName = typeName.Replace(@"\[\]", "[]");
            if (serializableType.ArrayOf != null)
                return serializableExpressionConverter.GetTypeInLINQ(serializableType.ArrayOf.ToType(serializableExpressionConverter, getTypeInLinq).MakeArrayType());
            if (serializableType.IsKnownByServer)
            {
                string fullTypeName = string.Format("{0}.{1}", serializableType.NamespaceName, typeName);
                value = Type.GetType(fullTypeName);
                if (value == null && Regex.IsMatch(serializableType.NamespaceName, "^System.Linq(.?|$)"))
                    value = typeof(Expression).Assembly.GetType(fullTypeName);
                if (value == null && Regex.IsMatch(serializableType.NamespaceName, "^System.Collections.ObjectModel(.?|$)"))
                    value = typeof(ObservableCollection<>).Assembly.GetType(fullTypeName);
                if (value == null && typeName == "TrackableCollection`1")
                    value = typeof(TrackableCollection<>);
                GetType(fullTypeName, serializableType, ref value);
                if (value == null)
                {
                    if (serializableType.WCFNamespaceName != null)
                    {
                        value = serializableExpressionConverter.GetTypeFromWCFNamespace(serializableType, typeName);
                        if (value != null)
                            return serializableExpressionConverter.GetTypeInLINQ(value);
                    }
                    throw new NotImplementedException();
                }
                else if (serializableType.GenericArguments != null && serializableType.GenericArguments.Count != 0)
                    value = value.MakeGenericType(serializableType.GenericArguments.Select(ga => ga.ToType(serializableExpressionConverter, getTypeInLinq)).ToArray());
                return (getTypeInLinq && serializableExpressionConverter != null) ? serializableExpressionConverter.GetTypeInLINQ(value) : value;
            }
            else
                return GetAnonymousType(serializableType, serializableExpressionConverter, typeName, getTypeInLinq);
        }
    
        static partial void GetType(string fullTypeName, SerializableType serializableType, ref Type value);
            
        static partial void ToType(SerializableType serializableType, ISerializableExpressionConverter serializableExpressionConverter, ref Type value);
    
        private static Type GetAnonymousType(SerializableType serializableType, ISerializableExpressionConverter serializableExpressionConverter, string typeName, bool getTypeInLinq)
        {
            Func<SerializableType, Type> buildType = st =>
                {
                    typeName = (typeName ?? st.TypeName).Replace("<>", "");
                    typeName = typeName.Replace("`", "");
                    var assemblyName = new AssemblyName(typeName + Guid.NewGuid().ToString());
                    var appDomain = Thread.GetDomain();
                    var assemblyBuilder = appDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
                    var moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
                    var typeBuilder = moduleBuilder.DefineType(typeName, TypeAttributes.Public);
                    Dictionary<string, Type> propertiesDefinition = new Dictionary<string, Type>();
                    foreach (var prop in st.Properties)
                    {
                        Type propType = prop.Type.ToType(serializableExpressionConverter, getTypeInLinq);
                        propType = serializableExpressionConverter.GetTypeInLINQ(propType);
                        propertiesDefinition.Add(prop.Name, propType);
                        var fieldBuilder = typeBuilder.DefineField("_" + prop.Name, propType, FieldAttributes.Private);
                        var propBuilder = typeBuilder.DefineProperty(prop.Name, PropertyAttributes.None, propType, null);
                        MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig;
                        MethodBuilder propGetBuilder = typeBuilder.DefineMethod("get_" + prop.Name, getSetAttr, propType, Type.EmptyTypes);
                        ILGenerator propGetIL = propGetBuilder.GetILGenerator();
                        propGetIL.Emit(OpCodes.Ldarg_0);
                        propGetIL.Emit(OpCodes.Ldfld, fieldBuilder);
                        propGetIL.Emit(OpCodes.Ret);
                        MethodBuilder propSetBuilder = typeBuilder.DefineMethod("set_" + prop.Name, getSetAttr, null, new Type[] { propType });
                        ILGenerator propSetIL = propSetBuilder.GetILGenerator();
                        propSetIL.Emit(OpCodes.Ldarg_0);
                        propSetIL.Emit(OpCodes.Ldarg_1);
                        propSetIL.Emit(OpCodes.Stfld, fieldBuilder);
                        propSetIL.Emit(OpCodes.Ret);
                        propBuilder.SetGetMethod(propGetBuilder);
                        propBuilder.SetSetMethod(propSetBuilder);
                    }
                    return typeBuilder.CreateType();
                };
            for (; ; )
            {
                WeakReference weakReference = AnonymousTypesCache.GetOrAdd(serializableType.GetHashCode(), hash => new Lazy<WeakReference>(() => new WeakReference(buildType(serializableType)))).Value;
                var value = (Type)weakReference.Target;
                if (value != null)
                    return value;
                Lazy<WeakReference> dummy;
                AnonymousTypesCache.TryRemove(serializableType.GetHashCode(), out dummy);
            }
        }
    }
}
