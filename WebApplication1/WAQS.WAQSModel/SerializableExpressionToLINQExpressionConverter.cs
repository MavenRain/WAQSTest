//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Text;
using WCFAsyncQueryableServices.SerializableExpressions;
using WCFAsyncQueryableServices.Common;
using WCFAsyncQueryableServices.Specifications;

namespace WCFAsyncQueryableServices.Service
{
    public static partial class SerializableExpressionToLINQExpressionConverter
    {
        public static Expression ToLINQExpression(this SerializableExpression serializableExpression, IEnumerable<string> withSpecificationsProperties, ISerializableExpressionConverter serializableExpressionConverter)
        {
            var expressionReference = new Reference<Expression>();
            new Visitor(expressionReference, withSpecificationsProperties, serializableExpressionConverter).Visit(serializableExpression);
            return OptimizeSelect(expressionReference.Value, serializableExpressionConverter, type => type);
        }
            
        internal static Expression OptimizeSelect(Expression expression, ISerializableExpressionConverter serializableExpressionConverter, Func<Type, Type> getConstructorType)
        {
            var dependentProperties = new List<List<PropertyInfo>>();
            Expression queryableExpression = expression;
            MethodCallExpression previousMethodCallExpression;
            while ((previousMethodCallExpression = queryableExpression as MethodCallExpression) != null && previousMethodCallExpression.Method.DeclaringType == typeof(Enumerable))
                queryableExpression = previousMethodCallExpression.Arguments[0];
            if (expression == queryableExpression)
                return expression;
            new SelectOptimizerVisitor(queryableExpression, dependentProperties, serializableExpressionConverter).Visit(expression);
            if (dependentProperties.Count == 0)
                return expression;
            Type parameterType;
            var queryableType = queryableExpression.Type.GetGenericArguments()[0];
            if (expression.Type.IsGenericType ? expression.Type.GetGenericArguments()[0].IsAssignableFrom(queryableType) : expression.Type.IsAssignableFrom(queryableType))
                return expression;
            var newQueryableType = getConstructorType(queryableType);
            var selectParameter = Expression.Parameter(queryableType);
            List<string> properties = new List<string>();
            var distinctDependentProperties = dependentProperties.Select(ps =>
                {
                    var sb = new StringBuilder();
                    foreach (var p in ps)
                    {
                        sb.Append(p.Name);
                        sb.Append(".");
                    }
                    string propertyName = sb.ToString();
                    if (properties.Contains(propertyName))
                        return null;
                    properties.Add(propertyName);
                    return ps;
                }).Where(ps => ps != null).ToList();
            expression = expression.ReplaceExpression(queryableExpression, Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && (parameterType = m.GetParameters()[1].ParameterType).IsGenericType && (parameterType = parameterType.GetGenericArguments()[0]).IsGenericType && parameterType.GetGenericArguments().Length == 2).MakeGenericMethod(queryableType, newQueryableType), queryableExpression, Expression.Lambda(OptimizeSelectExpression(serializableExpressionConverter, getConstructorType, newQueryableType, distinctDependentProperties, selectParameter), selectParameter)));
            return expression;
        }
            
        private static Expression OptimizeSelectExpression(ISerializableExpressionConverter serializableExpressionConverter, Func<Type, Type> getConstructorType, Type newQueryableType, IEnumerable<IEnumerable<PropertyInfo>> dependentProperties, Expression selectParameter)
        {
            return Expression.MemberInit(Expression.New(newQueryableType), dependentProperties.GroupBy(dp => dp.First().Name).Select(ps =>
                {
                    var p = ps.First().First();
                    if (ps.Any(ps2 => ps2.Skip(1).Any()))
                    {
                        if (ps.Any(ps2 => !ps2.Skip(1).Any()))
                            return Expression.Bind(p, Expression.MakeMemberAccess(selectParameter, p));
                        return Expression.Bind(p, OptimizeSelectExpression(serializableExpressionConverter, getConstructorType, getConstructorType(p.PropertyType), ps.Select(ps2 => ps2.Skip(1).ToList()).Where(ps2 => ps2.Count != 0), Expression.MakeMemberAccess(selectParameter, p)));
                    }
                    else
                    {
                        if (p.GetCustomAttributes(typeof(SpecificationsAttribute), true).Length == 0)
                            return Expression.Bind(p, Expression.MakeMemberAccess(selectParameter, p));
                        var exp = (LambdaExpression)serializableExpressionConverter.GetSpecificationLINQExpression(p);
                        return Expression.Bind(p, exp.Body.ReplaceParameter(exp.Parameters[0], selectParameter));
                    }
                }));
        }
            
        public static Expression GetConstantExpression(object value, Type type)
        {
            var expressionReference = new Reference<Expression>();
            new Visitor(expressionReference, null, null).VisitConstant(type, value);
            return expressionReference.Value;
        }
            
        public partial class Visitor : SerializableExpressionVisitor
        {
            protected Type _type;
            protected Reference<Expression> _expressionReference;
            protected IEnumerable<string> _withSpecificationsProperties;
            protected ISerializableExpressionConverter _serializableExpressionConverter;
            protected Dictionary<string, ParameterExpression> _lambdaParameters;
            protected Dictionary<Expression, bool> _isEnumerableExpressions;
            
            public Visitor(Reference<Expression> expressionReference, IEnumerable<string> withSpecificationsProperties, ISerializableExpressionConverter serializableExpressionConverter)
                : this(expressionReference, withSpecificationsProperties, serializableExpressionConverter, new Dictionary<string, ParameterExpression>(), false, new Dictionary<Expression, bool>())
            {
            }
            
            protected Visitor(Reference<Expression> expressionReference, IEnumerable<string> withSpecificationsProperties, ISerializableExpressionConverter serializableExpressionConverter, Dictionary<string, ParameterExpression> lambdaParameters, bool isEnumerable, Dictionary<Expression, bool> isEnumerableExpressions)
            {
                _expressionReference = expressionReference;
                _withSpecificationsProperties = withSpecificationsProperties;
                _serializableExpressionConverter = serializableExpressionConverter;
                _lambdaParameters = lambdaParameters;
                IsEnumerable = isEnumerable;
                _isEnumerableExpressions = isEnumerableExpressions;
            }
            
            public bool IsEnumerable { get; protected set; }
            
            private Func<Reference<Expression>, IEnumerable<string>, ISerializableExpressionConverter, Dictionary<string, ParameterExpression>, bool, Dictionary<Expression, bool>, Visitor> _visitorFactory;
            protected Func<Reference<Expression>, IEnumerable<string>, ISerializableExpressionConverter, Dictionary<string, ParameterExpression>, bool, Dictionary<Expression, bool>, Visitor> VisitorFactory
            {
                get { return _visitorFactory; }
                set { _visitorFactory = value; }
            }
            protected Visitor CreateNewVisitor(Reference<Expression> expressionReference, Dictionary<string, ParameterExpression> lambdaParameters = null)
            {
                return CreateNewVisitor(expressionReference, null, lambdaParameters);
            }
            protected Visitor CreateNewVisitor(Reference<Expression> expressionReference, IEnumerable<string> withSpecificationsProperties, Dictionary<string, ParameterExpression> lambdaParameters = null)
            {
                if (lambdaParameters == null)
                    lambdaParameters = _lambdaParameters;
                if (VisitorFactory == null)
                    return new Visitor(expressionReference, withSpecificationsProperties, _serializableExpressionConverter, lambdaParameters, IsEnumerable, _isEnumerableExpressions);
                return VisitorFactory(expressionReference, withSpecificationsProperties, _serializableExpressionConverter, lambdaParameters, IsEnumerable, _isEnumerableExpressions);
            }
            
            public override void Visit(SerializableExpression expression)
            {
                if (expression == null)
                    return;
                base.Visit(expression);
                if (_withSpecificationsProperties != null && _withSpecificationsProperties.Any())
                {
                    var parameterType = _expressionReference.Value.Type.GetGenericArguments()[0];
                    Type genericType;
                    var enumerableSelectParameter = Expression.Parameter(parameterType);
                    var enumerableSelectMethod = typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && (genericType = m.GetParameters()[1].ParameterType).IsGenericType && genericType.GetGenericArguments().Length == 2);
                    var properties = _withSpecificationsProperties.Select(wsp => _serializableExpressionConverter.GetProperty(parameterType, wsp)).Select(p => new { Property = p, Expression = _serializableExpressionConverter.GetSpecificationLINQExpression(p, parameterType) }).ToList();
                    var queryableProperties = properties.Where(p => p.Expression != null).ToList();
                    var enumerableProperties = properties.Where(p => p.Expression == null).Select(p => p.Property).ToList();
                    if (queryableProperties.Count != 0)
                    {
                        Expression originalQueryableExp;
                        ParameterExpression queryableSelectParameter = Expression.Parameter(parameterType);
                        Expression queryableSelectParameterExp = queryableSelectParameter;
                        if (IsEnumerable)
                        {
                            ParameterExpression queryableSelectParameterTmp;
                            originalQueryableExp = ExtractQueryable(_expressionReference.Value, out queryableSelectParameterExp, out queryableSelectParameterTmp);
                            if (queryableSelectParameterTmp != null)
                            {
                                if (queryableSelectParameterTmp.Type != queryableSelectParameter.Type || originalQueryableExp == null)
                                {
                                    enumerableProperties.AddRange(queryableProperties.Select(p => p.Property));
                                    queryableProperties.Clear();
                                }
                                else
                                    queryableSelectParameterExp = queryableSelectParameterExp.ReplaceParameter(queryableSelectParameterTmp, queryableSelectParameter);
                            }
                            else
                                queryableSelectParameterExp = queryableSelectParameter;
                        }
                        else
                            originalQueryableExp = _expressionReference.Value;
                        if (queryableProperties.Count != 0)
                        {
                            var withType = _serializableExpressionConverter.GetWithType(parameterType);
                            var queryableExp = Expression.Call(typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && (genericType = m.GetParameters()[1].ParameterType).IsGenericType && genericType.GetGenericArguments().Length == 1 && (genericType = genericType.GetGenericArguments()[0]).IsGenericType && genericType.GetGenericArguments().Length == 2).MakeGenericMethod(parameterType, withType), originalQueryableExp, Expression.Quote(Expression.Lambda(Expression.MemberInit(Expression.New(withType.GetConstructor(new Type[0])), new MemberBinding[] { Expression.Bind(withType.GetProperty((_serializableExpressionConverter.GetBaseType(parameterType) ?? parameterType).Name), queryableSelectParameter) }.Union(queryableProperties.Select(p =>
                                                            {
                                                                LambdaExpression lambda = (LambdaExpression)p.Expression;
                                                                return Expression.Bind(p.Property, lambda.Body.ReplaceParameter(lambda.Parameters[0], queryableSelectParameterExp));
                                                            }))), queryableSelectParameter)));
                            _isEnumerableExpressions.Add(queryableExp, false);
                            _expressionReference.Value = _expressionReference.Value.ReplaceExpression(originalQueryableExp, queryableExp);
                        }
                    }
                    if (enumerableProperties.Count != 0)
                    {
                        _expressionReference.Value = Expression.Call(enumerableSelectMethod.MakeGenericMethod(parameterType, parameterType), _expressionReference.Value, Expression.Lambda(Expression.Block(/*enumerableProperties.Select(p => (Expression)Expression.Assign(Expression.MakeMemberAccess(enumerableSelectParameter, p), _serializableExpressionConverter.GetSpecificationMethod(enumerableSelectParameter, p))).Union(new Expression[] { enumerableSelectParameter })*/), enumerableSelectParameter));
                    }
                }
                if (!_isEnumerableExpressions.ContainsKey(_expressionReference.Value))
                    _isEnumerableExpressions.Add(_expressionReference.Value, IsEnumerable);
            }
            
            public virtual IEnumerable<KeyValuePair<PropertyInfo, Expression>> GetLINQUsableProperties(Type type, ParameterExpression selectParameter, out List<PropertyInfo> notSupportedLINQProperties)
            {
                var lambdaNotSupportedLINQProperties = notSupportedLINQProperties = new List<PropertyInfo>();
                return _serializableExpressionConverter.GetScalarAndComplexProperties(type).Select(p => new KeyValuePair<PropertyInfo, Expression>(p, Expression.MakeMemberAccess(selectParameter, p)))
                    .Union(_withSpecificationsProperties.Select(p =>
                    {
                        Type baseType = _serializableExpressionConverter.GetBaseType(type) ?? type;
                        var dalSpecification = (LambdaExpression)_serializableExpressionConverter.GetSpecificationLINQExpression(type.GetProperty(p));
                        if (dalSpecification == null)
                        {
                            var propertyInfo = type.GetProperty(p);
                            lambdaNotSupportedLINQProperties.Add(propertyInfo);
                            return new KeyValuePair<PropertyInfo, Expression>(propertyInfo, null);
                        }
                        return new KeyValuePair<PropertyInfo, Expression>(type.GetProperty(p), dalSpecification.Body.ReplaceParameter(dalSpecification.Parameters[0], selectParameter));
                    }));
            }
            
            private ParameterExpression GetParameterExpression(SerializableParameterExpression expression, Dictionary<string, ParameterExpression> lambdaParameters = null)
            {
                if (lambdaParameters == null)
                    lambdaParameters = _lambdaParameters;
                ParameterExpression value;
                if (!lambdaParameters.TryGetValue(expression.Name, out value))
                    lambdaParameters.Add(expression.Name, value = Expression.Parameter(expression.Type.ToType(_serializableExpressionConverter), expression.Name));
                return value;
            }
            
            protected internal override void VisitTypeBinary(SerializableTypeBinaryExpression expression)
            {
                Reference<Expression> exp = new Reference<Expression>();
                var expVisitor = CreateNewVisitor(exp);
                expVisitor.Visit(expression.Expression);
                switch (EnumUtils.GetEnumValue<ExpressionType>(expression.NodeType))
                {
                    case ExpressionType.TypeIs:
                        _expressionReference.Value = Expression.TypeIs(exp.Value, expression.TypeOperand.ToType(_serializableExpressionConverter));
                        break;
                    case ExpressionType.TypeAs:
                        _expressionReference.Value = Expression.TypeAs(exp.Value, expression.TypeOperand.ToType(_serializableExpressionConverter));
                        break;
                }
            }
            
                
            protected internal override void VisitBinary(SerializableBinaryExpression expression)
            {
                Reference<Expression> leftExpression = new Reference<Expression>(), rightExpression = new Reference<Expression>();
                var leftVisitor = CreateNewVisitor(leftExpression);
                leftVisitor.Visit(expression.Left);
                var rightVisitor = CreateNewVisitor(rightExpression);
                rightVisitor.Visit(expression.Right);
                if (leftVisitor.IsEnumerable || rightVisitor.IsEnumerable)
                    IsEnumerable = true;
                MakeBinary(expression, leftExpression.Value, rightExpression.Value);
            }
        
            protected virtual void MakeBinary(SerializableBinaryExpression source, Expression leftExpression, Expression rightExpression)
            {
                switch (source.NodeType)
                {
                    case "Add":
                        if (leftExpression.Type == typeof(string))
                        {
                            _expressionReference.Value = Expression.Add(leftExpression, rightExpression, typeof(string).GetMethod("Concat", new Type[] { typeof(string), typeof(string) }));
                            return;
                        }
                        break;
                }
                _expressionReference.Value = Expression.MakeBinary(EnumUtils.GetEnumValue<ExpressionType>(source.NodeType), leftExpression, rightExpression);
            }
                    
            protected internal override void VisitConstant(SerializableConstantExpression expression)
            {
                Type type = expression.Type.ToType(_serializableExpressionConverter);
                object value = expression.Value;
                VisitConstant(type, value);
            }
            
            public void VisitConstant(Type type, object value)
            {
                if (value == null)
                    _expressionReference.Value = Expression.Constant(value);
                else if (type == typeof(int))
                    VisitConstant<int>(value);
                else if (type == typeof(uint))
                    VisitConstant<uint>(value);
                else if (type == typeof(short))
                    VisitConstant<short>(value);
                else if (type == typeof(ushort))
                    VisitConstant<ushort>(value);
                else if (type == typeof(byte))
                    VisitConstant<byte>(value);
                else if (type == typeof(long))
                    VisitConstant<long>(value);
                else if (type == typeof(ulong))
                    VisitConstant<ulong>(value);
                else if (type == typeof(decimal))
                    VisitConstant<decimal>(value);
                else if (type == typeof(double))
                    VisitConstant<double>(value);
                else if (type == typeof(char))
                    VisitConstant<char>(value);
                else if (type == typeof(DateTime))
                    VisitConstant<DateTime>(value);
                else if (type == typeof(TimeSpan))
                    VisitConstant<TimeSpan>(value);
                else if (type == typeof(int?))
                    VisitConstant<int?>(value);
                else if (type == typeof(uint?))
                    VisitConstant<uint?>(value);
                else if (type == typeof(short?))
                    VisitConstant<short?>(value);
                else if (type == typeof(ushort?))
                    VisitConstant<ushort?>(value);
                else if (type == typeof(byte?))
                    VisitConstant<byte?>(value);
                else if (type == typeof(long?))
                    VisitConstant<long?>(value);
                else if (type == typeof(ulong?))
                    VisitConstant<ulong?>(value);
                else if (type == typeof(decimal?))
                    VisitConstant<decimal?>(value);
                else if (type == typeof(double?))
                    VisitConstant<double?>(value);
                else if (type == typeof(char?))
                    VisitConstant<char?>(value);
                else if (type == typeof(DateTime?))
                    VisitConstant<DateTime?>(value);
                else if (type == typeof(TimeSpan?))
                    VisitConstant<TimeSpan?>(value);
                else if (type == typeof(string))
                    VisitConstant<string>(value);
                else if (typeof(Enum).IsAssignableFrom(type) || type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && typeof(Enum).IsAssignableFrom(type.GetGenericArguments()[0]))
                    typeof(Visitor).GetMethods(BindingFlags.NonPublic | BindingFlags.Instance).Single(m => m.Name == "VisitConstant" && m.IsGenericMethod).MakeGenericMethod(type).Invoke(this, new object[] { value });
                else
                    _expressionReference.Value = Expression.Constant(value);
            }
            protected void VisitConstant<T>(dynamic value)
            {
                T constant = (T)value;
                Expression<Func<T>> exp = () => constant;
                _expressionReference.Value = exp.Body;
            }
            
            protected internal override void VisitConstructor(SerializableConstructorExpression expression)
            {
                _type = GetConstructorType(expression.Type.ToType(_serializableExpressionConverter));
                Expression value = GetConstructorExpression(_type, expression);
                if (value != null)
                {
                    _expressionReference.Value = value;
                    return;
                }
                if (expression.Arguments.Any(a =>
                    {
                        Reference<Expression> argumentExpression = new Reference<Expression>();
                        var argumentVisitor = CreateNewVisitor(argumentExpression);
                        argumentVisitor.Visit(a);
                        return argumentVisitor.IsEnumerable;
                    }))
                    IsEnumerable = true;
                if (expression.Type.IsKnownByServer || expression.Arguments.Count == 0)
                {
                    _expressionReference.Value = Expression.New(_type.GetConstructor(expression.ArgumentTypes.Select(at => at.ToType(_serializableExpressionConverter)).ToArray()), expression.Arguments.Select(a =>
                    {
                        Reference<Expression> argumentExpression = new Reference<Expression>();
                        var argumentVisitor = CreateNewVisitor(argumentExpression);
                        argumentVisitor.IsEnumerable = IsEnumerable;
                        argumentVisitor.Visit(a);
                        return argumentExpression.Value;
                    }));
                    return;
                }
                var properties = _type.GetProperties();
                _expressionReference.Value = Expression.MemberInit(Expression.New(_type.GetConstructor(new Type[0])), expression.Arguments.Select((a, i) =>
                {
                    Reference<Expression> argumentExpression = new Reference<Expression>();
                    var argumentVisitor = CreateNewVisitor(argumentExpression);
                    argumentVisitor.IsEnumerable = IsEnumerable;
                    argumentVisitor.Visit(a);
                    return Expression.Bind(properties[i], argumentExpression.Value);
                }));
            }
            
            protected virtual Expression GetConstructorExpression(Type type, SerializableConstructorExpression expression)
            {
                return null;
            }
            
            protected virtual Type GetConstructorType(Type type)
            {
                return type;
            }
            
            protected internal override void VisitEntitySet(SerializableEntitySetExpression expression)
            {
                _expressionReference.Value = _serializableExpressionConverter.GetEntitySetExpression(expression.EntitySetName);
            }
            
            protected internal override void VisitLambda(SerializableLambdaExpression expression)
            {
                Reference<Expression> bodyExpression = new Reference<Expression>();
                Dictionary<string, ParameterExpression> parameters = new Dictionary<string, ParameterExpression>(_lambdaParameters);
                var parameterExpressions = expression.Parameters.Select(p => GetParameterExpression(p, parameters)).ToArray();
                var bodyVisitor = CreateNewVisitor(bodyExpression, parameters);
                bodyVisitor.Visit(expression.Body);
                if (bodyVisitor.IsEnumerable)
                    IsEnumerable = true;
                _expressionReference.Value = Expression.Lambda(Type.GetType("System.Func`" + (expression.Parameters.Count + 1).ToString()).MakeGenericType(GetLambdaGenericArguments(expression, bodyExpression.Value)), bodyExpression.Value, parameterExpressions);
            }
            
            protected virtual Type[] GetLambdaGenericArguments(SerializableLambdaExpression expression, Expression body)
            {
                var genericTypes = new Type[expression.Parameters.Count + (body.Type == null ? 0 : 1)];
                int index = 0;
                foreach (var p in expression.Parameters)
                    genericTypes[index++] = p.Type.ToType(_serializableExpressionConverter);
                if (body.Type != null)
                    genericTypes[index] = expression.ReturnType.ToType(_serializableExpressionConverter);
                return genericTypes;
            }
            
            protected internal override void VisitMemberInit(SerializableMemberInitExpression expression)
            {
                Reference<Expression> newExpression = new Reference<Expression>();
                var ctorVisitor = CreateNewVisitor(newExpression);
                ctorVisitor.Visit(expression.Constructor);
                if (ctorVisitor.IsEnumerable)
                    IsEnumerable = true;
                Type type = ctorVisitor._type;
                List<MemberAssignment> memberAssignments = new List<MemberAssignment>();
                bool resetMemberAssignments = false;
                for (; ; )
                {
                    foreach (var s in expression.Setters)
                    {
                        Reference<Expression> setterExpression = new Reference<Expression>();
                        var memberAssignmentVisitor = CreateNewVisitor(setterExpression);
                        memberAssignmentVisitor.Visit(s.Value);
                        if (memberAssignmentVisitor.IsEnumerable && !IsEnumerable)
                        {
                            IsEnumerable = true;
                            resetMemberAssignments = true;
                            break;
                        }
                        memberAssignments.Add(Expression.Bind(type.GetProperty(s.MemberName), setterExpression.Value));
                    }
                    if (!resetMemberAssignments)
                        break;
                    memberAssignments.Clear();
                }
                _expressionReference.Value = Expression.MemberInit((NewExpression)newExpression.Value, memberAssignments);
            }
            
            protected internal override void VisitMethodCall(SerializableMethodCallExpression expression)
            {
                Reference<Expression> source = new Reference<Expression>();
                if (expression.Source != null)
                {
                    var sourceVisitor = CreateNewVisitor(source);
                    sourceVisitor.Visit(expression.Source);
                    if (sourceVisitor.IsEnumerable)
                        IsEnumerable = true;
                }
                var isParametersEnumerable = new List<int>();
                var method = GetMethodInfo(expression);
                bool parameterNull = false;
                List<Expression> parameters = expression.Parameters.Select((p, pi) =>
                {
                    if (parameterNull)
                        return null;
                    Visitor visitor;
                    Reference<Expression> parameter = new Reference<Expression>();
                    bool takeOneWithSpecification = false;
                    switch (method.Name)
                    {
                        case "First":
                        case "FirstOrDefault":
                        case "Single":
                        case "SingleOrDefault":
                        case "Last":
                        case "LastOrDefault":
                            if (method.DeclaringType == typeof(Queryable))
                            {
                                if (pi == 1)
                                    return null;
                                if (expression.Parameters.Count == 2)
                                {
                                    expression.MemberName = "Where";
                                    expression.Signature = typeof(Queryable).GetMethods().First(m => m.Name == "Where" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).ToString();
                                    p = expression;
                                    method = method.DeclaringType.GetMethods().First(m => m.Name == method.Name && m.GetParameters().Length == 1).MakeGenericMethod(method.GetGenericArguments());
                                }
                            }
                            visitor = CreateNewVisitor(parameter, _withSpecificationsProperties != null ? new List<string>(_withSpecificationsProperties) : null);
                            if (_withSpecificationsProperties != null)
                            {
                                if (! method.Name.StartsWith("Last"))
                                    takeOneWithSpecification = true;
                                _withSpecificationsProperties = null;
                            }
                            break;
                        default:
                            visitor = CreateNewVisitor(parameter);
                            break;
                    }
                    SerializableConstantExpression serializableConstantExpression;
                    if ((method.DeclaringType == typeof(Enumerable) || method.DeclaringType == typeof(Queryable)) && (method.Name == "Take" || method.Name == "Skip") && (serializableConstantExpression = p as SerializableConstantExpression) != null && serializableConstantExpression.Value is int)
                        return Expression.Constant(serializableConstantExpression.Value, typeof(int));
                    visitor.Visit(p);
                    if (visitor.IsEnumerable)
                    {
                        MethodCallExpression arg0;
                        MethodCallExpression methodCall;
                        if (takeOneWithSpecification && (arg0 = (methodCall = (MethodCallExpression)parameter.Value).Arguments[0] as MethodCallExpression) != null && arg0.Method.Name == "Select" && arg0.Method.DeclaringType == typeof(Queryable))
                        {
                            var expSource = arg0.Arguments[0];
                            var genericType = arg0.Method.GetGenericArguments()[0];
                            if (expression.Parameters.Count == 2)
                            {
                                var expPredicateReference = new Reference<Expression>();
                                var expPredicateVisitor = CreateNewVisitor(expPredicateReference);
                                expPredicateVisitor.Visit(expression.Parameters[1]);
                                expSource = Expression.Call(typeof(Queryable).GetMethods().First(m => 
                                    {
                                        ParameterInfo[] mParameters;
                                        if (m.Name != "Where" || (mParameters = m.GetParameters()).Length != 2)
                                            return false;
                                        Type[] genericArgs = mParameters[1].ParameterType.GetGenericArguments();
                                        return genericArgs.Length == 1 && genericArgs[0].GetGenericArguments().Length == 2;
                                    }).MakeGenericMethod(genericType), expSource, Expression.Quote(expPredicateReference.Value));
                            }
                            expSource = Expression.Call(typeof(Queryable).GetMethod("Take").MakeGenericMethod(genericType), expSource, Expression.Constant(1));
                            _isEnumerableExpressions.Remove(parameter.Value);
                            var parameterSelectSource = Expression.Call(arg0.Method, expSource, arg0.Arguments[1]);
                            parameter.Value = Expression.Call(methodCall.Method, parameterSelectSource, methodCall.Arguments[1]);
                            _isEnumerableExpressions.Add(parameter.Value, true);
                            _isEnumerableExpressions.Add(parameterSelectSource, false);
                            parameterNull = true;
                        }
                        isParametersEnumerable.Add(pi);
                    }
                    return parameter.Value;
                }).Where(p => p != null).ToList();
                var value = VisitMethodCall(source.Value, method, parameters, isParametersEnumerable);
                if (value != null)
                {
                    _expressionReference.Value = value;
                    return;
                }
                if (isParametersEnumerable.Any() && method.DeclaringType == typeof(Queryable))
                {
                    IsEnumerable = true;
                    switch (method.Name)
                    {
                        case "Where":
                            value = VisitWhereCallEnumerableAndQueryable(expression, method, parameters);
                            break;
                        case "ThenBy":
                        case "ThenByDescending":
                            value = VisitThenByOrThenByDescendingCallEnumerableAndQueryable(expression, method, parameters);
                            break;
                        case "Take":
                        case "Skip":
                            value = VisitTakeOrSkipCallEnumerableAndQueryable(expression, method, parameters);
                            break;
                        case "First":
                        case "FirstOrDefault":
                        case "Single":
                        case "SingleOrDefault":
                            value = VisitFirstOrFirstOrDefaultOrSingleOrSingleOrDefaultCallEnumerableAndQueryable(expression, method, parameters);
                            break;
                        case "Select":
                            break;
                    }
                    if (value != null)
                    {
                        _expressionReference.Value = value;
                        return;
                    }
                    method = GetMethodInfo(expression);
                    Type[] methodGenericArguments;
                    if (method.GetParameters().Length == 2 && parameters.Count == 1 && (methodGenericArguments = method.GetGenericArguments()).Length == 1)
                        method = method.DeclaringType.GetMethods().First(m => m.Name == method.Name && m.GetParameters().Length == 1).MakeGenericMethod(methodGenericArguments[0]);
                }
                if (method.GetCustomAttributes(typeof(SpecificationsAttribute), true).Length == 0)
                {
                    if (method.Name == "Contains" && source.Value != null && source.Value.Type != method.DeclaringType && source.Value.Type.GetInterfaces().Contains(typeof(IEnumerable)))
                    {
                        method = typeof(Enumerable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(method.DeclaringType.GetGenericArguments()[0]);
                        parameters.Insert(0, source.Value);
                        source.Value = null;
                    }
                    _expressionReference.Value = Expression.Call(source.Value, method, parameters);
                }
                else
                {
                    var dalSpecification = (LambdaExpression)_serializableExpressionConverter.GetSpecificationLINQExpression(method, parameters, source.Value.Type);
                    if (dalSpecification == null || IsEnumerable)
                    {
                        _expressionReference.Value = Expression.Call(source.Value, method, parameters);
                        IsEnumerable = true;
                    }
                    else
                        _expressionReference.Value = dalSpecification.Body.ReplaceParameter(dalSpecification.Parameters[0], source.Value);
                }
            }
            
            protected virtual Expression VisitMethodCall(Expression source, MethodInfo method, List<Expression> parameters, List<int> isParametersEnumerable)
            {
                return null;
            }
            
            protected virtual Expression GetQueryableExpression(Expression expression, Func<MethodCallExpression, bool?> allowedMethod)
            {
                Expression previousExpression = expression as MethodCallExpression;
                if (previousExpression == null)
                    return null;
                MethodCallExpression previousMethodCallExpression;
                while ((previousMethodCallExpression = previousExpression as MethodCallExpression) != null)
                {
                    switch (allowedMethod(previousMethodCallExpression))
                    {
                        case true:
                            return previousExpression;
                        case false:
                            return null;
                    }
                    if ((previousExpression = previousMethodCallExpression.Arguments.FirstOrDefault()) == null)
                        break;
                }
                return previousExpression;
            }
            
            protected virtual Expression VisitWhereCallEnumerableAndQueryable(SerializableMethodCallExpression expression, MethodInfo method, List<Expression> parameters)
            {
                Expression selectExpressionBody;
                ParameterExpression selectExpressionParameter;
                Expression previousExpression = ExtractQueryable(parameters[0], out selectExpressionBody, out selectExpressionParameter);
            
                List<Expression> queryableExpressions = new List<Expression>();
                List<Expression> enumerableExpressions = new List<Expression>();
                Stack<Expression> predicateExpressions = new Stack<Expression>();
                LambdaExpression lambda = (LambdaExpression)parameters[1];
                var lambdaParameter = lambda.Parameters[0];
                predicateExpressions.Push(lambda.Body);
                if (_isEnumerableExpressions[parameters[1]])
                    while (predicateExpressions.Any())
                    {
                        var predicate = predicateExpressions.Pop();
                        BinaryExpression binaryExp = predicate as BinaryExpression;
                        if (binaryExp != null && predicate.NodeType == ExpressionType.AndAlso)
                        {
                            if (_isEnumerableExpressions[binaryExp.Left])
                                predicateExpressions.Push(binaryExp.Left);
                            else
                                queryableExpressions.Add(predicate);
                            if (_isEnumerableExpressions[binaryExp.Right])
                                predicateExpressions.Push(binaryExp.Right);
                            else
                                queryableExpressions.Add(binaryExp.Right);
                        }
                        else
                            enumerableExpressions.Add(predicate);
                    }
                else
                    queryableExpressions.Add(lambda.Body);
            
                if (queryableExpressions.Count == 0)
                    return null;
            
                if (previousExpression == null || !_isEnumerableExpressions.ContainsKey(previousExpression) || _isEnumerableExpressions[previousExpression])
                    throw new InvalidOperationException();
            
                _isEnumerableExpressions.Remove(parameters[1]);
            
                var whereParameter = Expression.Parameter(method.GetGenericArguments()[0]);
                _isEnumerableExpressions.Remove(parameters[0]);
                Func<Expression, Expression> whereLambdaSelector;
                if (selectExpressionBody == null)
                    whereLambdaSelector = e => e.ReplaceParameter(lambda.Parameters[0], whereParameter);
                else
                {
                    whereLambdaSelector = e => e.ReplaceParameter(lambda.Parameters[0], selectExpressionBody);
                    whereParameter = selectExpressionParameter;
                    method = method.GetGenericMethodDefinition().MakeGenericMethod(whereParameter.Type);
                }
                var queryableSource = Expression.Call(method, previousExpression, Expression.Quote(Expression.Lambda(queryableExpressions.Select(whereLambdaSelector).Aggregate((e1, e2) => Expression.AndAlso(e1, e2)), whereParameter)));
                _isEnumerableExpressions.Add(queryableSource, false);
                parameters[0] = parameters[0].ReplaceExpression(previousExpression, queryableSource);
                if (!_isEnumerableExpressions.ContainsKey(parameters[0]))
                    _isEnumerableExpressions.Add(parameters[0], true);
                if (enumerableExpressions.Count == 0)
                    return parameters[0];
            
                parameters[1] = (LambdaExpression)parameters[1].ReplaceExpression(lambda.Body, enumerableExpressions.Aggregate((e1, e2) => Expression.AndAlso(e1, e2)));
                _isEnumerableExpressions.Add(parameters[1], true);
                return null;
            }
            
            private Expression ExtractQueryable(Expression expression, out Expression selectExpressionBody, out ParameterExpression selectExpressionParameter)
            {
                Expression selectExpressionBodyValue = null;
                ParameterExpression selectExpressionParameterValue = null;
                Expression previousExpression = GetQueryableExpression(expression, m =>
                {
                    if (m.Method.DeclaringType != typeof(Enumerable))
                        return true;
                    switch (m.Method.Name)
                    {
                        case "Select":
                            if (_isEnumerableExpressions[m.Arguments[1]])
                                return false;
                            var selectLambda = (LambdaExpression)m.Arguments[1];
                            if (selectExpressionBodyValue == null)
                                selectExpressionBodyValue = selectLambda.Body;
                            else
                                selectExpressionBodyValue = selectExpressionBodyValue.ReplaceParameter(selectExpressionParameterValue, selectLambda.Body);
                            selectExpressionParameterValue = selectLambda.Parameters[0];
                            break;
                        case "SelectMany":
                        case "GroupBy":
                        case "GroupJoin":
                        case "Join":
                        case "Reverse":
                        case "Union":
                        case "Take":
                        case "Skip":
                            return false;
                    }
                    return null;
                });
                selectExpressionBody = selectExpressionBodyValue;
                selectExpressionParameter = selectExpressionParameterValue;
                return previousExpression;
            }
            
            protected virtual Expression VisitThenByOrThenByDescendingCallEnumerableAndQueryable(SerializableMethodCallExpression expression, MethodInfo method, List<Expression> parameters)
            {
                expression.Signature = Regex.Replace(expression.Signature, @"ThenBy((?:Descending)?)(.*?)System.Linq.IOrderedQueryable", m =>
                {
                    expression.MemberName = "OrderBy" + m.Groups[1].Value;
                    return string.Concat(expression.MemberName, m.Groups[2].Value, "System.Collections.Generic.IEnumerable");
                });
                return null;
            }
            
            protected virtual Expression VisitTakeOrSkipCallEnumerableAndQueryable(SerializableMethodCallExpression expression, MethodInfo method, List<Expression> parameters)
            {
                Expression previousExpression = parameters[0];
                MethodCallExpression previousMethodCallExpression;
                MethodInfo previousMethod = null;
                while ((previousMethodCallExpression = previousExpression as MethodCallExpression) != null && (previousMethod = previousMethodCallExpression.Method).DeclaringType == typeof(Enumerable))
                {
                    switch (previousMethod.Name)
                    {
                        case "Where":
                        case "OrderBy":
                        case "OrderByDescending":
                        case "Take":
                        case "Skip":
                        case "SelectMany":
                        case "Distinct":
                        case "GroupBy":
                        case "GroupJoin":
                        case "Join":
                        case "Reverse":
                        case "Union":
                            return null;
                    }
                    if ((previousExpression = previousMethodCallExpression.Arguments.FirstOrDefault()) == null)
                        break;
                }
            
                if (previousExpression == null || !_isEnumerableExpressions.ContainsKey(previousExpression) || _isEnumerableExpressions[previousExpression])
                    throw new InvalidOperationException();
            
                _isEnumerableExpressions.Remove(parameters[0]);
                var queryableValue = Expression.Call(method.GetGenericMethodDefinition().MakeGenericMethod(previousExpression.Type.GetGenericArguments()[0]), previousExpression, parameters[1]);
                _isEnumerableExpressions.Add(queryableValue, false);
                var value = parameters[0].ReplaceExpression(previousExpression, queryableValue);
                _isEnumerableExpressions.Add(value, true);
            
                return value;
            }
            
            protected virtual Expression VisitFirstOrFirstOrDefaultOrSingleOrSingleOrDefaultCallEnumerableAndQueryable(SerializableMethodCallExpression expression, MethodInfo method, List<Expression> parameters)
            {
                if (parameters.Count == 2)
                    return null;
            
                Expression previousExpression = parameters[0];
                MethodCallExpression previousMethodCallExpression;
                MethodInfo previousMethod = null;
                while ((previousMethodCallExpression = previousExpression as MethodCallExpression) != null && (previousMethod = previousMethodCallExpression.Method).DeclaringType == typeof(Enumerable))
                {
                    switch (previousMethod.Name)
                    {
                        case "Where":
                        case "OrderBy":
                        case "OrderByDescending":
                        case "Take":
                        case "Skip":
                        case "SelectMany":
                        case "Distinct":
                        case "GroupBy":
                        case "GroupJoin":
                        case "Join":
                        case "Reverse":
                        case "Union":
                            return null;
                    }
                    if ((previousExpression = previousMethodCallExpression.Arguments.FirstOrDefault()) == null)
                        break;
                }
            
                if (previousExpression == null || !_isEnumerableExpressions.ContainsKey(previousExpression) || _isEnumerableExpressions[previousExpression])
                    throw new InvalidOperationException();
            
                int take;
                switch (method.Name)
                {
                    case "First":
                    case "FirstOrDefault":
                        take = 1;
                        break;
                    case "Single":
                    case "SingleOrDefault":
                        take = 2;
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            
                _isEnumerableExpressions.Remove(parameters[0]);
                var queryableValue = Expression.Call(typeof(Queryable).GetMethod("Take").MakeGenericMethod(previousExpression.Type.GetGenericArguments()[0]), previousExpression, Expression.Constant(take, typeof(int)));
                _isEnumerableExpressions.Add(queryableValue, false);
                parameters[0] = parameters[0].ReplaceExpression(previousExpression, queryableValue);
                _isEnumerableExpressions.Add(parameters[0], true);
            
                return null;
            }
            
            protected MethodInfo GetMethodInfo(SerializableMethodCallExpression expression)
            {
                var declaringType = expression.MemberDeclaringType.ToType(_serializableExpressionConverter, false);
                if (declaringType == typeof(Queryable) && IsEnumerable)
                {
                    declaringType = typeof(Enumerable);
                    expression.Signature = Regex.Replace(Regex.Replace(expression.Signature, @"System.Linq.Expressions.Expression`1\[((?>[^\[\]]+|\[(?<DEPTH>)|\](?<-DEPTH>))*(?(DEPTH)(?!)))\]", m => m.Groups[1].Value), @"System.Linq.I(\w*)Queryable", m => m.Groups[1].Value.Length == 0 ? "System.Collections.Generic.IEnumerable" : string.Concat("System.Linq.I", m.Groups[1].Value, "Enumerable"));
                }
                var methodInfo = declaringType.GetMethods().Where(mi => mi.Name == expression.MemberName).Select(mi => mi.IsGenericMethod ? mi.GetGenericMethodDefinition() : mi).First(mi => expression.Signature == null || mi.ToString() == expression.Signature);
                if (expression.GenericArguments.Count != 0)
                    methodInfo = methodInfo.MakeGenericMethod(expression.GenericArguments.Select(ga => ga.ToType(_serializableExpressionConverter)).ToArray());
                return methodInfo;
            }
            
            protected internal override void VisitParameter(SerializableParameterExpression expression)
            {
                _expressionReference.Value = GetParameterExpression(expression);
            }
            
            protected internal override void VisitPropertyGetter(SerializablePropertyGetterExpression expression)
            {
                Reference<Expression> source = new Reference<Expression>();
                if (expression.Source != null)
                    CreateNewVisitor(source).Visit(expression.Source);
                if (expression.MemberName == "Count" && source.Value.Type.GetProperty(expression.MemberName) == null)
                    _expressionReference.Value = Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(source.Value.Type.GetGenericArguments()[0]), source.Value);
                else
                {
                    if (source.Value == null)
                    {
                        _expressionReference.Value = GetSpecificProperty(expression.MemberName);
                        return;
                    }
                    var property = source.Value.Type.GetProperty(expression.MemberName);
                    if (property.GetCustomAttributes(typeof(SpecificationsAttribute), true).Length == 0)
                        _expressionReference.Value = GetPropertyGetterExpression(source.Value, property);
                    else
                    {
                        var dalSpecification = (LambdaExpression)_serializableExpressionConverter.GetSpecificationLINQExpression(property, source.Value.Type);
                        if (dalSpecification == null || IsEnumerable)
                        {
                            _expressionReference.Value = Expression.MakeMemberAccess(source.Value, property);
                            IsEnumerable = true;
                        }
                        else
                            _expressionReference.Value = dalSpecification.Body.ReplaceParameter(dalSpecification.Parameters[0], source.Value);
                    }
                }
            }
            
            protected virtual Expression GetSpecificProperty(string propertyName)
            {
                Expression value = null;
                GetSpecificProperty(propertyName, ref value);
                if (value != null)
                    return value;
                throw new InvalidOperationException();
            }
            partial void GetSpecificProperty(string propertyName, ref Expression expression);
            
            protected virtual Expression GetPropertyGetterExpression(Expression source, PropertyInfo property)
            {
                return _serializableExpressionConverter.GetCustomPropertyExpression(source, property) ?? Expression.MakeMemberAccess(source, property);
            }
            
            protected internal override void VisitUnary(SerializableUnaryExpression expression)
            {
                Reference<Expression> operand = new Reference<Expression>();
                var operandVisitor = CreateNewVisitor(operand);
                operandVisitor.Visit(expression.Operand);
                _expressionReference.Value = Expression.MakeUnary(EnumUtils.GetEnumValue<ExpressionType>(expression.NodeType), operand.Value, expression.Type.ToType(_serializableExpressionConverter));
                if (operandVisitor.IsEnumerable)
                    IsEnumerable = true;
            }
            
            protected internal override void VisitConditional(SerializableConditionalExpression expression)
            {
                Reference<Expression> test = new Reference<Expression>();
                var testVisitor = CreateNewVisitor(test);
                testVisitor.Visit(expression.TestExpression);
                if (testVisitor.IsEnumerable)
                    IsEnumerable = true;
                Reference<Expression> ifTrue = new Reference<Expression>();
                var trueVisitor = CreateNewVisitor(ifTrue);
                trueVisitor.Visit(expression.IfTrueExpression);
                if (trueVisitor.IsEnumerable && !IsEnumerable)
                {
                    IsEnumerable = true;
                    if (!testVisitor.IsEnumerable)
                    {
                        testVisitor = CreateNewVisitor(test);
                        testVisitor.Visit(expression.TestExpression);
                    }
                }
                Reference<Expression> ifFalse = new Reference<Expression>();
                var falseVisitor = CreateNewVisitor(ifFalse);
                falseVisitor.Visit(expression.IfFalseExpression);
                if (falseVisitor.IsEnumerable && !IsEnumerable)
                {
                    IsEnumerable = true;
                    if (!testVisitor.IsEnumerable)
                    {
                        testVisitor = CreateNewVisitor(test);
                        testVisitor.Visit(expression.TestExpression);
                    }
                    if (!trueVisitor.IsEnumerable)
                    {
                        trueVisitor = CreateNewVisitor(ifTrue);
                        trueVisitor.Visit(expression.IfTrueExpression);
                    }
                }
                Type type = expression.Type.ToType(_serializableExpressionConverter);
                _expressionReference.Value = Expression.Condition(test.Value, ifTrue.Value, ifFalse.Value, type);
            }
        }
            
        private class SelectOptimizerVisitor : ExpressionVisitor
        {
            private Expression _queryableExpression;
            private List<List<PropertyInfo>> _dependentProperties;
            private ISerializableExpressionConverter _serializableExpressionConverter;
            private List<List<PropertyInfo>> _currentDependentProperties;
            private bool _isMember;
            
            public SelectOptimizerVisitor(Expression queryableExpression, List<List<PropertyInfo>> dependentProperties, ISerializableExpressionConverter serializableExpressionConverter)
            {
                _queryableExpression = queryableExpression;
                _dependentProperties = dependentProperties;
                _serializableExpressionConverter = serializableExpressionConverter;
            }
            
            public override Expression Visit(Expression node)
            {
                if (node == _queryableExpression)
                    return node;
                _isMember = false;
                var value = base.Visit(node);
                if (!_isMember)
                    _currentDependentProperties = null;
                return value;
            }
            
            protected override Expression VisitMember(MemberExpression node)
            {
                var propertyInfo = node.Member as PropertyInfo;
                if (propertyInfo != null)
                    AddDependences(propertyInfo);
                Visit(node.Expression);
                return node;
            }
            
            protected override Expression VisitMethodCall(MethodCallExpression node)
            {
                var properties = _serializableExpressionConverter.GetDependentProperties(node.Method).ToList();
                if (properties.Count != 0)
                {
                    if (node.Arguments.Count != 0)
                    {
                        List<List<PropertyInfo>> argumentProperties = new List<List<PropertyInfo>>();
                        var visitor = new SelectOptimizerVisitor(null, argumentProperties, _serializableExpressionConverter);
                        visitor.Visit(node.Arguments[0]);
                        if (argumentProperties.Count != 0)
                            properties = (from p in argumentProperties
                                            from p2 in properties
                                            select p.Union(p2)).ToList();
                    }
                    AddDependences(properties);
                    return node;
                }
                if (node.Method.DeclaringType == typeof(Enumerable))
                {
                    switch (node.Method.Name)
                    {
                        case "Select":
                        case "SelectMany":
                            Visit(node.Arguments[0]);
                            List<List<PropertyInfo>> argumentProperties = new List<List<PropertyInfo>>();
                            var visitor = new SelectOptimizerVisitor(null, argumentProperties, _serializableExpressionConverter);
                            visitor.Visit(node.Arguments[1]);
                            if (argumentProperties.Count != 0)
                            {
                                List<List<PropertyInfo>> dependentProperties;
                                if (_currentDependentProperties == null || _currentDependentProperties.Count == 0)
                                    dependentProperties = argumentProperties;
                                else
                                    dependentProperties = _currentDependentProperties.Union(argumentProperties).Select(ps => ps.ToList()).ToList();
                                AddDependences(argumentProperties, false);
                                _currentDependentProperties = dependentProperties;
                            }
                            return node;
                        default:
                            Visit(node.Arguments[0]);
                            IEnumerable<IEnumerable<PropertyInfo>> argumentPropertiesAggregation = new IEnumerable<PropertyInfo>[0];
                            foreach (var a in node.Arguments.Skip(1))
                            {
                                argumentProperties = new List<List<PropertyInfo>>();
                                visitor = new SelectOptimizerVisitor(null, argumentProperties, _serializableExpressionConverter);
                                visitor.Visit(a);
                                argumentPropertiesAggregation = argumentPropertiesAggregation.Union(argumentProperties);
                            }
                            AddDependences(argumentPropertiesAggregation, false);
                            return node;
                    }
                }
                foreach (var a in node.Arguments)
                {
                    List<List<PropertyInfo>> argumentProperties = new List<List<PropertyInfo>>();
                    var visitor = new SelectOptimizerVisitor(null, argumentProperties, _serializableExpressionConverter);
                    visitor.Visit(a);
                    if (argumentProperties.Count != 0)
                        properties = (from p in argumentProperties
                                        from p2 in properties
                                        select p.Union(p2)).ToList();
                    AddDependences(properties);
                }
                return node;
            }
            
            protected override MemberBinding VisitMemberBinding(MemberBinding node)
            {
                var memberAssignment = node as MemberAssignment;
                MemberExpression memberExpression;
                if (memberAssignment != null && (memberExpression = memberAssignment.Expression as MemberExpression) != null && memberAssignment.Member == memberExpression.Member)
                    return node;
                return base.VisitMemberBinding(node);
            }
            
            private void AddDependences(PropertyInfo propertyInfo)
            {
                AddDependences(new List<IEnumerable<PropertyInfo>>() { new[] { propertyInfo } });
            }
            private void AddDependences(IEnumerable<IEnumerable<PropertyInfo>> propertyDependentProperties, bool applyOnCurrent = true)
            {
                _isMember = true;
                if (propertyDependentProperties == null || !propertyDependentProperties.Any())
                    return;
                if (_currentDependentProperties == null)
                {
                    var properties = propertyDependentProperties.Select(ps => ps.ToList()).ToList();
                    if (applyOnCurrent)
                        _currentDependentProperties = properties;
                    _dependentProperties.AddRange(properties);
                }
                else
                {
                    if (applyOnCurrent)
                    {
                        foreach (var currentDependentProperties in _currentDependentProperties)
                            _dependentProperties.Remove(currentDependentProperties);
                        _dependentProperties.AddRange(_currentDependentProperties = (from propertyDependentSubProperties in propertyDependentProperties
                                                                                        from currentDependentSubProperties in _currentDependentProperties
                                                                                        select propertyDependentSubProperties.Union(currentDependentSubProperties).ToList()).ToList());
                    }
                    else
                        _dependentProperties.AddRange((from propertyDependentSubProperties in _currentDependentProperties
                                                        from currentDependentSubProperties in propertyDependentProperties
                                                        select propertyDependentSubProperties.Union(currentDependentSubProperties).ToList()).ToList());
                }
            }
        }
    }
}
