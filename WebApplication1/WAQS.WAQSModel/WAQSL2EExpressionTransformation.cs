//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace WCFAsyncQueryableServices.DAL.Interfaces.L2E
{
    public static class WAQSL2EExpressionTransformation
    {
        public static Expression TransformProperty(MemberExpression expression, IObjectContext objectContext, Func<Expression, Expression> transformExp)
        {
            var propertyInfo = expression.Member as PropertyInfo;
            if (propertyInfo == null)
                return expression;
            return TransformProperty(transformExp(expression.Expression), propertyInfo, objectContext) ?? expression;
        }
    
        public static Expression TransformProperty(Expression source, PropertyInfo property, IObjectContext objectContext)
        {
            if (property.Name == "Date" && source.Type == typeof(DateTime))
                return objectContext.GetDateExpression(source);
            BinaryExpression subtractExpression = source as BinaryExpression;
            if (subtractExpression != null && subtractExpression.NodeType == ExpressionType.Subtract && source.Type == typeof(TimeSpan))
            {
                if (subtractExpression.Left.Type == typeof(DateTime))
                {
                    switch (property.Name)
                    {
                        case "Days":
                            return objectContext.DiffDaysExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Hours":
                            return objectContext.DiffHoursExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Minutes":
                            return objectContext.DiffMinutesExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Seconds":
                            return objectContext.DiffSecondsExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Milliseconds":
                            return objectContext.DiffMillisecondsExpression(subtractExpression.Right, subtractExpression.Left);
                    }
                }
                else if (subtractExpression.Left.Type == typeof(DateTimeOffset))
                {
                    switch (property.Name)
                    {
                        case "Days":
                            return objectContext.DiffDaysOffsetExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Hours":
                            return objectContext.DiffHoursOffsetExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Minutes":
                            return objectContext.DiffMinutesOffsetExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Seconds":
                            return objectContext.DiffSecondsOffsetExpression(subtractExpression.Right, subtractExpression.Left);
                        case "Milliseconds":
                            return objectContext.DiffMillisecondsOffsetExpression(subtractExpression.Right, subtractExpression.Left);
                    }
                }
            }
            return null;
        }
    
        public static Expression TransformMethodCall(MethodCallExpression expression, IObjectContext objectContext, Func<Expression, Expression> transformExp)
        {
            return TransformMethodCall(transformExp(expression.Object), expression.Method, expression.Arguments.Select(a => transformExp(a)).ToList(), objectContext) ?? expression;
        }
    
        public static Expression TransformMethodCall(Expression source, MethodInfo method, List<Expression> arguments, IObjectContext objectContext)
        {
            if (source != null && arguments.Count == 1)
            {
                if (source.Type == typeof(DateTime) && method.DeclaringType == typeof(DateTime))
                {
                    switch (method.Name)
                    {
                        case "AddYears":
                            return objectContext.AddYearsExpression(source, arguments[0]);
                        case "AddMonths":
                            return objectContext.AddMonthsExpression(source, arguments[0]);
                        case "AddDays":
                            return objectContext.AddDaysExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddHours":
                            return objectContext.AddHoursExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddMinutes":
                            return objectContext.AddMinutesExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddSeconds":
                            return objectContext.AddSecondsExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddMilliseconds":
                            return objectContext.AddMillisecondsExpression(source, ConvertDoubleToInt(arguments[0]));
                    }
                }
                else if (source.Type == typeof(DateTimeOffset) && method.DeclaringType == typeof(DateTimeOffset))
                {
                    switch (method.Name)
                    {
                        case "AddYears":
                            return objectContext.AddYearsOffsetExpression(source, arguments[0]);
                        case "AddMonths":
                            return objectContext.AddMonthsOffsetExpression(source, arguments[0]);
                        case "AddDays":
                            return objectContext.AddDaysOffsetExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddHours":
                            return objectContext.AddHoursOffsetExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddMinutes":
                            return objectContext.AddMinutesOffsetExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddSeconds":
                            return objectContext.AddSecondsOffsetExpression(source, ConvertDoubleToInt(arguments[0]));
                        case "AddMilliseconds":
                            return objectContext.AddMillisecondsOffsetExpression(source, ConvertDoubleToInt(arguments[0]));
                    }
                }
            }
            if (source == null && method.DeclaringType == typeof(Math))
            {
                var parameters = method.GetParameters();
                switch (method.Name)
                {
                    case "Abs":
                        if (parameters.Length == 1)
                        {
                            if (parameters[0].ParameterType == typeof(short))
                                return objectContext.AbsInt16Expression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(int))
                                return objectContext.AbsInt32Expression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(long))
                                return objectContext.AbsInt64Expression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(float))
                                return objectContext.AbsSingleExpression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(double))
                                return objectContext.AbsDoubleExpression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(decimal))
                                return objectContext.AbsDecimalExpression(arguments[0]);
                        }
                        throw new NotImplementedException();
                    case "Ceiling":
                        if (parameters.Length == 1)
                        {
                            if (parameters[0].ParameterType == typeof(double))
                                return objectContext.CeilingDoubleExpression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(decimal))
                                return objectContext.CeilingDecimalExpression(arguments[0]);
                        }
                        throw new NotImplementedException();
                    case "Floor":
                        if (parameters.Length == 1)
                        {
                            if (parameters[0].ParameterType == typeof(double))
                                return objectContext.FloorDoubleExpression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(decimal))
                                return objectContext.FloorDecimalExpression(arguments[0]);
                        }
                        throw new NotImplementedException();
                    case "Pow":
                        if (parameters.Length == 2)
                        {
                            if (parameters[0].ParameterType == typeof(double) && parameters[1].ParameterType == typeof(double))
                                return objectContext.PowDoubleExpression(arguments[0], arguments[1]);
                        }
                        break;
                    case "Round":
                        switch (parameters.Length)
                        {
                            case 1: 
                                if (parameters[0].ParameterType == typeof(double))
                                    return objectContext.RoundToEvenDoubleExpression(arguments[0]);
                                if (parameters[0].ParameterType == typeof(decimal))
                                    return objectContext.RoundToEvenDecimalExpression(arguments[0]);
                                throw new NotImplementedException();
                            case 2:
                                if (parameters[0].ParameterType == typeof(double))
                                {
                                    if (parameters[1].ParameterType == typeof(int))
                                        return objectContext.RoundToEvenDoubleExpression(arguments[0], arguments[1]);
                                    if (parameters[1].ParameterType == typeof(MidpointRounding))
                                    {
                                        MidpointRounding midpointRouting;
                                        var constantExp = arguments[1] as ConstantExpression;
                                        if (constantExp != null)
                                            midpointRouting = (MidpointRounding)constantExp.Value;
                                        else
                                            midpointRouting = Expression.Lambda<Func<MidpointRounding>>(arguments[1]).Compile()();
                                        if (midpointRouting == MidpointRounding.ToEven)
                                            return objectContext.RoundToEvenDoubleExpression(arguments[0]);
                                        if (midpointRouting == MidpointRounding.AwayFromZero)
                                            return objectContext.RoundAwayFromZeroDoubleExpression(arguments[0]);
                                    }
                                }
                                else if (parameters[0].ParameterType == typeof(decimal))
                                {
                                    if (parameters[1].ParameterType == typeof(int))
                                        return objectContext.RoundToEvenDecimalExpression(arguments[0], arguments[1]);
                                    if (parameters[1].ParameterType == typeof(MidpointRounding))
                                    {
                                        MidpointRounding midpointRouting;
                                        var constantExp = arguments[1] as ConstantExpression;
                                        if (constantExp != null)
                                            midpointRouting = (MidpointRounding)constantExp.Value;
                                        else
                                            midpointRouting = Expression.Lambda<Func<MidpointRounding>>(arguments[1]).Compile()();
                                        if (midpointRouting == MidpointRounding.ToEven)
                                            return objectContext.RoundToEvenDecimalExpression(arguments[0]);
                                        if (midpointRouting == MidpointRounding.AwayFromZero)
                                            return objectContext.RoundAwayFromZeroDecimalExpression(arguments[0]);
                                    }
                                }
                                break;
                            case 3:
                                if (parameters[1].ParameterType == typeof(int) && parameters[2].ParameterType == typeof(MidpointRounding))
                                {
                                    MidpointRounding midpointRouting;
                                    var constantExp = arguments[2] as ConstantExpression;
                                    if (constantExp != null)
                                        midpointRouting = (MidpointRounding)constantExp.Value;
                                    else
                                        midpointRouting = Expression.Lambda<Func<MidpointRounding>>(arguments[2]).Compile()();
                                    if (parameters[0].ParameterType == typeof(double))
                                    {
                                        if (midpointRouting == MidpointRounding.ToEven)
                                            return objectContext.RoundToEvenDoubleExpression(arguments[0], arguments[1]);
                                        if (midpointRouting == MidpointRounding.AwayFromZero)
                                            return objectContext.RoundAwayFromZeroDoubleExpression(arguments[0], arguments[1]);
                                    }
                                    else if (parameters[0].ParameterType == typeof(decimal))
                                    {
                                        if (midpointRouting == MidpointRounding.ToEven)
                                            return objectContext.RoundToEvenDecimalExpression(arguments[0], arguments[1]);
                                        if (midpointRouting == MidpointRounding.AwayFromZero)
                                            return objectContext.RoundAwayFromZeroDecimalExpression(arguments[0], arguments[1]);
                                    }
                                }
                                break;
                        }
                        throw new NotImplementedException();
                    case "Truncate":
                        if (parameters.Length == 1)
                        {
                            if (parameters[0].ParameterType == typeof(double))
                                return objectContext.TruncateDoubleExpression(arguments[0]);
                            if (parameters[0].ParameterType == typeof(decimal))
                                return objectContext.TruncateDecimalExpression(arguments[0]);
                        }
                        throw new NotImplementedException();
                }
            }
            return null;
        }
    
        private static Expression ConvertDoubleToInt(Expression exp)
        {
            MemberExpression me;
            if (! (exp is ConstantExpression) && ((me = exp as MemberExpression) == null || me.Expression.NodeType != ExpressionType.Constant))
                return Expression.Convert(exp, typeof(int));
            int value = (int)Expression.Lambda<Func<double>>(exp).Compile()();
            return Expression.Constant(value);
        }
    
        public static Expression TransformBinary(BinaryExpression expression, IObjectContext objectContext, Func<Expression, Expression> transformExp)
        {
            return TransformBinary(expression.NodeType.ToString(), transformExp(expression.Left), transformExp(expression.Right), objectContext) ?? expression;
        }
    
        public static Expression TransformBinary(string nodeType, Expression leftExpression, Expression rightExpression, IObjectContext objectContext)
        {
            bool dateTimeExp = leftExpression.Type == typeof(DateTime);
            if ((dateTimeExp || leftExpression.Type == typeof(DateTimeOffset)) && rightExpression.Type == typeof(TimeSpan))
            {
                bool subtract = false;
                switch (nodeType)
                {
                    case "Add":
                        break;
                    case "Subtract":
                        subtract = true;
                        break;
                    default:
                        return null;
                }
            
                Expression daysExp, hoursExp, minutesExp, secondsExp, milliSecondsExp;
                var rightNew = rightExpression as NewExpression;
                MemberExpression rightMember = null;
                ConstantExpression constantExpression = null;
            
                bool argsCountValid = false;
                if (rightNew != null && (argsCountValid = (rightNew.Arguments.Count > 3)) && ((constantExpression = rightNew.Arguments[0] as ConstantExpression) != null || (rightMember = rightNew.Arguments[0] as MemberExpression) != null && rightMember.Expression is ConstantExpression))
                {
                    var days = constantExpression == null ? Expression.Lambda<Func<int>>(rightMember).Compile()() : (int)constantExpression.Value;
                    if (subtract)
                        days = -days;
                    Expression<Func<int>> fieldConstant = () => days;
                    daysExp = days == 0 ? null : fieldConstant.Body;
                }
                else if (argsCountValid)
                {
                    daysExp = Expression.MakeMemberAccess(rightExpression, typeof(TimeSpan).GetProperty("Days"));
                    if (subtract)
                        daysExp = Expression.MakeUnary(ExpressionType.Negate, daysExp, typeof(int));
                }
                else
                    daysExp = null;
            
                argsCountValid = false;
                if (rightNew != null && (argsCountValid = (rightNew.Arguments.Count > 2)) && ((constantExpression = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 0 : 1] as ConstantExpression) != null || (rightMember = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 0 : 1] as MemberExpression) != null && rightMember.Expression is ConstantExpression))
                {
                    var hours = constantExpression == null ? Expression.Lambda<Func<int>>(rightMember).Compile()() : (int)constantExpression.Value;
                    if (subtract)
                        hours = -hours;
                    Expression<Func<int>> fieldConstant = () => hours;
                    hoursExp = hours == 0 ? null : fieldConstant.Body;
                }
                else if (argsCountValid)
                {
                    hoursExp = Expression.MakeMemberAccess(rightExpression, typeof(TimeSpan).GetProperty("Hours"));
                    if (subtract)
                        hoursExp = Expression.MakeUnary(ExpressionType.Negate, hoursExp, typeof(int));
                }
                else
                    hoursExp = null;
            
                argsCountValid = false;
                if (rightNew != null && (argsCountValid = (rightNew.Arguments.Count > 2)) && ((constantExpression = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 1 : 2] as ConstantExpression) != null || (rightMember = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 1 : 2] as MemberExpression) != null && rightMember.Expression is ConstantExpression))
                {
                    var minutes = constantExpression == null ? Expression.Lambda<Func<int>>(rightMember).Compile()() : (int)constantExpression.Value;
                    if (subtract)
                        minutes = -minutes;
                    Expression<Func<int>> fieldConstant = () => minutes;
                    minutesExp = minutes == 0 ? null : fieldConstant.Body;
                }
                else if (argsCountValid)
                {
                    minutesExp = Expression.MakeMemberAccess(rightExpression, typeof(TimeSpan).GetProperty("Minutes"));
                    if (subtract)
                        minutesExp = Expression.MakeUnary(ExpressionType.Negate, minutesExp, typeof(int));
                }
                else
                    minutesExp = null;
            
                argsCountValid = false;
                if (rightNew != null && (argsCountValid = (rightNew.Arguments.Count > 2)) && ((constantExpression = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 2 : 3] as ConstantExpression) != null || (rightMember = rightNew.Arguments[rightNew.Arguments.Count == 3 ? 2 : 3] as MemberExpression) != null && rightMember.Expression is ConstantExpression))
                {
                    var seconds = constantExpression == null ? Expression.Lambda<Func<int>>(rightMember).Compile()() : (int)constantExpression.Value;
                    if (subtract)
                        seconds = -seconds;
                    Expression<Func<int>> fieldConstant = () => seconds;
                    secondsExp = seconds == 0 ? null : fieldConstant.Body;
                }
                else if (argsCountValid)
                {
                    secondsExp = Expression.MakeMemberAccess(rightExpression, typeof(TimeSpan).GetProperty("Seconds"));
                    if (subtract)
                        secondsExp = Expression.MakeUnary(ExpressionType.Negate, secondsExp, typeof(int));
                }
                else
                    secondsExp = null;
            
                argsCountValid = false;
                if (rightNew != null && (argsCountValid = (rightNew.Arguments.Count > 4)) && ((constantExpression = rightNew.Arguments[4] as ConstantExpression) != null || (rightMember = rightNew.Arguments[4] as MemberExpression) != null && rightMember.Expression is ConstantExpression))
                {
                    var milliseconds = constantExpression == null ? Expression.Lambda<Func<int>>(rightMember).Compile()() : (int)constantExpression.Value;
                    if (subtract)
                        milliseconds = -milliseconds;
                    Expression<Func<int>> fieldConstant = () => milliseconds;
                    milliSecondsExp = milliseconds == 0 ? null : fieldConstant.Body;
                }
                else if (argsCountValid)
                {
                    milliSecondsExp = Expression.MakeMemberAccess(rightExpression, typeof(TimeSpan).GetProperty("Milliseconds"));
                    if (subtract)
                        milliSecondsExp = Expression.MakeUnary(ExpressionType.Negate, milliSecondsExp, typeof(int));
                }
                else
                    milliSecondsExp = null;
            
                var value = leftExpression;
                if (daysExp != null)
                {
                    if (dateTimeExp)
                        value = objectContext.AddDaysExpression(value, daysExp);
                    else
                        value = objectContext.AddDaysOffsetExpression(value, daysExp);
                }
                if (hoursExp != null)
                {
                    if (dateTimeExp)
                        value = objectContext.AddHoursExpression(value, hoursExp);
                    else 
                        value = objectContext.AddHoursOffsetExpression(value, hoursExp);
                }
                if (minutesExp != null)
                {
                    if (dateTimeExp)
                        value = objectContext.AddMinutesExpression(value, minutesExp);
                    else
                        value = objectContext.AddMinutesOffsetExpression(value, minutesExp);
                }
                if (secondsExp != null)
                {
                    if (dateTimeExp)
                        value = objectContext.AddSecondsExpression(value, secondsExp);
                    else
                        value = objectContext.AddSecondsOffsetExpression(value, secondsExp);
                }
                if (milliSecondsExp != null)
                {
                    if (dateTimeExp)
                        value = objectContext.AddMillisecondsExpression(value, milliSecondsExp);
                    else
                        value = objectContext.AddMillisecondsOffsetExpression(value, milliSecondsExp);
                }
                return value;
            }
            return null;
        }
    }
}
