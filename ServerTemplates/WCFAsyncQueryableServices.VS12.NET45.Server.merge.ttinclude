
<#@ assembly name="System.Collections.Immutable" #><#@ assembly name="System.Runtime" #><#@ assembly name="Microsoft.CodeAnalysis" #><#@ assembly name="Microsoft.CodeAnalysis.CSharp" #><#@ assembly name="Microsoft.CodeAnalysis.Workspaces" #><#@ assembly name="Microsoft.CodeAnalysis.CSharp.Workspaces" #><#@ import namespace="Microsoft.CodeAnalysis" #><#@ import namespace="Microsoft.CodeAnalysis.CSharp" #><#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #><#@ import namespace="Microsoft.CodeAnalysis.CSharp.Symbols" #><#@ import namespace="Microsoft.CodeAnalysis.FindSymbols" #><#@ import namespace="Microsoft.CodeAnalysis.MSBuild" #><#@ import namespace="ISolution = Microsoft.CodeAnalysis.Solution" #><#@ import namespace="IProject = Microsoft.CodeAnalysis.Project" #><#@ import namespace="SyntaxVisitor = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor" #><#@ import namespace="SyntaxRewriter = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter" #><#@ import namespace="SyntaxVisitorOfBool = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<bool>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfString = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<string>>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfSyntaxNode = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode>>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfMethodDeclarationSyntax = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax>>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfClassDeclarationSyntax = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfTypeSymbol = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ITypeSymbol>>" #><#@ import namespace="SyntaxVisitorOfIEnumerableOfNamespaceSymbol = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.INamespaceSymbol>>" #><#@ import namespace="ISolution = Microsoft.CodeAnalysis.Solution" #><#@ import namespace="ISemanticModel = Microsoft.CodeAnalysis.SemanticModel" #><#@ import namespace="IDocument = Microsoft.CodeAnalysis.Document" #><#@ import namespace="RoslynAccessibility = Microsoft.CodeAnalysis.Accessibility" #><#@ import namespace="NamespaceSymbol = Microsoft.CodeAnalysis.INamespaceSymbol" #><#@ import namespace="TypeSymbol = Microsoft.CodeAnalysis.ITypeSymbol" #><#@ import namespace="MethodSymbol = Microsoft.CodeAnalysis.IMethodSymbol" #><#@ import namespace="PropertySymbol = Microsoft.CodeAnalysis.IPropertySymbol" #><#@ import namespace="NamedTypeSymbol = Microsoft.CodeAnalysis.INamedTypeSymbol" #><#@ import namespace="ParameterSymbol = Microsoft.CodeAnalysis.IParameterSymbol" #><#@ import namespace="LocalSymbol = Microsoft.CodeAnalysis.ILocalSymbol" #><#@ import namespace="ArrayTypeSymbol = Microsoft.CodeAnalysis.IArrayTypeSymbol" #><#@import namespace="System.Text.RegularExpressions"#><#@ assembly name="System.Core" #><#@ assembly name="System.Data" #><#@ assembly name="System.Data.Entity" #><#@ assembly name="System.Data.Entity.Design" #><#@ assembly name="System.Xml" #><#@ assembly name="System.Xml.Linq"#><#@ assembly name="EnvDTE"#><#@ import namespace="System" #><#@ import namespace="System.Linq" #><#@ import namespace="System.IO" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="System.Data.Objects" #><#@ import namespace="System.Data.Objects.DataClasses" #><#@ import namespace="System.Xml" #><#@ import namespace="System.Xml.Linq" #><#@ import namespace="System.Globalization" #><#@ import namespace="System.Reflection" #><#@ import namespace="System.Data.Metadata.Edm" #><#@ import namespace="System.Data.Mapping" #><#@ import namespace="System.Data.Entity.Design" #><#@ import namespace="System.CodeDom" #><#@ import namespace="System.CodeDom.Compiler" #><#@ import namespace="Microsoft.CSharp"#><#@ import namespace="System.Text"#><#@ import namespace="Microsoft.VisualStudio.TextTemplating"#><#@ template language="C#" hostspecific="true"#><#@ output extension=".txt"#><#@ assembly name="EnvDTE" #><#@ assembly name="EnvDTE80" #><#@ assembly name="System.Collections"#><#@ import namespace="System"#><#@ import namespace="System.Collections.Concurrent"#><#@ import namespace="System.Collections.Generic"#><#@ import namespace="System.IO" #><#@ import namespace="System.Linq"#><#@ import namespace="System.Text"#><#@ import namespace="System.Text.RegularExpressions"#><#@ import namespace="System.Threading.Tasks"#><#@ import namespace="System.IO"#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

    public static Solution LoadSolution(string path, ITextTemplatingEngineHost host)
    {
        return MSBuildWorkspace.Create().OpenSolutionAsync(path).Result;
    }

    public static ISymbol FindSourceDefinition(ISymbol symbol, ISolution solution)
    {
        return SymbolFinder.FindSourceDefinitionAsync(symbol, solution).Result;
    }

    public static SyntaxTree GetSyntaxTree(Document document)
    {
        return document.GetSyntaxTreeAsync().Result;
    }

    public static Compilation GetCompilation(Project project)
    {
        return project.GetCompilationAsync().Result;
    }

    public static SyntaxNode GetSyntaxRoot(Document document)
    {
        return document.GetSyntaxRootAsync().Result;
    }

    public static SemanticModel GetSemanticModel(Document document)
    {
        return document.GetSemanticModelAsync().Result;
    }

    public static SyntaxKind GetKind(CSharpSyntaxNode node)
    {
        return node.CSharpKind();
    }

    public static SyntaxKind GetKind(SyntaxNode node)
    {
        return GetKind((CSharpSyntaxNode)node);
    }

    public static SyntaxKind GetKind(SyntaxToken node)
    {
        return node.CSharpKind();
    }

    public static bool IsAssignExpression(SyntaxKind kind)
    {
        return kind == SyntaxKind.SimpleAssignmentExpression;
    }

    public enum RoslynSyntaxKind
    {
        AssignExpression = SyntaxKind.SimpleAssignmentExpression, 
        AddAssignExpression = SyntaxKind.AddAssignmentExpression, 
        SubtractAssignExpression = SyntaxKind.SubtractAssignmentExpression, 
        MultiplyAssignExpression = SyntaxKind.MultiplyAssignmentExpression, 
        DivideAssignExpression = SyntaxKind.DivideAssignmentExpression, 
        ModuloAssignExpression = SyntaxKind.ModuloAssignmentExpression, 
        AsExpression = SyntaxKind.AsExpression
    }

    public const SyntaxKind SyntaxKindAssignExpression = SyntaxKind.SimpleAssignmentExpression;
    public const SyntaxKind SyntaxKindMemberAccessExpression = SyntaxKind.SimpleMemberAccessExpression;

    public static Project AddDocument(Project project, string name, string text, IEnumerable<string> folders, out DocumentId documentId)
    {
        var document = project.AddDocument(name, text, folders);
        documentId = document.Id;
        return document.Project;
    }
#>
<#+// Copyright (c) Microsoft Corporation.  All rights reserved.
// Copyright (c) Matthieu MEZIL.  All rights reserved.

public class EdmxElements
{
    private EdmxElements(ITextTemplatingEngineHost host, string edmxPath, string namespaceName)
    {
        EdmxPath = edmxPath;
        Code = new CodeGenerationTools(this);
        NamespaceName = namespaceName ?? Code.VsNamespaceSuggestion();
        MetadataTools = new MetadataTools(this);
        Loader = new MetadataLoader(this);
        ItemCollection = Loader.CreateEdmItemCollection(EdmxPath);
        EdmxName = Path.GetFileNameWithoutExtension(EdmxPath);
        Container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
        EntityTypes = ItemCollection.GetItems<EntityType>().ToList();
        ComplexTypes = ItemCollection.GetItems<ComplexType>().ToList();
        EdmTypes = EntityTypes.Cast<StructuralType>().Union(ComplexTypes).ToList();
        EntitySets = Container.BaseEntitySets.OfType<EntitySet>().ToList();
        FunctionImports = Container.FunctionImports.ToList();
    }

    private EdmxElements()
    {
    }

    public static EdmxElements Get(ITextTemplatingEngineHost host, string edmxPath, string namespaceName = null)
    {
        return Get(host, ref edmxPath, namespaceName);
    }

    public static EdmxElements Get(ITextTemplatingEngineHost host, ref string edmxPath, string namespaceName = null)
    {
        edmxPath = Path.GetFullPath(host.ResolvePath(edmxPath));
        return new EdmxElements(host, edmxPath, namespaceName);
    }

    public string EdmxPath { get; private set; }
    public string NamespaceName { get; private set; }
    public string EdmxName { get; private set; }
    public MetadataTools MetadataTools { get; private set; }
    public CodeGenerationTools Code { get; private set; }
    public MetadataLoader Loader { get; private set; }
    public EdmItemCollection ItemCollection { get; private set; }
    public List<EntityType> EntityTypes { get; private set; }
    public List<ComplexType> ComplexTypes { get; private set; }
    public List<StructuralType> EdmTypes { get; private set; }
    public List<EntitySet> EntitySets { get; private set; }
    public List<EdmFunction> FunctionImports { get; private set; }
    public EntityContainer Container { get; private set; }

    private StoreItemCollection _storeItemCollection;
    public StoreItemCollection StoreItemCollection
    {
        get 
        {
            if (_storeItemCollection == null)
                Loader.TryCreateStoreItemCollection(EdmxPath, out _storeItemCollection);
            return _storeItemCollection; 
        }
    }

    private EntityContainer _storeContainer;
    public EntityContainer StoreContainer
    {
        get { return _storeContainer ?? (_storeContainer = StoreItemCollection.GetItems<EntityContainer>().First()); }
    }

    private string _storeContainerName;
    public string StoreContainerName 
    {
        get { return _storeContainerName ?? (_storeContainerName = StoreContainer.Name); }
    }

    private StorageMappingItemCollection _mappingCollection;
    public StorageMappingItemCollection MappingCollection
    {
        get 
        { 
            if (_mappingCollection == null)
                Loader.TryCreateStorageMappingItemCollection(EdmxPath, ItemCollection, StoreItemCollection, out _mappingCollection);
            return _mappingCollection;
        }
    }
}


partial class WritingFunctions
{
    private Action<string> _write;

    public WritingFunctions(Action<string> write)
    {
        _write = write;
    }

    public void Write(string text)
    {
        _write(text);
    }
}

public static class EdmFunctionExtensions
{
    public static string GetParameters(EdmFunction edmFunction, EdmxElements edmxElements)
    {
        FunctionImportParameter[] parameters;
        return GetParameters(edmFunction, edmxElements, out parameters);
    }
    public static string GetParameters(EdmFunction edmFunction, EdmxElements edmxElements, out FunctionImportParameter[] parameters)
    {
        parameters = FunctionImportParameter.Create(edmFunction.Parameters, edmxElements.Code, edmxElements.MetadataTools).ToArray();
        return String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName));
    }

    public static string GetReturnTypeName(EdmFunction edmFunction, EdmxElements edmxElements)
    {
        TypeUsage returnType;
        return GetReturnTypeName(edmFunction, edmxElements, out returnType);
    }
    public static string GetReturnTypeName(EdmFunction edmFunction, EdmxElements edmxElements, out TypeUsage returnType)
    {
        returnType = edmxElements.MetadataTools.GetElementType(edmFunction.ReturnParameter.TypeUsage);
        if (returnType == null)
            return null;
        return edmxElements.Code.Escape(returnType);
    }
}

public static string GetPlurial(string entityTypeName)
{
    return entityTypeName.EndsWith("y") ? entityTypeName.Substring(0, entityTypeName.Length - 1) + "ies" : entityTypeName.EndsWith("s") ? entityTypeName + "es" : entityTypeName + "s";
}

public static string GetPlurial(CodeGenerationTools code, EntityContainer container, EdmType edmType)
{
    var entityType = edmType as EntityType;

    EntitySet entitySet;
    if (entityType != null && (entitySet = GetEntitySet(container, entityType)) != null && entitySet.ElementType == entityType)
        return code.Escape(entitySet);
    return GetPlurial(code.Escape(edmType));
}

public static string GetContainerNameWithoutEntitiesName(EntityContainer container)
{
    string containerName = container.Name;
    string containerWithoutEntitiesName = containerName;
    if (containerWithoutEntitiesName.EndsWith("Entities") && containerWithoutEntitiesName.Length > 8)
        containerWithoutEntitiesName = containerWithoutEntitiesName.Substring(0, containerWithoutEntitiesName.Length - 8);
    return containerWithoutEntitiesName;
}

public static string PropertyAccessibilityAndVirtual(EdmMember member)
{
    string accessibility = Accessibility.ForProperty(member);
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static bool IsConcurrencyFixed(EdmMember edmMember)
{
    return edmMember.TypeUsage.Facets.Any(f => f.Name == "ConcurrencyMode" && f.Value.ToString() == "Fixed");
}

public static int? MaxLength(EdmMember edmMember)
{
    var maxLengthFacet = edmMember.TypeUsage.Facets.FirstOrDefault(f => f.Name == "MaxLength");
    if (maxLengthFacet != null && maxLengthFacet.Value != null && maxLengthFacet.Value.ToString() != "Max")
        return (int)maxLengthFacet.Value;
    return null;
}

public static bool FixedLength(EdmMember edmMember)
{
    return edmMember.TypeUsage.Facets.Any(f => f.Name == "FixedLength" && f.Value!=null && (bool)f.Value);
}

public static string ReadOnlyPropertyAccessibilityAndVirtual(EdmMember member)
{
    string accessibility = Accessibility.ForReadOnlyProperty(member);
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static string AccessibilityAndVirtual(string accessibility)
{
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static EntitySet GetEntitySet(EntityContainer container, EntityType entityType)
{
    EntitySet value = container.BaseEntitySets.OfType<EntitySet>().FirstOrDefault(es => es.ElementType == entityType);
    if (value != null)
        return value;
    if (entityType.BaseType != null)
        return GetEntitySet(container, (EntityType)entityType.BaseType);
    return null;
}

public static EntitySet GetEntitySet(EntityContainer container, EdmItemCollection itemCollection, string entityTypeName)
{
    return GetEntitySet(container, itemCollection.GetItems<EntityType>().First(et => et.Name == entityTypeName));
}

public static NavigationProperty GetNavigationPropertyFromFK(EdmProperty property)
{
    var entityType = (EntityType)property.DeclaringType;
    foreach (NavigationProperty navigationProperty in entityType.NavigationProperties.Where(n => Accessibility.ForReadOnlyProperty(n) == "public"))
    {
        var association = (AssociationType)navigationProperty.RelationshipType;
        var associationEndMembers = association.AssociationEndMembers.Where(aem => aem.GetEntityType() == entityType);
        var referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
        if (referentialConstraint == null)
            return null;
        if (referentialConstraint != null && associationEndMembers.Contains(referentialConstraint.ToRole) && referentialConstraint.ToProperties.Contains(property) && navigationProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
        {
            return navigationProperty;
        }
    }
    return null;
}

public static NavigationProperty GetOtherNavigationProperty(NavigationProperty navigationProperty)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    return navigationProperty.ToEndMember.GetEntityType().NavigationProperties.FirstOrDefault(np => np.RelationshipType == association && np != navigationProperty);
}

public static IEnumerable<EdmProperty> GetFKsFromNavigationProperty(NavigationProperty navigationProperty)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    var referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
    if (referentialConstraint != null)
    {
        if (navigationProperty.FromEndMember == referentialConstraint.FromRole)
            return referentialConstraint.ToProperties; 
        else
            return referentialConstraint.FromProperties; 
    }
    return new EdmProperty[0];
}

public static IEnumerable<EntityType> GetSubEntityTypes(EdmItemCollection itemCollection, EntityType entityType, string accessibility = "public")
{
    return GetSubEntityTypes(itemCollection, entityType.Name, accessibility);
}

public static IEnumerable<EntityType> GetSubEntityTypes(EdmItemCollection itemCollection, string entityTypeName, string accessibility = "public")
{
    IEnumerable<EntityType> subEntityTypes = itemCollection.GetItems<EntityType>().OrderBy(e => e.Name).Where(e => e.BaseType != null && e.BaseType.Name == entityTypeName);
    if (accessibility != null)
        subEntityTypes = subEntityTypes.Where(e => Accessibility.ForType(e) == accessibility);
    foreach (EntityType et in subEntityTypes)
    {
        foreach (EntityType subEntityType in GetSubEntityTypes(itemCollection, et, accessibility))
            yield return subEntityType;
        yield return et;
    }
}

public EntityType GetEntityType(EdmItemCollection itemCollection, string entityTypeName)
{
    return itemCollection.GetItems<EntityType>().FirstOrDefault(et => et.Name == entityTypeName);
}

public static IEnumerable<EntityType> GetEntityTypes(EdmItemCollection itemCollection, EntitySet entitySet)
{
    var entityType = (EntityType)entitySet.ElementType;
    foreach (var subEntityType in GetSubEntityTypes(itemCollection, entityType))
        yield return subEntityType;
    yield return entityType;
}

public static IEnumerable<EntityType> GetDescendantsThenAscendantsEntityTypes(EdmItemCollection itemCollection, EntityType entityType)
{
    foreach (var subEntityType in GetSubEntityTypes(itemCollection, entityType))
        yield return subEntityType;
    yield return entityType;
    while ((entityType = (EntityType)entityType.BaseType) != null)
        yield return entityType;
}

public static void DefineMetadata()
{
    TemplateMetadata[MetadataConstants.TT_TEMPLATE_NAME] = "CSharpSelfTracking.Types";
    TemplateMetadata[MetadataConstants.TT_TEMPLATE_VERSION] = "5.0";
    TemplateMetadata[MetadataConstants.TT_MINIMUM_ENTITY_FRAMEWORK_VERSION] = "4.0";
}

void WriteHeader(string namespaceName, CodeGenerationTools code, params string[] usings)
{
    new WritingFunctions(Write).WriteHeader(PushIndent, namespaceName, code, usings);
}
partial class WritingFunctions
{
public void WriteHeader(Action<string> pushIndent, string namespaceName, CodeGenerationTools code, params string[] usings)
{
    WriteHeaderWithExternAliases(pushIndent, namespaceName, code, new string[0], usings);
}
}

void WriteCopyright()
{
    new WritingFunctions(Write).WriteCopyright();
}
partial class WritingFunctions
{
public void WriteCopyright()
{
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

<#+
}
}

void WriteHeaderWithExternAliases(string namespaceName, CodeGenerationTools code, string[] aliases, string[] usings)
{
    new WritingFunctions(Write).WriteHeaderWithExternAliases(PushIndent, namespaceName, code, aliases, usings);
}
partial class WritingFunctions
{
public void WriteHeaderWithExternAliases(Action<string> pushIndent, string namespaceName, CodeGenerationTools code, string[] aliases, string[] usings)
{
    CodeRegion region = new CodeRegion(this);
    WriteCopyright();
    foreach (var a in aliases.Where(al => al != null).Distinct())
    {
#>
extern alias <#=a#>;
<#+
    }	
#>
 
<#+
    foreach (var u in usings.Where(us => ! string.IsNullOrEmpty(us)).Distinct())
    {
#>
using <#=u#>;
<#+
    }	
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>

namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        pushIndent(CodeRegion.GetIndent(1));
    }
}
}

void WriteFooter(string namespaceName)
{
    new WritingFunctions(Write).WriteFooter(PopIndent, namespaceName);
}
partial class WritingFunctions
{
public void WriteFooter(Func<string> popIndent, string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        popIndent();
#>
}
<#+
    }
}
}

public partial class OriginalValueMembers
{
    private readonly HashSet<EdmProperty> _concurrencyMembers;

    public OriginalValueMembers(bool recordRequiredOriginalValuesOnly, MetadataWorkspace metadataWorkspace, MetadataTools metadataTools)
    {
        if (recordRequiredOriginalValuesOnly)
            try
            {
                _concurrencyMembers = new HashSet<EdmProperty>();
                foreach (EntityContainer container in metadataWorkspace.GetItems<EntityContainer>(DataSpace.CSpace))
                {
                    ILookup<EntityType, EntityType> directSubTypeLookup = metadataWorkspace.GetItems<EntityType>(DataSpace.CSpace).ToLookup(e => (EntityType)e.BaseType);
                    foreach (EntitySetBase eSet in container.BaseEntitySets.Where(es => es.BuiltInTypeKind == BuiltInTypeKind.EntitySet))
                    {
                        List<EntityType> subTypes = new List<EntityType>();
                        GetSubtypes(directSubTypeLookup, (EntityType)eSet.ElementType, subTypes);
                        foreach (EntityType eType in subTypes)
                            foreach (EdmProperty member in GetRelevantMembersForUpdate(metadataWorkspace, eSet, eType, true))
                                _concurrencyMembers.Add(member);
                    }
                }

                foreach (AssociationType assoc in metadataWorkspace.GetItems<AssociationType>(DataSpace.CSpace).Where(a => a.IsForeignKey))
                    foreach (EdmProperty toProperty in assoc.ReferentialConstraints[0].ToProperties)
                        _concurrencyMembers.Add(toProperty);
            }
            catch (Exception)
            {
                _concurrencyMembers = null;
            }
    }

    public bool IsOriginalValueMember(EdmProperty edmProperty)
    {
        return _concurrencyMembers == null || _concurrencyMembers.Contains(edmProperty);
    }

    private static void GetSubtypes(ILookup<EntityType, EntityType> lookup, EntityType eType, List<EntityType> subTypes)
    {
        subTypes.Add(eType);
        foreach (EntityType subType in lookup[eType])
            GetSubtypes(lookup, subType, subTypes);
    }
}

bool VerifyTypesAreCaseInsensitiveUnique(EdmItemCollection itemCollection)
{
    Dictionary<string, bool> alreadySeen = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
    foreach(StructuralType type in itemCollection.GetItems<StructuralType>())
    {
        if (!(type is EntityType || type is ComplexType))
            continue;

        if (alreadySeen.ContainsKey(type.FullName))
        {
            Error(String.Format(CultureInfo.CurrentCulture, "This template does not support types that differ only by case, the types {0} are not supported", type.FullName));
            return false;
        }
        else
            alreadySeen.Add(type.FullName, true);
    }

    return true;
}

// True if the association for the specified navigation property is an identifying relationship or a foreign key relationship.
public static bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, NavigationProperty navProperty)
{
    if (tools == null)
        throw new ArgumentNullException("tools");

    if (navProperty == null)
        throw new ArgumentNullException("navProperty");

    return IsForeignKeyOrIdentifyingRelationship(tools, (AssociationType)navProperty.RelationshipType);
}

// True if the specified association is an identifying relationship or a foreign key relationship.
public static bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, AssociationType association)
{
    if (tools == null)
        throw new ArgumentNullException("tools");

    if (association == null)
        throw new ArgumentNullException("association");

    return association.IsForeignKey || tools.IsIdentifyingRelationship(association);
}

public static bool IsPublic(EdmMember member)
{
    string setter = Accessibility.ForWriteOnlyProperty(member);
    string getter = Accessibility.ForReadOnlyProperty(member);

    return getter == "public" && setter == "public" && (member.TypeUsage.EdmType is ComplexType ? Accessibility.ForType(member.TypeUsage.EdmType) == "public" : true);
}
public static bool IsPublicOrInternal(EdmMember member)
{
    string setter = Accessibility.ForWriteOnlyProperty(member);
    string getter = Accessibility.ForReadOnlyProperty(member);
    string typeAccessibility;
    return (getter == "public" || getter == "internal") && (setter == "public" || setter == "internal") && (member.TypeUsage.EdmType is ComplexType ? ((typeAccessibility = Accessibility.ForType(member.TypeUsage.EdmType)) == "public" || typeAccessibility == "internal") : true);
}

public static bool IsPublic(EdmFunction method)
{
    return Accessibility.ForMethod(method) == "public";
}
public static bool IsPublicOrInternal(EdmFunction method)
{
    string methodAccessibility = Accessibility.ForMethod(method);
    return methodAccessibility == "public" || methodAccessibility == "internal";
}

public static bool IsPublic(NavigationProperty np)
{
    if (np == null || np.ToEndMember == null)
        return false;
    return IsPublic((EdmMember)np) && Accessibility.ForType(np.ToEndMember.GetEntityType()) == "public";
}
public static bool IsPublicOrInternal(NavigationProperty np)
{
    if (np == null || np.ToEndMember == null)
        return false;
    string typeAccessibility;
    return IsPublicOrInternal((EdmMember)np) && ((typeAccessibility = Accessibility.ForType(np.ToEndMember.GetEntityType())) == "public" || typeAccessibility == "internal");
}

public static bool IsPublic(EdmType type)
{
    return Accessibility.ForType(type) == "public";
}

public static IEnumerable<EdmProperty> GetCSDLIdentityProperties(EntityType entityType)
{
    return entityType.Properties.Where(p => p.MetadataProperties.Select(mp => mp.Value).OfType<string>().Any(sgp => sgp == "Identity"));
}

public static IEnumerable<EdmProperty> GetCSDLComputedProperties(EntityType entityType)
{
    return entityType.Properties.Where(p => p.MetadataProperties.Select(mp => mp.Value).OfType<string>().Any(sgp => sgp == "Computed"));
}

public IEnumerable<string> GetIdentityProperties(string inputFile, EntityType entityType)
{
    return GetIdentityProperties(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetIdentityProperties(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Identity", hostResolvePath).Distinct();
}

public bool HasTemporaryKeys(string inputFile, EntityType entityType)
{
    return HasTemporaryKeys(inputFile, entityType, HostResolvePath);
}
public static bool HasTemporaryKeys(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Identity", hostResolvePath).Any() || entityType.NavigationProperties.Any(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne && HasTemporaryKeys(inputFile, np.ToEndMember.GetEntityType(), hostResolvePath));
}

public string HostResolvePath(string path)
{
    return Host.ResolvePath(path);
}

public bool CouldHaveCSDLTemporaryKeys(EntityType entityType)
{
    return CouldHaveCSDLTemporaryKeys(entityType, HostResolvePath);
}
public static bool CouldHaveCSDLTemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return HasCSDLTemporaryKeys(entityType, hostResolvePath) || CouldHaveCSDLTemporaryKeysNps(entityType, hostResolvePath, navigationProperties).Any();
}

public IEnumerable<NavigationProperty> CouldHaveCSDLTemporaryKeysNps(EntityType entityType)
{
    return CouldHaveCSDLTemporaryKeysNps(entityType, HostResolvePath);
}
public static IEnumerable<NavigationProperty> CouldHaveCSDLTemporaryKeysNps(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return entityType.NavigationProperties.Where(np => 
        {
            if (navigationProperties.Contains(np) || !np.GetDependentProperties().Any())
                return false;
            navigationProperties.Add(np);
            IEnumerable<EdmProperty> fromProperties, toProperties;
            GetNavigationPropertyReferentialConstraintsEnumerables(np, out fromProperties, out toProperties);
            return np.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many && fromProperties.Any(f => entityType.KeyMembers.Contains(f)) && CouldHaveCSDLTemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath, navigationProperties);
        });
}

public IEnumerable<EdmMember> TemporaryKeys(EntityType entityType)
{
    return TemporaryKeys(entityType, HostResolvePath);
}
public static IEnumerable<EdmMember> TemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return GetCSDLIdentityProperties(entityType).Cast<EdmMember>().Intersect(entityType.KeyMembers).Union(CouldHaveCSDLTemporaryKeysNps(entityType, hostResolvePath).SelectMany<NavigationProperty, EdmMember>(np => 
        {
            if (navigationProperties.Contains(np))
                return new EdmMember[0];
            navigationProperties.Add(np);
            IEnumerable<EdmProperty> fromProperties, toProperties;
            GetNavigationPropertyReferentialConstraintsEnumerables(np, out fromProperties, out toProperties);
            var toTemporaryKeys = TemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath, navigationProperties).Intersect(toProperties);
            IEnumerator<EdmProperty> fromPropertiesEnumerator = fromProperties.GetEnumerator(), toPropertiesEnumerator = toProperties.GetEnumerator();
            var result = new List<EdmMember>();
            while (fromPropertiesEnumerator.MoveNext() && toPropertiesEnumerator.MoveNext())
                if (toTemporaryKeys.Contains(toPropertiesEnumerator.Current))
                    result.Add(fromPropertiesEnumerator.Current);
            return result;
        })).Distinct();
}

public bool HasCSDLTemporaryKeys(EntityType entityType)
{
    return HasCSDLTemporaryKeys(entityType, HostResolvePath);
}
public static bool HasCSDLTemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetCSDLIdentityProperties(entityType).Any() || entityType.NavigationProperties.Any(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne && HasCSDLTemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath));
}

public IEnumerable<string> GetComputedProperties(string inputFile, EntityType entityType)
{
    return GetComputedProperties(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetComputedProperties(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Computed", hostResolvePath).Distinct();
}

public IEnumerable<string> GetStoreGeneratedPropertiesPrivate(string inputFile, EntityType entityType, string storeGeneratedPattern)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, storeGeneratedPattern, HostResolvePath);
}
public static IEnumerable<string> GetStoreGeneratedPropertiesPrivate(string inputFile, EntityType entityType, string storeGeneratedPattern, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityTypeLoop.NamespaceName, ".", entityTypeLoop.Name, @"(?:\))?$")));
        if (entityTypeMapping != null) 
            foreach (var mappingFragment in entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)))
            {
                foreach (var storeGeneratedProp in GetStoreGeneratedPropertiesPrivate(runtime, mappingFragment, mappingFragment.Attribute("StoreEntitySet").Value, storeGeneratedPattern, edm_ns, msl_ns, ssdl_ns))
                    yield return storeGeneratedProp;
            }
    }
}

public static IEnumerable<string> GetStoreGeneratedPropertiesPrivate(XElement runtime, XElement mappingParent, string table, string storeGeneratedPattern, string edm_ns, string msl_ns, string ssdl_ns, string prefix = "")
{
    foreach (var scalarProperty in mappingParent.Elements(XName.Get("ScalarProperty", msl_ns)))
    {
        var column = scalarProperty.Attribute("ColumnName").Value;
        XAttribute storeGeneratedPatternAttribute;
        if ((storeGeneratedPatternAttribute = runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("EntityType", ssdl_ns)).First(et => et.Attribute("Name").Value == table).Elements(XName.Get("Property", ssdl_ns)).First(p => p.Attribute("Name").Value == column).Attribute("StoreGeneratedPattern")) != null && storeGeneratedPatternAttribute.Value == storeGeneratedPattern)
            yield return prefix + scalarProperty.Attribute("Name").Value;
    }
    foreach (var complexProperty in mappingParent.Elements(XName.Get("ComplexProperty", msl_ns)))
        foreach (var storeGeneratedProp in GetStoreGeneratedPropertiesPrivate(runtime, complexProperty, table, storeGeneratedPattern, edm_ns, msl_ns, ssdl_ns, prefix = complexProperty.Attribute("Name").Value + "."))
            yield return storeGeneratedProp;
}

public static string InitializedTrackingField(EdmProperty property, CodeGenerationTools code)
{
    string namePart = property.Name + "Initialized";
    if (code.CamelCaseFields)
        namePart = code.CamelCase(namePart);
    return "_" + namePart;
}

public static bool IsSaveReference(MetadataTools tools, NavigationProperty navProperty)
{
    return !IsForeignKeyOrIdentifyingRelationship(tools, navProperty) && navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many && navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.One;
}

public static string CreateFixupMethodName(RelationshipEndMember endMember)
{
    return String.Format(CultureInfo.InvariantCulture, "Fixup{0}_{1}_{2}Keys", endMember.DeclaringType.NamespaceName.Replace(".", "_"), endMember.DeclaringType.Name, endMember.Name);
}

public static string CreateKeyNameVariable(string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}KeyName", keyName);
}

public static string CreateReferenceValueLookupKey(AssociationEndMember endMember, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", endMember.DeclaringType.FullName, endMember.Name, keyName);
}

public static string CreateReferenceValueLookupKey(NavigationProperty navProp, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navProp.Name, keyName);
}

public IEnumerable<string> GetTablesMappedTo(string inputFile, EntityType entityType)
{
    return GetTablesMappedTo(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetTablesMappedTo(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityTypeLoop.NamespaceName, ".", entityTypeLoop.Name, @"(?:\))?$")));
        if (entityTypeMapping != null)
            foreach (var mappingFragment in entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)))
                yield return mappingFragment.Attribute("StoreEntitySet").Value;
    }	
}

public IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, string table)
{
    return GetDependentTablesAssociation(inputFile, table, HostResolvePath);
}
public static IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, string table, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    foreach (var association in runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)))
    {
        XElement end;
        if ((end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(r => r.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Principal", ssdl_ns)).Attribute("Role").Value)
            yield return association;
    }
}

public IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, List<string> tables, string table)
{
    return GetDependentTablesAssociation(inputFile, tables, table, HostResolvePath);
}
public static IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, List<string> tables, string table, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    foreach (var association in runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)))
    {
        XElement end;
        if ((end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(e => e.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Principal", ssdl_ns)).Attribute("Role").Value && tables.Contains(Regex.Match(association.Elements(XName.Get("End", ssdl_ns)).First(e => e != end).Attribute("Type").Value, "[^.]+$").Value))
            yield return association;
    }
}

public IEnumerable<string> TableWithoutPrincipal(string inputFile, List<string> tables)
{
    return TableWithoutPrincipal(inputFile, tables, HostResolvePath);
}
public static IEnumerable<string> TableWithoutPrincipal(string inputFile, List<string> tables, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    return tables.Where(table => ! runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)).Any(association => 
    {
        XElement end;
        return (end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(e => e.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Dependent", ssdl_ns)).Attribute("Role").Value && tables.Contains(Regex.Match(association.Elements(XName.Get("End", ssdl_ns)).First(e => e != end).Attribute("Type").Value, "[^.]+$").Value);
    }));
}

public string GetMappedColumn(string inputFile, EntityType entityType, string table, EdmMember prop)
{
    return GetMappedColumn(inputFile, entityType, table, prop, HostResolvePath);
}
public static string GetMappedColumn(string inputFile, EntityType entityType, string table, EdmMember prop, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    if (entityType != null)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityType.NamespaceName, ".", entityType.Name, @"(?:\))?$")));
        if (entityTypeMapping == null)
            return null;
        var storeEntitySetMapping = entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)).FirstOrDefault(mf => mf.Attribute("StoreEntitySet").Value == table);
        if (storeEntitySetMapping == null)
        { 
            if (entityType.BaseType == null)
                return null;
            return GetMappedColumn(inputFile, (EntityType)entityType.BaseType, table, prop, hostResolvePath);
        }
        return storeEntitySetMapping.Elements(XName.Get("ScalarProperty", msl_ns)).First(sp => sp.Attribute("Name").Value == prop.Name).Attribute("ColumnName").Value;
    }
    return null;
}

public bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop)
{
    return IsHorizontalEntitySplittingCondition(inputFile, entityType, prop, HostResolvePath);
}
public void GetEdmxRuntimeAndEDMAndMSLNamespaces(string inputFile, out string edm_ns, out string msl_ns, out XElement runtime)
{
    GetEdmxRuntimeAndEDMAndMSLNamespaces(inputFile, HostResolvePath, out edm_ns, out msl_ns, out runtime);
}
public static void GetEdmxRuntimeAndEDMAndMSLNamespaces(string inputFile, Func<string, string> hostResolvePath, out string edm_ns, out string msl_ns, out XElement runtime)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    edm_ns = GetEDM_NS(root);
    msl_ns = GetMSL_NS(root);
    runtime = root.Element(XName.Get("Runtime", edm_ns));
}
public static bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop, Func<string, string> hostResolvePath)
{
    string edm_ns, msl_ns;
    XElement runtime;
    GetEdmxRuntimeAndEDMAndMSLNamespaces(inputFile, hostResolvePath, out edm_ns, out msl_ns, out runtime);
    return IsHorizontalEntitySplittingCondition(inputFile, entityType, prop, edm_ns, msl_ns, runtime);
}
public static bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop, string edm_ns, string msl_ns, XElement runtime)
{
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityType.NamespaceName, ".", entityType.Name, @"(?:\))?$")));
        if (entityTypeMapping == null)
            return false;
        if (entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)).Any(mf => mf.Elements(XName.Get("Condition", msl_ns)).Any(c => 
            {
                var nameAttribute = c.Attribute("Name");
                if (nameAttribute == null)
                    return false;
                if (nameAttribute.Value == prop.Name)
                    return true;
                return false;
            })))
            return true;
    }
    return false;
}

public static void GetNavigationPropertyReferentialConstraintsEnumerables(NavigationProperty navigationProperty, out IEnumerable<EdmProperty> fromEnumerable, out IEnumerable<EdmProperty> toEnumerable)
{
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerables(navigationProperty, out referentialConstraint, out fromEnumerable, out toEnumerable);
}
public static void GetNavigationPropertyReferentialConstraintsEnumerables(NavigationProperty navigationProperty, out ReferentialConstraint referentialConstraint, out IEnumerable<EdmProperty> fromEnumerable, out IEnumerable<EdmProperty> toEnumerable)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
    if (referentialConstraint != null)
    {
        if (navigationProperty.FromEndMember == referentialConstraint.FromRole)
        {
            fromEnumerable = referentialConstraint.FromProperties;
            toEnumerable = referentialConstraint.ToProperties; 
        }
        else
        {
            fromEnumerable = referentialConstraint.ToProperties;
            toEnumerable = referentialConstraint.FromProperties; 
        }
        return;
    }
    fromEnumerable = new EdmProperty[0];
    toEnumerable = new EdmProperty[0];
}

public static void GetNavigationPropertyReferentialConstraintsEnumerators(NavigationProperty navigationProperty, out IEnumerator<EdmProperty> fromEnumerator, out IEnumerator<EdmProperty> toEnumerator)
{
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerators(navigationProperty, out referentialConstraint, out fromEnumerator, out toEnumerator);
}
public static void GetNavigationPropertyReferentialConstraintsEnumerators(NavigationProperty navigationProperty, out ReferentialConstraint referentialConstraint, out IEnumerator<EdmProperty> fromEnumerator, out IEnumerator<EdmProperty> toEnumerator)
{
    IEnumerable<EdmProperty> fromEnumerable, toEnumerable;
    GetNavigationPropertyReferentialConstraintsEnumerables(navigationProperty, out referentialConstraint, out fromEnumerable, out toEnumerable);
    fromEnumerator = fromEnumerable.GetEnumerator();
    toEnumerator = toEnumerable.GetEnumerator();
}

public static  bool IsStruct(EdmProperty property)
{
    return IsStruct(property.TypeUsage);
}
public static bool IsStruct(TypeUsage type)
{
    switch (type.ToString())
    {
        case "Edm.Byte":
        case "Edm.DateTime":
        case "Edm.DateTimeOffset":
        case "Edm.Time":
        case "Edm.Decimal":
        case "Edm.Double":
        case "Edm.Single":
        case "Edm.Int16":
        case "Edm.Int32":
        case "Edm.Int64":
        case "Edm.SByte":
            return true;
    }
    return false;
}

public static IEnumerable<Tuple<string, string>> GetKeysProperties(CodeGenerationTools code, EntityType entityType, int? index = null)
{
    foreach (var km in entityType.KeyMembers)
    {
        string typeName = code.Escape(km.TypeUsage);
        string key = string.Concat(code.Escape(entityType), index, code.Escape(km));
        yield return new Tuple<string, string>(typeName, key);
    }
} 

public bool HasPublicManyToManyRelationship(EdmxElements edmxElements)
{
    return edmxElements.EntityTypes.Any(e => IsPublic(e) && e.NavigationProperties.Any(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many));
}

public IEnumerable<string> WriteKeysTypes(EdmxElements edmxElements, EntityFrameworkTemplateFileManager fileManager, string entitiesNamespace, string edmxName, string relativePath)
{
    fileManager.StartNewFile("Includes.tt");
    string beginTag = "<" + "#";
    string endTag = "#" + ">";
    var edmxUtilityTTIncludeNameValue = edmxUtilityTTIncludeName;
    if (! string.IsNullOrEmpty(relativePath))
        edmxUtilityTTIncludeNameValue = Regex.Replace(edmxUtilityTTIncludeName, @"^((.?)*)\.ttinclude$", m => string.Concat(relativePath, m.Groups[1].Value, ".merge.ttinclude"));
#>
<#="<" + "#@"#> template language="C#" hostspecific="true"<#=endTag#>
<#="<" + "#@"#> include file="<#=edmxUtilityTTIncludeNameValue#>"<#=endTag#>
<#="<" + "#@"#> output extension=".txt"<#=endTag#>
<#=beginTag#>var fileManager = EntityFrameworkTemplateFileManager.Create(this);<#=endTag#>
<#+
    var code = edmxElements.Code;
    var typeNames = new List<string>();
    string @namespace = edmxElements.NamespaceName + ".Query.Include";
    foreach (EntityType entityType in edmxElements.EntityTypes.Where(e => IsPublic(e)))
    {
        string entityTypeName = code.Escape(entityType);
        foreach (var navigationProperty in entityType.NavigationProperties.Where(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many))
        {
            var typeNameSB = new StringBuilder();
            var properties = new List<Tuple<string, string>>();
            typeNameSB.Append("Include");
            foreach (var p in GetKeysProperties(code, entityType, 1).Union(GetKeysProperties(code, (EntityType)navigationProperty.ToEndMember.GetEntityType(), 2)))
            {
                typeNameSB.Append(p.Item2);
                properties.Add(p);
            }
            string typeName = typeNameSB.ToString();
            if (typeNames.Contains(typeName))
                continue;
            typeNames.Add(typeName);
#>
<#=beginTag#>fileManager.StartNewFile("<#=typeName#>.cs");<#=endTag#>
<#+
            WriteHeader(@namespace, code, "System", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://<#=edmxName#>/QueryInclude")]
public class <#=typeName#>
{
<#+
            foreach (var p in properties)
            {
#>
    [DataMember]
    public <#=p.Item1#> <#=p.Item2#> { get; set; }

<#+
            }
#>
}
<#+
            WriteFooter(@namespace);
            yield return typeName;

            var fromProperties = GetKeysProperties(code, entityType).ToList();
            typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in fromProperties)
                typeNameSB.Append(p.Item2);
            typeNameSB.Append("To");
            var toTypeName = code.Escape(navigationProperty.ToEndMember.GetEntityType());
            typeNameSB.Append(toTypeName);
            typeName = typeNameSB.ToString();

#>
<#=beginTag#>fileManager.StartNewFile("<#=typeName + ".cs"#>");<#=endTag#>
<#+
            WriteHeader(@namespace, code, "System", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://<#=edmxName#>/QueryInclude")]
public class <#=typeName#>
{
<#+
            foreach (var p in fromProperties)
            {
#>
    [DataMember]
    public <#=p.Item1#> <#=p.Item2#> { get; set; }

<#+
            }
#>
    [DataMember]
    public <#=entitiesNamespace#>.<#=toTypeName#> To { get; set; }
}
<#+
            WriteFooter(@namespace);
            yield return typeName;
        }
    }
#>
<#=beginTag#>fileManager.Process();<#=endTag#>
<#+
}

public static IEnumerable<string> GetKeysTypes(EdmxElements edmxElements)
{
    var code = edmxElements.Code;
    var typeNames = new List<string>();
    foreach (EntityType entityType in edmxElements.EntityTypes.Where(e => IsPublic(e)))
    {
        string entityTypeName = code.Escape(entityType);
        foreach (var navigationProperty in entityType.NavigationProperties.Where(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many))
        {
            var typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in GetKeysProperties(code, entityType, 1).Union(GetKeysProperties(code, (EntityType)navigationProperty.ToEndMember.GetEntityType(), 2)))
                typeNameSB.Append(p.Item2);
            string typeName = typeNameSB.ToString();
            if (typeNames.Contains(typeName))
                continue;
            typeNames.Add(typeName);
            yield return typeName;

            var fromProperties = GetKeysProperties(code, entityType).ToList();
            typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in fromProperties)
                typeNameSB.Append(p.Item2);
            typeNameSB.Append("To");
            var toTypeName = code.Escape(navigationProperty.ToEndMember.GetEntityType());
            typeNameSB.Append(toTypeName);
            yield return typeNameSB.ToString();
        }
    }
}

public static class EdmxChanges
{
    public static bool EdmxApplyChanges(string edmxPath, XElement edmx)
    {
        if (File.Exists(edmxPath + ".changes.xml"))
        {
            var changes = XElement.Load(edmxPath + ".changes.xml");
            ApplyChanges(edmx, changes);
            return true;
        }
        return false;
    }

    private static void ApplyChanges(XElement original, XElement change)
    {
        if (original.Name != change.Name || original.Attribute("Name") != null && original.Attribute("Name").Value != change.Attribute("Name").Value)
            throw new NotImplementedException();
        foreach (var addedAttribute in change.Attributes())
        {
            XAttribute originalAttribute = original.Attribute(addedAttribute.Name);
            if (originalAttribute == null)
                original.Add(addedAttribute);
            else
                originalAttribute.Value = addedAttribute.Value;
        }
        foreach (var changesChild in change.Elements())
        {
            var originalChild = original.Elements().FirstOrDefault(o => o.Name == changesChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesChild.Attribute("Name").Value));
            if (originalChild == null)
            {
                switch (changesChild.Name.LocalName)
                {
                    case "add":
                        foreach (var changesSubChild in changesChild.Elements())
                            original.Add(changesSubChild);
                        break;
                    case "remove":
                        foreach (var changesSubChild in changesChild.Elements())
                        {
                            originalChild = original.Elements().First(o => o.Name == changesSubChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesSubChild.Attribute("Name").Value));
                            originalChild.Remove();
                        }
                        break;
                    case "replace":
                        foreach (var changesSubChild in changesChild.Elements())
                        {
                            originalChild = original.Elements().First(o => o.Name == changesSubChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesSubChild.Attribute("Name").Value));
                            originalChild.Remove();
                            original.Add(changesSubChild);
                        }
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            else
            {
                ApplyChanges(originalChild, changesChild);
            }
        }
    }
}

void TestKeys(CodeGenerationTools code, EntityType entityType, string e1, string e2, string prefix1 = null, string prefix2 = null)
{
    var keysEnumerator = entityType.KeyMembers.GetEnumerator();
    keysEnumerator.MoveNext();
    for(;;)
    {
        string key = code.Escape(keysEnumerator.Current);
#><#=e1#>.<#=prefix1 ?? ""#><#=key#> == <#=e2#>.<#=prefix2 ?? ""#><#=key#><#+
        if (keysEnumerator.MoveNext())
        {
#> && <#+
        }
        else
            break;		
    }
}


void WriteIncludeTypeKeys(CodeGenerationTools code, EntityType entityType, NavigationProperty navigationProperty)
{
    var entityTypeName = code.Escape(entityType);
    foreach (var km in entityType.KeyMembers)
    {
#><#=entityTypeName#>1<#=code.Escape(km)#><#+
    }
    var toEntityType = navigationProperty.ToEndMember.GetEntityType();
    var toEntityTypeName = code.Escape(toEntityType);
    foreach (var km in toEntityType.KeyMembers)
    {
#><#=toEntityTypeName#>2<#=code.Escape(km)#><#+
    }
}

void WriteIncludeTo(CodeGenerationTools code, EntityType entityType, NavigationProperty navigationProperty)
{
    var entityTypeName = code.Escape(entityType);
    foreach (var km in entityType.KeyMembers)
    {
#><#=entityTypeName#><#=code.Escape(km)#><#+
    }
#>To<#=code.Escape(navigationProperty.ToEndMember.GetEntityType())#><#+
}

void InitKeys(CodeGenerationTools code, EntityType entityType, string e, int? index = null, string prefixName = null)
{
    var keysEnumerator = entityType.KeyMembers.GetEnumerator();
    keysEnumerator.MoveNext();
    for(;;)
    {
        string key = code.Escape(keysEnumerator.Current);
#><#=prefixName ?? ""#><#=index == null ? "" : index.Value.ToString()#><#=key#> = <#=e#>.<#=key#><#+
        if (keysEnumerator.MoveNext())
        {
#>, <#+
        }
        else
            break;		
    }
}

void TestNavigationKeys(CodeGenerationTools code, NavigationProperty navigationProperty, string e1 = "e1", string e2 = "e2")
{
    IEnumerator<EdmProperty> fromEnumerator, toEnumerator;
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerators(navigationProperty, out referentialConstraint, out fromEnumerator, out toEnumerator);
    if (referentialConstraint != null)
    {
        bool hasNext = fromEnumerator.MoveNext() & toEnumerator.MoveNext(); 
        while (hasNext)
        {
#><#=e1#>.<#=fromEnumerator.Current#> == <#=e2#>.<#=toEnumerator.Current#><#+
            hasNext = fromEnumerator.MoveNext() & toEnumerator.MoveNext(); 
            if (! hasNext)
                break;
#> && <#+
        }
    }
}
#>
<#+// Copyright (c) Microsoft Corporation.  All rights reserved.

public static Dictionary<string, string> TemplateMetadata = new Dictionary<string, string>();

/// <summary>
/// Responsible for helping to create source code that is
/// correctly formated and functional
/// </summary>
public class CodeGenerationTools
{
	private readonly DynamicTextTransformation _textTransformation;
	private readonly CSharpCodeProvider _code;
	private readonly MetadataTools _ef;

	private CodeGenerationTools()
	{
	}

	/// <summary>
	/// Initializes a new CodeGenerationTools object with the TextTransformation (T4 generated class)
	/// that is currently running
	/// </summary>
	public CodeGenerationTools(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
		_code = new CSharpCodeProvider();
		_ef = new MetadataTools(_textTransformation);
		FullyQualifySystemTypes = false;
		CamelCaseFields = true;
	}

	/// <summary>
	/// When true, all types that are not being generated
	/// are fully qualified to keep them from conflicting with
	/// types that are being generated. Useful when you have
	/// something like a type being generated named System.
	///
	/// Default is false.
	/// </summary>
	public bool FullyQualifySystemTypes { get; set; }

	/// <summary>
	/// When true, the field names are Camel Cased,
	/// otherwise they will preserve the case they
	/// start with.
	///
	/// Default is true.
	/// </summary>
	public bool CamelCaseFields { get; set; }

	/// <summary>
	/// Returns the NamespaceName suggested by VS if running inside VS.  Otherwise, returns
	/// null.
	/// </summary>
	public string VsNamespaceSuggestion()
	{
		string suggestion = _textTransformation.Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint");
		if (String.IsNullOrEmpty(suggestion))
		{
			return null;
		}

		return suggestion;
	}

	/// <summary>
	/// Returns a string that is safe for use as an identifier in C#.
	/// Keywords are escaped.
	/// </summary>
	public string Escape(string name)
	{
		if (name == null)
		{
			return null;
		}

		return _code.CreateEscapedIdentifier(name);
	}

	/// <summary>
	/// Returns the name of the TypeUsage's EdmType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(TypeUsage typeUsage)
	{
		if (typeUsage == null)
		{
			return null;
		}

		if (typeUsage.EdmType is ComplexType ||
			typeUsage.EdmType is EntityType)
		{
			return Escape(typeUsage.EdmType.Name);
		}
		else if (typeUsage.EdmType is SimpleType)
		{
			Type clrType = _ef.UnderlyingClrType(typeUsage.EdmType);
			string typeName = typeUsage.EdmType is EnumType ? Escape(typeUsage.EdmType.Name) : Escape(clrType);
			if (clrType.IsValueType && _ef.IsNullable(typeUsage))
			{
				return String.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName);
			}

			return typeName;
		}
		else if (typeUsage.EdmType is CollectionType)
		{
			return String.Format(CultureInfo.InvariantCulture, "ICollection<{0}>", Escape(((CollectionType)typeUsage.EdmType).TypeUsage));
		}

		throw new ArgumentException("typeUsage");
	}

	/// <summary>
	/// Returns the name of the EdmMember that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return Escape(member.Name);
	}

	/// <summary>
	/// Returns the name of the EdmType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmType type)
	{
		if (type == null)
		{
			return null;
		}

		return Escape(type.Name);
	}

	/// <summary>
	/// Returns the name of the EdmFunction that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmFunction function)
	{
		if (function == null)
		{
			return null;
		}

		return Escape(function.Name);
	}

	/// <summary>
	/// Returns the name of the EnumMember that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EnumMember member)
	{
		if (member == null)
		{
			return null;
		}

		return Escape(member.Name);
	}

	/// <summary>
	/// Returns the name of the EntityContainer that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EntityContainer container)
	{
		if (container == null)
		{
			return null;
		}

		return Escape(container.Name);
	}

	/// <summary>
	/// Returns the name of the EntitySet that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return Escape(set.Name);
	}

	/// <summary>
	/// Returns the name of the StructuralType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(StructuralType type)
	{
		if (type == null)
		{
			return null;
		}

		return Escape(type.Name);
	}

	/// <summary>
	/// Returns the NamespaceName with each segment safe to
	/// use as an identifier.
	/// </summary>
	public string EscapeNamespace(string namespaceName)
	{
		if (String.IsNullOrEmpty(namespaceName))
		{
			return namespaceName;
		}

		string[] parts = namespaceName.Split('.');
		namespaceName = String.Empty;
		foreach (string part in parts)
		{
			if (namespaceName != String.Empty)
			{
				namespaceName += ".";
			}

			namespaceName += Escape(part);
		}

		return namespaceName;
	}

	/// <summary>
	/// Returns the name of the EdmMember formatted for
	/// use as a field identifier.
	///
	/// This method changes behavior based on the CamelCaseFields
	/// setting.
	/// </summary>
	public string FieldName(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return FieldName(member.Name);
	}

	/// <summary>
	/// Returns the name of the EntitySet formatted for
	/// use as a field identifier.
	///
	/// This method changes behavior based on the CamelCaseFields
	/// setting.
	/// </summary>
	public string FieldName(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return FieldName(set.Name);

	}

	private string FieldName(string name)
	{
		if (CamelCaseFields)
		{
			return "_" + CamelCase(name);
		}
		else
		{
			return "_" + name;
		}
	}

	/// <summary>
	/// Returns the name of the Type object formatted for
	/// use in source code.
	///
	/// This method changes behavior based on the FullyQualifySystemTypes
	/// setting.
	/// </summary>
	public string Escape(Type clrType)
	{
		return Escape(clrType, FullyQualifySystemTypes);
	}

	/// <summary>
	/// Returns the name of the Type object formatted for
	/// use in source code.
	/// </summary>
	public string Escape(Type clrType, bool fullyQualifySystemTypes)
	{
		if(clrType == null)
		{
			return null;
		}

		string typeName;
		if (fullyQualifySystemTypes)
		{
			typeName = "global::" + clrType.FullName;
		}
		else
		{
			typeName = _code.GetTypeOutput(new CodeTypeReference(clrType));
		}
		return typeName;
	}

	/// <summary>
	/// Returns the abstract option if the entity is Abstract, otherwise returns String.Empty
	/// </summary>
	public string AbstractOption(EntityType entity)
	{
		if (entity.Abstract)
		{
			return "abstract";
		}
		return String.Empty;
	}

	/// <summary>
	/// Returns the passed in identifier with the first letter changed to lowercase
	/// </summary>
	public string CamelCase(string identifier)
	{
		if (String.IsNullOrEmpty(identifier))
		{
			return identifier;
		}

		if (identifier.Length == 1)
		{
			return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
		}

		return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + identifier.Substring(1);
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with a single space concatenated on the end.
	/// </summary>
	public string SpaceAfter(string value)
	{
		return StringAfter(value, " ");
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with a single space concatenated on the end.
	/// </summary>
	public string SpaceBefore(string value)
	{
		return StringBefore(" ", value);
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with append concatenated on the end.
	/// </summary>
	public string StringAfter(string value, string append)
	{
		if (String.IsNullOrEmpty(value))
		{
			return String.Empty;
		}

			return value + append;
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with prepend concatenated on the front.
	/// </summary>
	public string StringBefore(string prepend, string value)
	{
		if (String.IsNullOrEmpty(value))
		{
			return String.Empty;
		}

		return prepend + value;
	}

	/// <summary>
	/// Returns false and shows an error if the supplied type names aren't case-insensitively unique,
	/// otherwise returns true.
	/// </summary>
	public bool VerifyCaseInsensitiveTypeUniqueness(IEnumerable<string> types, string sourceFile)
	{
		return VerifyCaseInsensitiveUniqueness(types, t => string.Format(CultureInfo.CurrentCulture, GetResourceString("Template_CaseInsensitiveTypeConflict"), t), sourceFile);
	}

	/// <summary>
	/// Returns false and shows an error if the supplied strings aren't case-insensitively unique,
	/// otherwise returns true.
	/// </summary>
	private bool VerifyCaseInsensitiveUniqueness(IEnumerable<string> items, Func<string, string> formatMessage, string sourceFile)
	{
		HashSet<string> hash = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
		foreach (string item in items)
		{
			if (!hash.Add(item))
			{
				_textTransformation.Errors.Add(new System.CodeDom.Compiler.CompilerError(sourceFile, -1, -1, "6023", formatMessage(item)));
				return false;
			}
		}
		return true;
	}

	/// <summary>
	/// Returns the names of the items in the supplied collection that correspond to O-Space types.
	/// </summary>
	public IEnumerable<string> GetAllGlobalItems(EdmItemCollection itemCollection)
	{
		return itemCollection.GetItems<GlobalItem>().Where(i => i is EntityType || i is ComplexType || i is EnumType || i is EntityContainer).Select(g => GetGlobalItemName(g));
	}

	/// <summary>
	/// Returns the name of the supplied GlobalItem.
	/// </summary>
	public string GetGlobalItemName(GlobalItem item)
	{
		if (item is EdmType)
		{
			return ((EdmType)item).Name;
		}
		else
		{
			return ((EntityContainer)item).Name;
		}
	}

	/// <summary>
	/// Retuns as full of a name as possible, if a namespace is provided
	/// the namespace and name are combined with a period, otherwise just
	/// the name is returned.
	/// </summary>
	public string CreateFullName(string namespaceName, string name)
	{
		if (String.IsNullOrEmpty(namespaceName))
		{
			return name;
		}

		return namespaceName + "." + name;
	}

	/// <summary>
	/// Retuns a literal representing the supplied value.
	/// </summary>
	public string CreateLiteral(object value)
	{
		if (value == null)
		{
			return string.Empty;
		}

		Type type = value.GetType();
		if (type.IsEnum)
		{
			return type.FullName + "." + value.ToString();
		}
		if (type == typeof(Guid))
		{
			return string.Format(CultureInfo.InvariantCulture, "new Guid(\"{0}\")",
								 ((Guid)value).ToString("D", CultureInfo.InvariantCulture));
		}
		else if (type == typeof(DateTime))
		{
			return string.Format(CultureInfo.InvariantCulture, "new DateTime({0}, DateTimeKind.Unspecified)",
								 ((DateTime)value).Ticks);
		}
		else if (type == typeof(byte[]))
		{
			var arrayInit = string.Join(", ", ((byte[])value).Select(b => b.ToString(CultureInfo.InvariantCulture)).ToArray());
			return string.Format(CultureInfo.InvariantCulture, "new Byte[] {{{0}}}", arrayInit);
		}
		else if (type == typeof(DateTimeOffset))
		{
			var dto = (DateTimeOffset)value;
			return string.Format(CultureInfo.InvariantCulture, "new DateTimeOffset({0}, new TimeSpan({1}))",
								 dto.Ticks, dto.Offset.Ticks);
		}
		else if (type == typeof(TimeSpan))
		{
			return string.Format(CultureInfo.InvariantCulture, "new TimeSpan({0})",
								 ((TimeSpan)value).Ticks);
		}

		var expression = new CodePrimitiveExpression(value);
		var writer = new StringWriter();
		CSharpCodeProvider code = new CSharpCodeProvider();
		code.GenerateCodeFromExpression(expression, writer, new CodeGeneratorOptions());
		return writer.ToString();
	}

	/// <summary>
	/// Returns a resource string from the System.Data.Entity.Design assembly.
	/// </summary>
	public static string GetResourceString(string resourceName, CultureInfo culture = null)
	{
		if(_resourceManager == null)
		{
			_resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design",
				typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
		}

		return _resourceManager.GetString(resourceName, culture);
	}
	static System.Resources.ResourceManager _resourceManager;

	private const string ExternalTypeNameAttributeName = @"http://schemas.microsoft.com/ado/2006/04/codegeneration:ExternalTypeName";

	/// <summary>
	/// Gets the entity, complex, or enum types for which code should be generated from the given item collection.
	/// Any types for which an ExternalTypeName annotation has been applied in the conceptual model
	/// metadata (CSDL) are filtered out of the returned list.
	/// </summary>
	/// <typeparam name="T">The type of item to return.</typeparam>
	/// <param name="itemCollection">The item collection to look in.</param>
	/// <returns>The items to generate.</returns>
	public IEnumerable<T> GetItemsToGenerate<T>(ItemCollection itemCollection) where T: GlobalItem
	{
		return itemCollection.GetItems<T>().Where(i => !i.MetadataProperties.Any(p => p.Name == ExternalTypeNameAttributeName));
	}

	/// <summary>
	/// Returns the escaped type name to use for the given usage of a c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="typeUsage">The c-space type usage to get a name for.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(TypeUsage typeUsage)
	{
		return typeUsage == null ? null : GetTypeName(typeUsage.EdmType, _ef.IsNullable(typeUsage), modelNamespace: null);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(EdmType edmType)
	{
		return GetTypeName(edmType, isNullable: null, modelNamespace: null);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given usage of an c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="typeUsage">The c-space type usage to get a name for.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(TypeUsage typeUsage, string modelNamespace)
	{
		return typeUsage == null ? null : GetTypeName(typeUsage.EdmType, _ef.IsNullable(typeUsage), modelNamespace);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(EdmType edmType, string modelNamespace)
	{
		return GetTypeName(edmType, isNullable: null, modelNamespace: modelNamespace);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <param name="isNullable">Set this to true for nullable usage of this type.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	private string GetTypeName(EdmType edmType, bool? isNullable, string modelNamespace)
	{
		if (edmType == null)
		{
			return null;
		}

		var collectionType = edmType as CollectionType;
		if (collectionType != null)
		{
			return String.Format(CultureInfo.InvariantCulture, "ICollection<{0}>", GetTypeName(collectionType.TypeUsage, modelNamespace));
		}

		// Try to get an external type name, and if that is null, then try to get escape the name from metadata,
		// possibly namespace-qualifying it.
		var typeName = Escape(edmType.MetadataProperties
							  .Where(p => p.Name == ExternalTypeNameAttributeName)
							  .Select(p => (string)p.Value)
							  .FirstOrDefault())
			??
			(modelNamespace != null && edmType.NamespaceName != modelNamespace ?
			 CreateFullName(EscapeNamespace(edmType.NamespaceName), Escape(edmType)) :
			 Escape(edmType));

		if (edmType is StructuralType)
		{
			return typeName;
		}

		if (edmType is SimpleType)
		{
			var clrType = _ef.UnderlyingClrType(edmType);
			if (!(edmType is EnumType))
			{
				typeName = Escape(clrType);
			}

			return clrType.IsValueType && isNullable == true ?
				String.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName) :
				typeName;
		}

		throw new ArgumentException("typeUsage");
	}
}

/// <summary>
/// Responsible for making the Entity Framework Metadata more
/// accessible for code generation.
/// </summary>
public class MetadataTools
{
	private readonly DynamicTextTransformation _textTransformation;

	private MetadataTools()
	{
	}

	/// <summary>
	/// Initializes an MetadataTools Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public MetadataTools(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// This method returns the underlying CLR type of the o-space type corresponding to the supplied <paramref name="typeUsage"/>
	/// Note that for an enum type this means that the type backing the enum will be returned, not the enum type itself.
	/// </summary>
	public Type ClrType(TypeUsage typeUsage)
	{
		return UnderlyingClrType(typeUsage.EdmType);
	}

	/// <summary>
	/// This method returns the underlying CLR type given the c-space type.
	/// Note that for an enum type this means that the type backing the enum will be returned, not the enum type itself.
	/// </summary>
	public Type UnderlyingClrType(EdmType edmType)
	{
		var primitiveType = edmType as PrimitiveType;
		if (primitiveType != null)
		{
			return primitiveType.ClrEquivalentType;
		}

		var enumType = edmType as EnumType;
		if (enumType != null)
		{
			return enumType.UnderlyingType.ClrEquivalentType;
		}

		return typeof(object);
	}

	/// <summary>
	/// True if the EdmProperty is a key of its DeclaringType, False otherwise.
	/// </summary>
	public bool IsKey(EdmProperty property)
	{
		if (property != null && property.DeclaringType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
		{
			return ((EntityType)property.DeclaringType).KeyMembers.Contains(property);
		}

		return false;
	}

	/// <summary>
	/// True if the EdmProperty TypeUsage is Nullable, False otherwise.
	/// </summary>
	public bool IsNullable(EdmProperty property)
	{
		return property != null && IsNullable(property.TypeUsage);
	}

	/// <summary>
	/// True if the TypeUsage is Nullable, False otherwise.
	/// </summary>
	public bool IsNullable(TypeUsage typeUsage)
	{
		Facet nullableFacet = null;
		if (typeUsage != null &&
			typeUsage.Facets.TryGetValue("Nullable", true, out nullableFacet))
		{
			return (bool)nullableFacet.Value;
		}

		return false;
	}

	/// <summary>
	/// If the passed in TypeUsage represents a collection this method returns final element
	/// type of the collection, otherwise it returns the value passed in.
	/// </summary>
	public TypeUsage GetElementType(TypeUsage typeUsage)
	{
		if (typeUsage == null)
		{
			return null;
		}

		if (typeUsage.EdmType is CollectionType)
		{
			return GetElementType(((CollectionType)typeUsage.EdmType).TypeUsage);
		}
		else
		{
			return typeUsage;
		}
	}

	/// <summary>
	/// Returns the NavigationProperty that is the other end of the same association set if it is
	/// available, otherwise it returns null.
	/// </summary>
	public NavigationProperty Inverse(NavigationProperty navProperty)
	{
		if(navProperty == null)
		{
			return null;
		}

		EntityType toEntity = navProperty.ToEndMember.GetEntityType();
		return toEntity.NavigationProperties
			.SingleOrDefault(n => Object.ReferenceEquals(n.RelationshipType, navProperty.RelationshipType) && !Object.ReferenceEquals(n, navProperty));
	}

	/// <summary>
	/// Given a property on the dependent end of a referential constraint, returns the corresponding property on the principal end.
	/// Requires: The association has a referential constraint, and the specified dependentProperty is one of the properties on the dependent end.
	/// </summary>
	public EdmProperty GetCorrespondingPrincipalProperty(NavigationProperty navProperty, EdmProperty dependentProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		if (dependentProperty == null)
		{
			throw new ArgumentNullException("dependentProperty");
		}

		ReadOnlyMetadataCollection<EdmProperty> fromProperties = GetPrincipalProperties(navProperty);
		ReadOnlyMetadataCollection<EdmProperty> toProperties = GetDependentProperties(navProperty);
		return fromProperties[toProperties.IndexOf(dependentProperty)];
	}

	/// <summary>
	/// Given a property on the principal end of a referential constraint, returns the corresponding property on the dependent end.
	/// Requires: The association has a referential constraint, and the specified principalProperty is one of the properties on the principal end.
	/// </summary>
	public EdmProperty GetCorrespondingDependentProperty(NavigationProperty navProperty, EdmProperty principalProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		if (principalProperty == null)
		{
			throw new ArgumentNullException("principalProperty");
		}

		ReadOnlyMetadataCollection<EdmProperty> fromProperties = GetPrincipalProperties(navProperty);
		ReadOnlyMetadataCollection<EdmProperty> toProperties = GetDependentProperties(navProperty);
		return toProperties[fromProperties.IndexOf(principalProperty)];
	}

	/// <summary>
	/// Gets the collection of properties that are on the principal end of a referential constraint for the specified navigation property.
	/// Requires: The association has a referential constraint.
	/// </summary>
	public ReadOnlyMetadataCollection<EdmProperty> GetPrincipalProperties(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return ((AssociationType)navProperty.RelationshipType).ReferentialConstraints[0].FromProperties;
	}

	/// <summary>
	/// Gets the collection of properties that are on the dependent end of a referential constraint for the specified navigation property.
	/// Requires: The association has a referential constraint.
	/// </summary>
	public ReadOnlyMetadataCollection<EdmProperty> GetDependentProperties(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return ((AssociationType)navProperty.RelationshipType).ReferentialConstraints[0].ToProperties;
	}

	/// <summary>
	/// True if this entity type requires the HandleCascadeDelete method defined and the method has
	/// not been defined on any base type
	/// </summary>
	public bool NeedsHandleCascadeDeleteMethod(ItemCollection itemCollection, EntityType entity)
	{
		bool needsMethod = ContainsCascadeDeleteAssociation(itemCollection, entity);
		// Check to make sure no base types have already declared this method
		EntityType baseType = entity.BaseType as EntityType;
		while(needsMethod && baseType != null)
		{
			needsMethod = !ContainsCascadeDeleteAssociation(itemCollection, baseType);
			baseType = baseType.BaseType as EntityType;
		}
		return needsMethod;
	}

	/// <summary>
	/// True if this entity type participates in any relationships where the other end has an OnDelete
	/// cascade delete defined, or if it is the dependent in any identifying relationships
	/// </summary>
	private bool ContainsCascadeDeleteAssociation(ItemCollection itemCollection, EntityType entity)
	{
		return itemCollection.GetItems<AssociationType>().Where(a =>
				((RefType)a.AssociationEndMembers[0].TypeUsage.EdmType).ElementType.Name == entity.Name && IsCascadeDeletePrincipal(a.AssociationEndMembers[1]) ||
				((RefType)a.AssociationEndMembers[1].TypeUsage.EdmType).ElementType.Name == entity.Name && IsCascadeDeletePrincipal(a.AssociationEndMembers[0])).Any();
	}

	/// <summary>
	/// True if the source end of the specified navigation property is the principal in an identifying relationship.
	/// or if the source end has cascade delete defined.
	/// </summary>
	public bool IsCascadeDeletePrincipal(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return IsCascadeDeletePrincipal((AssociationEndMember)navProperty.FromEndMember);
	}

	/// <summary>
	/// True if the specified association end is the principal in an identifying relationship.
	/// or if the association end has cascade delete defined.
	/// </summary>
	public bool IsCascadeDeletePrincipal(AssociationEndMember associationEnd)
	{
		if (associationEnd == null)
		{
			throw new ArgumentNullException("associationEnd");
		}

		return associationEnd.DeleteBehavior == OperationAction.Cascade || IsPrincipalEndOfIdentifyingRelationship(associationEnd);
	}

	/// <summary>
	/// True if the specified association end is the principal end in an identifying relationship.
	/// In order to be an identifying relationship, the association must have a referential constraint where all of the dependent properties are part of the dependent type's primary key.
	/// </summary>
	public bool IsPrincipalEndOfIdentifyingRelationship(AssociationEndMember associationEnd)
	{
		if (associationEnd == null)
		{
			throw new ArgumentNullException("associationEnd");
		}

		ReferentialConstraint refConstraint = ((AssociationType)associationEnd.DeclaringType).ReferentialConstraints.Where(rc => rc.FromRole == associationEnd).SingleOrDefault();
		if (refConstraint != null)
		{
			EntityType entity = refConstraint.ToRole.GetEntityType();
			return !refConstraint.ToProperties.Where(tp => !entity.KeyMembers.Contains(tp)).Any();
		}
		return false;
	}

	/// <summary>
	/// True if the specified association type is an identifying relationship.
	/// In order to be an identifying relationship, the association must have a referential constraint where all of the dependent properties are part of the dependent type's primary key.
	/// </summary>
	public bool IsIdentifyingRelationship(AssociationType association)
	{
		if (association == null)
		{
			throw new ArgumentNullException("association");
		}

		return IsPrincipalEndOfIdentifyingRelationship(association.AssociationEndMembers[0]) || IsPrincipalEndOfIdentifyingRelationship(association.AssociationEndMembers[1]);
	}

	/// <summary>
	/// requires: firstType is not null
	/// effects: if secondType is among the base types of the firstType, return true,
	/// otherwise returns false.
	/// when firstType is same as the secondType, return false.
	/// </summary>
	public bool IsSubtypeOf(EdmType firstType, EdmType secondType)
	{
		if (secondType == null)
		{
			return false;
		}

		// walk up firstType hierarchy list
		for (EdmType t = firstType.BaseType; t != null; t = t.BaseType)
		{
			if (t == secondType)
				return true;
		}
		return false;
	}

	/// <summary>
	/// Returns the subtype of the EntityType in the current itemCollection
	/// </summary>
	public IEnumerable<EntityType> GetSubtypesOf(EntityType type, ItemCollection itemCollection, bool includeAbstractTypes)
	{
		if (type != null)
		{
			IEnumerable<EntityType> typesInCollection = itemCollection.GetItems<EntityType>();
			foreach (EntityType typeInCollection in typesInCollection)
			{
				if (type.Equals(typeInCollection) == false && this.IsSubtypeOf(typeInCollection, type))
				{
					if ( includeAbstractTypes || !typeInCollection.Abstract)
					{
						yield return typeInCollection;
					}
			   }
			}
		}
	}

	public static bool TryGetStringMetadataPropertySetting(MetadataItem item, string propertyName, out string value)
	{
		value = null;
		MetadataProperty property = item.MetadataProperties.FirstOrDefault(p => p.Name == propertyName);
		if (property != null)
		{
			value = (string)property.Value;
		}
		return value != null;
	}
}

/// <summary>
/// Responsible for loading an EdmItemCollection from a .edmx file or .csdl files
/// </summary>
public class MetadataLoader
{
	private readonly DynamicTextTransformation _textTransformation;

	private MetadataLoader()
	{
	}

	/// <summary>
	/// Initializes an MetadataLoader Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public MetadataLoader(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// Load the metadata for Edm, Store, and Mapping collections and register them
	/// with a new MetadataWorkspace, returns false if any of the parts can't be
	/// created, some of the ItemCollections may be registered and usable even if false is
	/// returned
	/// </summary>
	public bool TryLoadAllMetadata(string inputFile, out MetadataWorkspace metadataWorkspace)
	{
		metadataWorkspace = new MetadataWorkspace();

		EdmItemCollection edmItemCollection = CreateEdmItemCollection(inputFile);
		metadataWorkspace.RegisterItemCollection(edmItemCollection);

		StoreItemCollection storeItemCollection = null;
		if (TryCreateStoreItemCollection(inputFile, out storeItemCollection))
		{
			StorageMappingItemCollection storageMappingItemCollection = null;
			if (TryCreateStorageMappingItemCollection(inputFile, edmItemCollection, storeItemCollection, out storageMappingItemCollection))
			{
				metadataWorkspace.RegisterItemCollection(storeItemCollection);
				metadataWorkspace.RegisterItemCollection(storageMappingItemCollection);
				return true;
			}
		}

		return false;
	}

	/// <summary>
	/// Create an EdmItemCollection loaded with the metadata provided
	/// </summary>
	public EdmItemCollection CreateEdmItemCollection(string sourcePath, params string[] referenceSchemas)
	{
		EdmItemCollection edmItemCollection;
		if(TryCreateEdmItemCollection(sourcePath, referenceSchemas, out edmItemCollection))
		{
			return edmItemCollection;
		}

		return new EdmItemCollection();
	}

	/// <summary>
	/// Attempts to create a EdmItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateEdmItemCollection(string sourcePath, out EdmItemCollection edmItemCollection)
	{
		return TryCreateEdmItemCollection(sourcePath, null, out edmItemCollection);
	}

	/// <summary>
	/// Attempts to create a EdmItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateEdmItemCollection(string sourcePath, string[] referenceSchemas, out EdmItemCollection edmItemCollection)
	{
		edmItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		if (referenceSchemas == null)
		{
			referenceSchemas = new string[0];
		}

		ItemCollection itemCollection = null;
		sourcePath = _textTransformation.Host.ResolvePath(sourcePath);
		EdmItemCollectionBuilder collectionBuilder = new EdmItemCollectionBuilder(_textTransformation, referenceSchemas.Select(s => _textTransformation.Host.ResolvePath(s)).Where(s => s != sourcePath));
		if (collectionBuilder.TryCreateItemCollection(sourcePath, out itemCollection))
		{
			edmItemCollection = (EdmItemCollection)itemCollection;
		}

		return edmItemCollection != null;
	}

	/// <summary>
	/// Attempts to create a StoreItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateStoreItemCollection(string sourcePath, out StoreItemCollection storeItemCollection)
	{
		storeItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		ItemCollection itemCollection = null;
		StoreItemCollectionBuilder collectionBuilder = new StoreItemCollectionBuilder(_textTransformation);
		if (collectionBuilder.TryCreateItemCollection(_textTransformation.Host.ResolvePath(sourcePath), out itemCollection))
		{
			storeItemCollection = (StoreItemCollection)itemCollection;
		}
		return storeItemCollection != null;
	}

	/// <summary>
	/// Attempts to create a StorageMappingItemCollection from the specified metadata file, EdmItemCollection, and StoreItemCollection
	/// </summary>
	public bool TryCreateStorageMappingItemCollection(string sourcePath, EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection, out StorageMappingItemCollection storageMappingItemCollection)
	{
		storageMappingItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		if (edmItemCollection == null)
		{
			throw new ArgumentNullException("edmItemCollection");
		}

		if (storeItemCollection == null)
		{
			throw new ArgumentNullException("storeItemCollection");
		}

		ItemCollection itemCollection = null;
		StorageMappingItemCollectionBuilder collectionBuilder = new StorageMappingItemCollectionBuilder(_textTransformation, edmItemCollection, storeItemCollection);
		if (collectionBuilder.TryCreateItemCollection(_textTransformation.Host.ResolvePath(sourcePath), out itemCollection))
		{
			storageMappingItemCollection = (StorageMappingItemCollection)itemCollection;
		}
		return storageMappingItemCollection != null;
	}

	/// <summary>
	/// Gets the Model Namespace from the provided schema file.
	/// </summary>
	public string GetModelNamespace(string sourcePath)
	{
		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return String.Empty;
		}

		EdmItemCollectionBuilder builder = new EdmItemCollectionBuilder(_textTransformation);
		XElement model;
		if(builder.TryLoadRootElement(_textTransformation.Host.ResolvePath(sourcePath), out model))
		{
			XAttribute attribute = model.Attribute("Namespace");
			if (attribute != null)
			{
				return attribute.Value;
			}
		}

		return String.Empty;
	}

	/// <summary>
	/// Returns true if the specified file path is valid
	/// </summary>
	private static bool ValidateInputPath(string sourcePath, DynamicTextTransformation textTransformation)
	{
		if (String.IsNullOrEmpty(sourcePath))
		{
			throw new ArgumentException("sourcePath");
		}

		if(sourcePath == "$edmxInputFile$")
		{
			textTransformation.Errors.Add(new CompilerError(textTransformation.Host.TemplateFile ?? CodeGenerationTools.GetResourceString("Template_CurrentlyRunningTemplate"), 0, 0, string.Empty,
				CodeGenerationTools.GetResourceString("Template_ReplaceVsItemTemplateToken")));
			return false;
		}

		return true;
	}

	/// <summary>
	/// Base class for ItemCollectionBuilder classes that
	/// loads the specific types of metadata
	/// </summary>
	private abstract class ItemCollectionBuilder
	{
		private readonly DynamicTextTransformation _textTransformation;
		private readonly string _fileExtension;
		private readonly string _edmxSectionName;
		private readonly string  _rootElementName;

		/// <summary>
		/// FileExtension for individual (non-edmx) metadata file for this
		/// specific ItemCollection type
		/// </summary>
		public string FileExtension
		{
			get { return _fileExtension; }
		}

		/// <summary>
		/// The name of the XmlElement in the .edmx <Runtime> element
		/// to find this ItemCollection's metadata
		/// </summary>
		public string EdmxSectionName
		{
			get { return _edmxSectionName; }
		}

		/// <summary>
		/// The name of the root element of this ItemCollection's metadata
		/// </summary>
		public string RootElementName
		{
			get { return _rootElementName; }
		}

		/// <summary>
		/// Method to build the appropriate ItemCollection
		/// </summary>
		protected abstract ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors);

		/// <summary>
		/// Ctor to setup the ItemCollectionBuilder members
		/// </summary>
		protected ItemCollectionBuilder(DynamicTextTransformation textTransformation, string fileExtension, string edmxSectionName, string rootElementName)
		{
			_textTransformation = textTransformation;
			_fileExtension = fileExtension;
			_edmxSectionName = edmxSectionName;
			_rootElementName = rootElementName;
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected abstract string GetNamespace(SchemaConstants constants);

		/// <summary>
		/// Try to create an ItemCollection loaded with the metadata provided
		/// </summary>
		public bool TryCreateItemCollection(string sourcePath, out ItemCollection itemCollection)
		{
			itemCollection = null;

			if (!ValidateInputPath(sourcePath, _textTransformation))
			{
				return false;
			}

			XElement schemaElement = null;
			if (TryLoadRootElement(sourcePath, out schemaElement))
			{
				List<XmlReader> readers = new List<XmlReader>();
				try
				{
					var providerManifestToken = schemaElement.Attribute("ProviderManifestToken");
					int providerManifestTokenValue;
					if (providerManifestToken != null && int.TryParse(providerManifestToken.Value, out providerManifestTokenValue) && providerManifestTokenValue > 2008)
						providerManifestToken.Value = "2008";
					readers.Add(schemaElement.CreateReader());
					IList<EdmSchemaError> errors = null;

					ItemCollection tempItemCollection = CreateItemCollection(readers, out errors);
					if (ProcessErrors(errors, sourcePath))
					{
						return false;
					}

					itemCollection = tempItemCollection;
					return true;
				}
				finally
				{
					foreach (XmlReader reader in readers)
					{
						((IDisposable)reader).Dispose();
					}
				}
			}

			return false;
		}

		/// <summary>
		/// Tries to load the root element from the metadata file provided
		/// </summary>
		public bool TryLoadRootElement(string sourcePath, out XElement schemaElement)
		{
			schemaElement = null;
			string extension = Path.GetExtension(sourcePath);
			if (extension.Equals(".edmx", StringComparison.InvariantCultureIgnoreCase))
			{
				return TryLoadRootElementFromEdmx(sourcePath, out schemaElement);
			}
			else if(extension.Equals(FileExtension, StringComparison.InvariantCultureIgnoreCase))
			{
				// load from single metadata file (.csdl, .ssdl, or .msl)
				schemaElement = XElement.Load(sourcePath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);
				return true;
			}

			return false;
		}

		/// <summary>
		/// Tries to load the root element from the provided edmxDocument
		/// </summary>
		private bool TryLoadRootElementFromEdmx(XElement edmxDocument, SchemaConstants schemaConstants, string sectionName, string rootElementName, out XElement rootElement)
		{
			rootElement = null;

			XNamespace edmxNs = schemaConstants.EdmxNamespace;
			XNamespace sectionNs = GetNamespace(schemaConstants);

			XElement runtime = edmxDocument.Element(edmxNs  + "Runtime");
			if (runtime == null)
			{
				return false;
			}

			XElement section = runtime.Element(edmxNs + sectionName);
			if (section == null)
			{
				return false;
			}

			string templateVersion;

			if (!TemplateMetadata.TryGetValue(MetadataConstants.TT_TEMPLATE_VERSION, out templateVersion))
			{
				templateVersion = MetadataConstants.DEFAULT_TEMPLATE_VERSION;
			}

			if (schemaConstants.MinimumTemplateVersion > new Version(templateVersion))
			{
				_textTransformation.Errors.Add(new CompilerError(
					_textTransformation.Host.TemplateFile ?? CodeGenerationTools.GetResourceString("Template_CurrentlyRunningTemplate"), 0, 0, string.Empty,
						CodeGenerationTools.GetResourceString("Template_UnsupportedSchema"))
				{IsWarning = true});
			}

			rootElement = section.Element(sectionNs + rootElementName);
			return rootElement != null;
		}

		/// <summary>
		/// Tries to load the root element from the provided .edmx metadata file
		/// </summary>
		private bool TryLoadRootElementFromEdmx(string edmxPath, out XElement rootElement)
		{
			rootElement = null;

			XElement element = XElement.Load(edmxPath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);

			EdmxChanges.EdmxApplyChanges(edmxPath, element);

			return TryLoadRootElementFromEdmx(element, MetadataConstants.V3_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement)
				|| TryLoadRootElementFromEdmx(element, MetadataConstants.V2_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement)
				|| TryLoadRootElementFromEdmx(element, MetadataConstants.V1_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement);
		}

		/// <summary>
		/// Takes an Enumerable of EdmSchemaErrors, and adds them
		/// to the errors collection of the template class
		/// </summary>
		private bool ProcessErrors(IEnumerable<EdmSchemaError> errors, string sourceFilePath)
		{
			bool foundErrors = false;
			foreach (EdmSchemaError error in errors)
			{
				CompilerError newError = new CompilerError(error.SchemaLocation, error.Line, error.Column,
												 error.ErrorCode.ToString(CultureInfo.InvariantCulture),
												 error.Message);
				newError.IsWarning = error.Severity == EdmSchemaErrorSeverity.Warning;
				foundErrors |= error.Severity == EdmSchemaErrorSeverity.Error;
				if (error.SchemaLocation == null)
				{
					newError.FileName = sourceFilePath;
				}
				_textTransformation.Errors.Add(newError);
			}

			return foundErrors;
		}
	}

	/// <summary>
	/// Builder class for creating a StorageMappingItemCollection
	/// </summary>
	private class StorageMappingItemCollectionBuilder : ItemCollectionBuilder
	{
		private readonly EdmItemCollection _edmItemCollection;
		private readonly StoreItemCollection _storeItemCollection;

		public StorageMappingItemCollectionBuilder(DynamicTextTransformation textTransformation, EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection)
			: base(textTransformation, MetadataConstants.MSL_EXTENSION, MetadataConstants.MSL_EDMX_SECTION_NAME, MetadataConstants.MSL_ROOT_ELEMENT_NAME)
		{
			_edmItemCollection = edmItemCollection;
			_storeItemCollection = storeItemCollection;
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			return MetadataItemCollectionFactory.CreateStorageMappingItemCollection(_edmItemCollection, _storeItemCollection, readers, out errors);
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.MslNamespace;
		}
	}

	/// <summary>
	/// Builder class for creating a StoreItemCollection
	/// </summary>
	private class StoreItemCollectionBuilder : ItemCollectionBuilder
	{
		public StoreItemCollectionBuilder(DynamicTextTransformation textTransformation)
			: base(textTransformation, MetadataConstants.SSDL_EXTENSION, MetadataConstants.SSDL_EDMX_SECTION_NAME, MetadataConstants.SSDL_ROOT_ELEMENT_NAME)
		{
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			return MetadataItemCollectionFactory.CreateStoreItemCollection(readers, out errors);
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.SsdlNamespace;
		}
	}

	/// <summary>
	/// Builder class for creating a EdmItemCollection
	/// </summary>
	private class EdmItemCollectionBuilder : ItemCollectionBuilder
	{
		private List<string> _referenceSchemas = new List<string>();

		public EdmItemCollectionBuilder(DynamicTextTransformation textTransformation)
			: base(textTransformation, MetadataConstants.CSDL_EXTENSION, MetadataConstants.CSDL_EDMX_SECTION_NAME, MetadataConstants.CSDL_ROOT_ELEMENT_NAME)
		{
		}

		public EdmItemCollectionBuilder(DynamicTextTransformation textTransformation, IEnumerable<string> referenceSchemas)
			: this(textTransformation)
		{
			_referenceSchemas.AddRange(referenceSchemas);
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			List<XmlReader> ownedReaders = new List<XmlReader>();
			List<XmlReader> allReaders = new List<XmlReader>();
			try
			{
				allReaders.AddRange(readers);
				foreach (string path in _referenceSchemas.Distinct())
				{
					XElement reference;
					if(TryLoadRootElement(path, out reference))
					{
						XmlReader reader = reference.CreateReader();
						allReaders.Add(reader);
						ownedReaders.Add(reader);
					}
				}

				return MetadataItemCollectionFactory.CreateEdmItemCollection(allReaders, out errors);
			}
			finally
			{
				foreach (XmlReader reader in ownedReaders)
				{
					((IDisposable)reader).Dispose();
				}
			}
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.CsdlNamespace;
		}
	}
}

/// <summary>
/// Responsible for encapsulating the retrieval and translation of the CodeGeneration
/// annotations in the EntityFramework Metadata to a form that is useful in code generation.
/// </summary>
public static class Accessibility
{
	private const string GETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:GetterAccess";
	private const string SETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:SetterAccess";
	private const string TYPE_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:TypeAccess";
	private const string METHOD_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:MethodAccess";
	private const string ACCESS_PROTECTED = "Protected";
	private const string ACCESS_INTERNAL = "Internal";
	private const string ACCESS_PRIVATE = "Private";
	private static readonly Dictionary<string, int> AccessibilityRankIdLookup = new Dictionary<string, int>
		{
			{ "private", 1},
			{ "internal", 2},
			{ "protected", 3},
			{ "public", 4},
		};

	/// <summary>
	/// Gets the accessibility that should be applied to a type being generated from the provided GlobalItem.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForType(GlobalItem item)
	{
		if (item == null)
		{
			return null;
		}

		return GetAccessibility(item, TYPE_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return propertyAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a Read-Only property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForReadOnlyProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return GetAccessibility(member, GETTER_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a property being
	/// generated from the provided EntitySet.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForReadOnlyProperty(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return GetAccessibility(set, GETTER_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a Write-Only property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForWriteOnlyProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return GetAccessibility(member, SETTER_ACCESS);
	}


	/// <summary>
	/// Gets the accessibility that should be applied at the get level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to empty if no annotation is found or the accessibility is the same as the property level.
	/// </summary>
	public static string ForGetter(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return getterAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the set level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to empty if no annotation is found or the accessibility is the same as the property level.
	/// </summary>
	public static string ForSetter(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return setterAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied to a method being generated from the provided EdmFunction.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForMethod(EdmFunction function)
	{
		if (function == null)
		{
			return null;
		}

		return GetAccessibility(function, METHOD_ACCESS);
	}

	private static void CalculatePropertyAccessibility(MetadataItem item,
		out string propertyAccessibility,
		out string getterAccessibility,
		out string setterAccessibility)
	{
		getterAccessibility = GetAccessibility(item, GETTER_ACCESS);
		int getterRank = AccessibilityRankIdLookup[getterAccessibility];

		setterAccessibility = GetAccessibility(item, SETTER_ACCESS);
		int setterRank = AccessibilityRankIdLookup[setterAccessibility];

		int propertyRank = Math.Max(getterRank, setterRank);
		if (setterRank == propertyRank)
		{
			setterAccessibility = String.Empty;
		}

		if (getterRank == propertyRank)
		{
			getterAccessibility = String.Empty;
		}

		propertyAccessibility = AccessibilityRankIdLookup.Where(v => v.Value == propertyRank).Select(v => v.Key).Single();
	}

	private static string GetAccessibility(MetadataItem item, string name)
	{
		string accessibility;
		if (MetadataTools.TryGetStringMetadataPropertySetting(item, name, out accessibility))
		{
			return TranslateUserAccessibilityToCSharpAccessibility(accessibility);
		}

		return "public";
	}

	private static string TranslateUserAccessibilityToCSharpAccessibility(string userAccessibility)
	{
		if (userAccessibility == ACCESS_PROTECTED)
		{
			return "protected";
		}
		else if (userAccessibility == ACCESS_INTERNAL)
		{
			return "internal";
		}
		else if (userAccessibility == ACCESS_PRIVATE)
		{
			return "private";
		}
		else
		{
			// default to public
			return "public";
		}
	}
}

/// <summary>
/// Responsible for creating source code regions in code when the loop inside
/// actually produces something.
/// </summary>
public class CodeRegion
{
	private const int STANDARD_INDENT_LENGTH = 4;

	private readonly DynamicTextTransformation _textTransformation;
	private int _beforeRegionLength;
	private int _emptyRegionLength;
	private int _regionIndentLevel = -1;

	/// <summary>
	/// Initializes an CodeRegion instance with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public CodeRegion(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// Initializes an CodeRegion instance with the
	/// TextTransformation (T4 generated class) that is currently running,
	/// and the indent level to start the first region at.
	/// </summary>
	public CodeRegion(object textTransformation, int firstIndentLevel)
		: this(textTransformation)
	{
		if (firstIndentLevel < 0)
		{
			throw new ArgumentException("firstIndentLevel");
		}

		_regionIndentLevel = firstIndentLevel - 1;
	}

	/// <summary>
	/// Starts the begining of a region
	/// </summary>
	public void Begin(string regionName)
	{
		if (regionName == null)
		{
			throw new ArgumentNullException("regionName");
		}

		Begin(regionName, 1);
	}

	/// <summary>
	/// Start the begining of a region, indented
	/// the numbers of levels specified
	/// </summary>
	public void Begin(string regionName, int levelsToIncreaseIndent)
	{
		if (regionName == null)
		{
			throw new ArgumentNullException("regionName");
		}

		_beforeRegionLength = _textTransformation.GenerationEnvironment.Length;
		_regionIndentLevel += levelsToIncreaseIndent;
		_textTransformation.Write(GetIndent(_regionIndentLevel));
		_textTransformation.WriteLine("#region " + regionName);
		_emptyRegionLength = _textTransformation.GenerationEnvironment.Length;
	}

	/// <summary>
	/// Ends a region, or totaly removes it if nothing
	/// was generted since the begining of the region.
	/// </summary>
	public void End()
	{
		End(1);
	}

	/// <summary>
	/// Ends a region, or totaly removes it if nothing
	/// was generted since the begining of the region, also outdents
	/// the number of levels specified.
	/// </summary>
	public void End(int levelsToDecrease)
	{
		int indentLevel = _regionIndentLevel;
		_regionIndentLevel -= levelsToDecrease;

		if (_emptyRegionLength == _textTransformation.GenerationEnvironment.Length)
			_textTransformation.GenerationEnvironment.Length = _beforeRegionLength;
		else
		{
			_textTransformation.WriteLine(String.Empty);
			_textTransformation.Write(GetIndent(indentLevel));
			_textTransformation.WriteLine("#endregion");
			_textTransformation.WriteLine(String.Empty);
		}
	}

	/// <summary>
	/// Gets the current indent level that the next end region statement will be written
	/// at
	/// </summary>
	public int CurrentIndentLevel { get { return _regionIndentLevel; } }

	/// <summary>
	/// Get a string of spaces equivelent to the number of indents
	/// desired.
	/// </summary>
	public static string GetIndent(int indentLevel)
	{
		if (indentLevel < 0)
		{
			throw new ArgumentException("indentLevel");
		}

		return String.Empty.PadLeft(indentLevel * STANDARD_INDENT_LENGTH);
	}
}


/// <summary>
/// Responsible for collecting together the actual method parameters
/// and the parameters that need to be sent to the Execute method.
/// </summary>
public class FunctionImportParameter
{
	public FunctionParameter Source { get; set; }
	public string RawFunctionParameterName { get; set; }
	public string FunctionParameterName { get; set; }
	public string FunctionParameterType { get; set; }
	public string LocalVariableName { get; set; }
	public string RawClrTypeName { get; set; }
	public string ExecuteParameterName { get; set; }
	public string EsqlParameterName { get; set; }
	public bool NeedsLocalVariable { get; set; }
	public bool IsNullableOfT { get; set; }


	/// <summary>
	/// Creates a set of FunctionImportParameter objects from the parameters passed in.
	/// </summary>
	public static IEnumerable<FunctionImportParameter> Create(IEnumerable<FunctionParameter> parameters, CodeGenerationTools code, MetadataTools ef)
	{
		if (parameters == null)
		{
			throw new ArgumentNullException("parameters");
		}

		if (code == null)
		{
			throw new ArgumentNullException("code");
		}

		if (ef == null)
		{
			throw new ArgumentNullException("ef");
		}

		UniqueIdentifierService unique = new UniqueIdentifierService();
		List<FunctionImportParameter> importParameters = new List<FunctionImportParameter>();
		foreach (FunctionParameter parameter in parameters)
		{
			FunctionImportParameter importParameter = new FunctionImportParameter();
			importParameter.Source = parameter;
			importParameter.RawFunctionParameterName = unique.AdjustIdentifier(code.CamelCase(parameter.Name));
			importParameter.FunctionParameterName = code.Escape(importParameter.RawFunctionParameterName);
			if (parameter.Mode == ParameterMode.In)
			{
				TypeUsage typeUsage = parameter.TypeUsage;
				importParameter.NeedsLocalVariable = true;
				importParameter.FunctionParameterType = code.GetTypeName(typeUsage);
				importParameter.EsqlParameterName = parameter.Name;
				Type clrType = ef.UnderlyingClrType(parameter.TypeUsage.EdmType);
				importParameter.RawClrTypeName = typeUsage.EdmType is EnumType ? code.GetTypeName(typeUsage.EdmType) : code.Escape(clrType);
				importParameter.IsNullableOfT = clrType.IsValueType;
			}
			else
			{
				importParameter.NeedsLocalVariable = false;
				importParameter.FunctionParameterType = "ObjectParameter";
				importParameter.ExecuteParameterName = importParameter.FunctionParameterName;
			}
			importParameters.Add(importParameter);
		}

		// we save the local parameter uniquification for a second pass to make the visible parameters
		// as pretty and sensible as possible
		for (int i = 0; i < importParameters.Count; i++)
		{
			FunctionImportParameter importParameter = importParameters[i];
			if (importParameter.NeedsLocalVariable)
			{
				importParameter.LocalVariableName = unique.AdjustIdentifier(importParameter.RawFunctionParameterName + "Parameter");
				importParameter.ExecuteParameterName = importParameter.LocalVariableName;
			}
		}

		return importParameters;
	}

	//
	// Class to create unique variables within the same scope
	//
	private sealed class UniqueIdentifierService
	{
		private readonly HashSet<string> _knownIdentifiers;

		public UniqueIdentifierService()
		{
			_knownIdentifiers = new HashSet<string>(StringComparer.Ordinal);
		}

		/// <summary>
		/// Given an identifier, makes it unique within the scope by adding
		/// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
		/// </summary>
		public string AdjustIdentifier(string identifier)
		{
			// find a unique name by adding suffix as necessary
			int numberOfConflicts = 0;
			string adjustedIdentifier = identifier;

			while (!_knownIdentifiers.Add(adjustedIdentifier))
			{
				++numberOfConflicts;
				adjustedIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
			}

			return adjustedIdentifier;
		}
	}
}

/// <summary>
/// Responsible for marking the various sections of the generation,
/// so they can be split up into separate files
/// </summary>
public class EntityFrameworkTemplateFileManager
{
	/// <summary>
	/// Creates the VsEntityFrameworkTemplateFileManager if VS is detected, otherwise
	/// creates the file system version.
	/// </summary>
	public static EntityFrameworkTemplateFileManager Create(object textTransformation)
	{
		DynamicTextTransformation transformation = DynamicTextTransformation.Create(textTransformation);
		IDynamicHost host = transformation.Host;

#if !PREPROCESSED_TEMPLATE
		var hostServiceProvider = host.AsIServiceProvider();

		if (hostServiceProvider != null)
		{
			EnvDTE.DTE dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));

			if (dte != null)
			{
				return new VsEntityFrameworkTemplateFileManager(transformation);
			}
		}
#endif
		return new EntityFrameworkTemplateFileManager(transformation);
	}

	private sealed class Block
	{
		public String Name;
		public int Start, Length;
	}

	private readonly List<Block> files = new List<Block>();
	private readonly Block footer = new Block();
	private readonly Block header = new Block();
	private readonly DynamicTextTransformation _textTransformation;

	// reference to the GenerationEnvironment StringBuilder on the
	// TextTransformation object
	private readonly StringBuilder _generationEnvironment;

	private Block currentBlock;

	/// <summary>
	/// Initializes an EntityFrameworkTemplateFileManager Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	private EntityFrameworkTemplateFileManager(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
		_generationEnvironment = _textTransformation.GenerationEnvironment;
	}

	/// <summary>
	/// Marks the end of the last file if there was one, and starts a new
	/// and marks this point in generation as a new file.
	/// </summary>
	public void StartNewFile(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}

		CurrentBlock = new Block { Name = name };
	}

	public void StartFooter()
	{
		CurrentBlock = footer;
	}

	public void StartHeader()
	{
		CurrentBlock = header;
	}

	public void EndBlock()
	{
		if (CurrentBlock == null)
		{
			return;
		}

		CurrentBlock.Length = _generationEnvironment.Length - CurrentBlock.Start;

		if (CurrentBlock != header && CurrentBlock != footer)
		{
			files.Add(CurrentBlock);
		}

		currentBlock = null;
	}

	/// <summary>
	/// Produce the template output files.
	/// </summary>
	public virtual IEnumerable<string> Process(bool split = true)
	{
		var generatedFileNames = new List<string>();

		if (split)
		{
			EndBlock();

			var headerText = _generationEnvironment.ToString(header.Start, header.Length);
			var footerText = _generationEnvironment.ToString(footer.Start, footer.Length);
			var outputPath = Path.GetDirectoryName(_textTransformation.Host.TemplateFile);

			files.Reverse();

			foreach (var block in files)
			{
				var fileName = Path.Combine(outputPath, block.Name);
				var content = headerText + _generationEnvironment.ToString(block.Start, block.Length) + footerText;

				generatedFileNames.Add(fileName);
				CreateFile(fileName, content);
				_generationEnvironment.Remove(block.Start, block.Length);
			}
		}

		return generatedFileNames;
	}

	protected virtual void CreateFile(string fileName, string content)
	{
		if (IsFileContentDifferent(fileName, content))
		{
			File.WriteAllText(fileName, content);
		}
	}

	protected bool IsFileContentDifferent(String fileName, string newContent)
	{
		return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
	}

	private Block CurrentBlock
	{
		get { return currentBlock; }
		set
		{
			if (CurrentBlock != null)
			{
				EndBlock();
			}

			if (value != null)
			{
				value.Start = _generationEnvironment.Length;
			}

			currentBlock = value;
		}
	}

#if !PREPROCESSED_TEMPLATE
	private sealed class VsEntityFrameworkTemplateFileManager : EntityFrameworkTemplateFileManager
	{
		private EnvDTE.ProjectItem templateProjectItem;
		private EnvDTE.DTE dte;
		private Action<string> checkOutAction;
		private Action<IEnumerable<string>> projectSyncAction;

		/// <summary>
		/// Creates an instance of the VsEntityFrameworkTemplateFileManager class with the IDynamicHost instance
		/// </summary>
		public VsEntityFrameworkTemplateFileManager(object textTemplating)
			: base(textTemplating)
		{
			var hostServiceProvider = _textTransformation.Host.AsIServiceProvider();
			if (hostServiceProvider == null)
			{
				throw new ArgumentNullException("Could not obtain hostServiceProvider");
			}

			dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
			if (dte == null)
			{
				throw new ArgumentNullException("Could not obtain DTE from host");
			}

			templateProjectItem = dte.Solution.FindProjectItem(_textTransformation.Host.TemplateFile);

			checkOutAction = fileName => dte.SourceControl.CheckOutItem(fileName);
			projectSyncAction = keepFileNames => ProjectSync(templateProjectItem, keepFileNames);
		}

		public override IEnumerable<string> Process(bool split)
		{
			if (templateProjectItem.ProjectItems == null)
			{
				return new List<string>();
			}

			var generatedFileNames = base.Process(split);

			projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));

			return generatedFileNames;
		}

		protected override void CreateFile(string fileName, string content)
		{
			if (IsFileContentDifferent(fileName, content))
			{
				CheckoutFileIfRequired(fileName);
				File.WriteAllText(fileName, content);
			}
		}

		private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<string> keepFileNames)
		{
			var keepFileNameSet = new HashSet<string>(keepFileNames);
			var projectFiles = new Dictionary<string, EnvDTE.ProjectItem>();
			var originalOutput = Path.GetFileNameWithoutExtension(templateProjectItem.FileNames[0]);

			foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
			{
				projectFiles.Add(projectItem.FileNames[0], projectItem);
			}

			// Remove unused items from the project
			foreach (var pair in projectFiles)
			{
				if (!keepFileNames.Contains(pair.Key)
					&& !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalOutput + "."))
				{
					pair.Value.Delete();
				}
			}

			// Add missing files to the project
			foreach (string fileName in keepFileNameSet)
			{
				if (!projectFiles.ContainsKey(fileName))
				{
					templateProjectItem.ProjectItems.AddFromFile(fileName);
				}
			}
		}

		private void CheckoutFileIfRequired(string fileName)
		{
			if (dte.SourceControl == null
				|| !dte.SourceControl.IsItemUnderSCC(fileName)
					|| dte.SourceControl.IsItemCheckedOut(fileName))
			{
				return;
			}

			// run on worker thread to prevent T4 calling back into VS
			checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
		}
	}
#endif
}

/// <summary>
/// Responsible creating an instance that can be passed
/// to helper classes that need to access the TextTransformation
/// members.  It accesses member by name and signature rather than
/// by type.  This is necessary when the
/// template is being used in Preprocessed mode
/// and there is no common known type that can be
/// passed instead
/// </summary>
public class DynamicTextTransformation
{
	private object _instance;
	IDynamicHost _dynamicHost;

	private readonly MethodInfo _write;
	private readonly MethodInfo _writeLine;
	private readonly PropertyInfo _generationEnvironment;
	private readonly PropertyInfo _errors;
	private readonly PropertyInfo _host;

	private DynamicTextTransformation()
	{
	}

	/// <summary>
	/// Creates an instance of the DynamicTextTransformation class around the passed in
	/// TextTransformation shapped instance passed in, or if the passed in instance
	/// already is a DynamicTextTransformation, it casts it and sends it back.
	/// </summary>
	public static DynamicTextTransformation Create(object instance)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}

		DynamicTextTransformation textTransformation = instance as DynamicTextTransformation;
		if (textTransformation != null)
		{
			return textTransformation;
		}

		return new DynamicTextTransformation(instance);
	}

	private DynamicTextTransformation(object instance)
	{
		_instance = instance;
		Type type = _instance.GetType();
		_write = type.GetMethod("Write", new Type[] { typeof(string) });
		_writeLine = type.GetMethod("WriteLine", new Type[] { typeof(string) });
		_generationEnvironment = type.GetProperty("GenerationEnvironment", BindingFlags.Instance | BindingFlags.NonPublic);
		_host = type.GetProperty("Host");
		_errors = type.GetProperty("Errors");
	}

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's GenerationEnvironment property
	/// </summary>
	public StringBuilder GenerationEnvironment { get { return (StringBuilder)_generationEnvironment.GetValue(_instance, null); } }

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's Errors property
	/// </summary>
	public System.CodeDom.Compiler.CompilerErrorCollection Errors { get { return (System.CodeDom.Compiler.CompilerErrorCollection)_errors.GetValue(_instance, null); } }

	/// <summary>
	/// Calls the wrapped TextTranformation instance's Write method.
	/// </summary>
	public void Write(string text)
	{
		_write.Invoke(_instance, new object[] { text });
	}

	/// <summary>
	/// Calls the wrapped TextTranformation instance's WriteLine method.
	/// </summary>
	public void WriteLine(string text)
	{
		_writeLine.Invoke(_instance, new object[] { text });
	}

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's Host property
	/// if available (shows up when hostspecific is set to true in the template directive) and returns
	/// the appropriate implementation of IDynamicHost
	/// </summary>
	public IDynamicHost Host
	{
		get
		{
			if (_dynamicHost == null)
			{
				if(_host == null)
				{
					_dynamicHost = new NullHost();
				}
				else
				{
					_dynamicHost = new DynamicHost(_host.GetValue(_instance, null));
				}
			}
			return _dynamicHost;
		}
	}
}


/// <summary>
/// Reponsible for abstracting the use of Host between times
/// when it is available and not
/// </summary>
public interface IDynamicHost
{
	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// </summary>
	string ResolveParameterValue(string id, string name, string otherName);

	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// </summary>
	string ResolvePath(string path);

	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// </summary>
	string TemplateFile { get; }

	/// <summary>
	/// Returns the Host instance cast as an IServiceProvider
	/// </summary>
	IServiceProvider AsIServiceProvider();
}

/// <summary>
/// Reponsible for implementing the IDynamicHost as a dynamic
/// shape wrapper over the Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost interface
/// rather than type dependent wrapper.  We don't use the
/// interface type so that the code can be run in preprocessed mode
/// on a .net framework only installed machine.
/// </summary>
public class DynamicHost : IDynamicHost
{
	private readonly object _instance;
	private readonly MethodInfo _resolveParameterValue;
	private readonly MethodInfo _resolvePath;
	private readonly PropertyInfo _templateFile;

	private DynamicHost()
	{
	}

	/// <summary>
	/// Creates an instance of the DynamicHost class around the passed in
	/// Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost shapped instance passed in.
	/// </summary>
	public DynamicHost(object instance)
	{
		_instance = instance;
		Type type = _instance.GetType();
		_resolveParameterValue = type.GetMethod("ResolveParameterValue", new Type[] { typeof(string), typeof(string), typeof(string) });
		_resolvePath = type.GetMethod("ResolvePath", new Type[] { typeof(string) });
		_templateFile = type.GetProperty("TemplateFile");

	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// </summary>
	public string ResolveParameterValue(string id, string name, string otherName)
	{
		return (string)_resolveParameterValue.Invoke(_instance, new object[] { id, name, otherName });
	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// </summary>
	public string ResolvePath(string path)
	{
		return (string)_resolvePath.Invoke(_instance, new object[] { path });
	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// </summary>
	public string TemplateFile
	{
		get
		{
			return (string)_templateFile.GetValue(_instance, null);
		}
	}

	/// <summary>
	/// Returns the Host instance cast as an IServiceProvider
	/// </summary>
	public IServiceProvider AsIServiceProvider()
	{
		return _instance as IServiceProvider;
	}
}

/// <summary>
/// Reponsible for implementing the IDynamicHost when the
/// Host property is not available on the TextTemplating type. The Host
/// property only exists when the hostspecific attribute of the template
/// directive is set to true.
/// </summary>
public class NullHost : IDynamicHost
{
	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// that simply retuns null.
	/// </summary>
	public string ResolveParameterValue(string id, string name, string otherName)
	{
		return null;
	}

	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// that simply retuns the path passed in.
	/// </summary>
	public string ResolvePath(string path)
	{
		return path;
	}

	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// that returns null.
	/// </summary>
	public string TemplateFile
	{
		get
		{
			return null;
		}
	}

	/// <summary>
	/// Returns null.
	/// </summary>
	public IServiceProvider AsIServiceProvider()
	{
		return null;
	}
}

/// <summary>
/// Responsible for encapsulating the constants defined in Metadata
/// </summary>
public static class MetadataConstants
{
	public const string CSDL_EXTENSION = ".csdl";

	public const string CSDL_EDMX_SECTION_NAME = "ConceptualModels";
	public const string CSDL_ROOT_ELEMENT_NAME = "Schema";
	public const string EDM_ANNOTATION_09_02 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

	public const string SSDL_EXTENSION = ".ssdl";

	public const string SSDL_EDMX_SECTION_NAME = "StorageModels";
	public const string SSDL_ROOT_ELEMENT_NAME = "Schema";

	public const string MSL_EXTENSION = ".msl";

	public const string MSL_EDMX_SECTION_NAME = "Mappings";
	public const string MSL_ROOT_ELEMENT_NAME = "Mapping";

	public const string TT_TEMPLATE_NAME = "TemplateName";
	public const string TT_TEMPLATE_VERSION = "TemplateVersion";
	public const string TT_MINIMUM_ENTITY_FRAMEWORK_VERSION = "MinimumEntityFrameworkVersion";

	public const string DEFAULT_TEMPLATE_VERSION = "5.0";

	public static readonly SchemaConstants V1_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2007/06/edmx",
		"http://schemas.microsoft.com/ado/2006/04/edm",
		"http://schemas.microsoft.com/ado/2006/04/edm/ssdl",
		"urn:schemas-microsoft-com:windows:storage:mapping:CS",
		new Version("3.5"));

	public static readonly SchemaConstants V2_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2008/10/edmx",
		"http://schemas.microsoft.com/ado/2008/09/edm",
		"http://schemas.microsoft.com/ado/2009/02/edm/ssdl",
		"http://schemas.microsoft.com/ado/2008/09/mapping/cs",
		new Version("4.0"));

	public static readonly SchemaConstants V3_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2009/11/edmx",
		"http://schemas.microsoft.com/ado/2009/11/edm",
		"http://schemas.microsoft.com/ado/2009/11/edm/ssdl",
		"http://schemas.microsoft.com/ado/2009/11/mapping/cs",
		new Version("4.5"));
}

public struct SchemaConstants
{
	public SchemaConstants(string edmxNamespace, string csdlNamespace, string ssdlNamespace, string mslNamespace, Version minimumTemplateVersion) : this()
	{
		EdmxNamespace = edmxNamespace;
		CsdlNamespace = csdlNamespace;
		SsdlNamespace = ssdlNamespace;
		MslNamespace = mslNamespace;
		MinimumTemplateVersion = minimumTemplateVersion;
	}

	public string EdmxNamespace { get; private set; }
	public string CsdlNamespace { get; private set; }
	public string SsdlNamespace { get; private set; }
	public string MslNamespace { get; private set; }
	public Version MinimumTemplateVersion { get; private set; }
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

string edmxUtilityTTIncludeName = "WCFAsyncQueryableServices.VS12.Edmx.Utility.ttinclude";

private static string EDM_NS4 = "http://schemas.microsoft.com/ado/2008/10/edmx";
private static string SSDL_NS4 = "http://schemas.microsoft.com/ado/2009/02/edm/ssdl";
private static string CSDL_NS4 = "http://schemas.microsoft.com/ado/2008/09/edm";
private static string MSL_NS4 = "http://schemas.microsoft.com/ado/2008/09/mapping/cs";
private static string annotation_NS4 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

private static string EDM_NS5 = "http://schemas.microsoft.com/ado/2009/11/edmx";
private static string SSDL_NS5 = "http://schemas.microsoft.com/ado/2009/11/edm/ssdl";
private static string CSDL_NS5 = "http://schemas.microsoft.com/ado/2009/11/edm";
private static string MSL_NS5 = "http://schemas.microsoft.com/ado/2009/11/mapping/cs";
private static string annotation_NS5 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

public static string GetEDM_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? EDM_NS4 : EDM_NS5;
}

public static string GetSSDL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? SSDL_NS4 : SSDL_NS5;
}

public static string GetCSDL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? CSDL_NS4 : CSDL_NS5;
}

public static string GetMSL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? MSL_NS4 : MSL_NS5;
}

public static string GetAnnotation_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? annotation_NS4 : annotation_NS5;
}

public static IEnumerable<EdmType> GetAllTypes(EdmItemCollection itemCollection)
{
	return itemCollection.GetItems<EntityType>().Cast<EdmType>().Union(itemCollection.GetItems<ComplexType>()).Union(itemCollection.GetItems<EnumType>());
}

partial class OriginalValueMembers
{
	IEnumerable<EdmMember> GetRelevantMembersForUpdate(MetadataWorkspace metadataWorkspace, EntitySetBase entitySet, EntityTypeBase entityType, bool partialUpdateSupported)
	{
		return metadataWorkspace.GetRelevantMembersForUpdate(entitySet, entityType, true);   
	}
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

public static IEnumerable<EnvDTE.Project> GetProjects(ITextTemplatingEngineHost host)
{
    var serviceProvider = (IServiceProvider)host;
    var dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
    var projects = dte.Solution.Projects.OfType<object>().ToList();
    while (projects.Count != 0)
    {
        var projectsValue = projects.ToList();
        projects.Clear();
        foreach (var item in projectsValue)
        {
            if (item != null)
            { 
                var project = item as EnvDTE.Project;
                if (project != null) 
                {
                    if (project.Properties == null) // unload project in a folder
                        continue;
                    if (project.FullName.EndsWith(".csproj"))
                        yield return project;
                    else if (project.ProjectItems != null)
                        projects.AddRange(project.ProjectItems.OfType<object>());
                }
                else 
                { 
                    var projectItem = item as EnvDTE.ProjectItem;
                    if (projectItem != null)
                    {
                        if (projectItem.SubProject != null)
                            projects.Add(projectItem.SubProject);
                        if (projectItem.ProjectItems != null)
                            projects.AddRange(projectItem.ProjectItems.OfType<object>());
                    }
                }                
            }
        }
    }
}

public static IEnumerable<EnvDTE.ProjectItem> GetAllCsItems(EnvDTE.Project parent)
{
    if (parent != null)
        foreach (EnvDTE.ProjectItem value in parent.ProjectItems)
        {
            if (! value.Name.EndsWith(".tt"))
            {
                if (value.Name.EndsWith(".cs"))
                    yield return value;
                else if (value != parent && value.Name != null)
                {
                    foreach (var item in GetAllCsItems(value))
                        yield return item;
                    foreach (var item in GetAllCsItems(value.SubProject))
                        yield return item;
                }
            }
        }
}
public static IEnumerable<EnvDTE.ProjectItem> GetAllCsItems(EnvDTE.ProjectItem parent)
{
    if (parent != null)
        foreach (EnvDTE.ProjectItem value in parent.ProjectItems)
        {
            if (! value.Name.EndsWith(".tt"))
            {
                if (value.Name.EndsWith(".cs"))
                    yield return value;
                else if (value != parent && value.Name != null)
                {
                    foreach (var item in GetAllCsItems(value))
                        yield return item;
                    foreach (var item in GetAllCsItems(value.SubProject))
                        yield return item;
                }
            }
        }
}

public class SpecificationsElements
{
    public enum Type
    {
        Server,
        UnitTest,
        Client
    }

    public enum MethodAnalizing
    {
        Method,
        Signature,
        None
    }

    private SpecificationsElements(Dictionary<string, object> cache)
    {
        Usings = new Dictionary<string, List<string>>();
        Solution = (ISolution)cache["Solution"];
        GetMethods = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["GetMethods"];
        ValidateMethods = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["ValidateMethods"];
        ServiceMethods = (List<MethodDeclarationSyntax>)cache["ServiceMethods"];
        AllServiceMethods = (List<MethodDeclarationSyntax>)cache["AllServiceMethods"];
        SubMethods = (List<MethodDeclarationSyntax>)cache["SubMethods"];
        Methods = (List<MethodDeclarationSyntax>)cache["Methods"];
        var metadata = (Dictionary<string, List<Dictionary<string, object>>>)cache["Metadata"];
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        var metadataValues = new Dictionary<int, WAQSMetadata>();
        foreach (var m in metadata)
            Metadata.Add(m.Key, m.Value.Select(m2 => 
                {
                    var mValue = WAQSMetadata.Get(m2);
                    metadataValues.Add((int)m2["HashCode"], mValue);
                    return mValue;
                }).ToList());
        ExtensionMethods = (List<MethodDeclarationSyntax>)cache["ExtensionMethods"];
        NonExtensionMethods = (List<MethodDeclarationSyntax>)cache["NonExtensionMethods"];
        NonEntitiesExtensionMethods = (List<MethodDeclarationSyntax>)cache["NonEntitiesExtensionMethods"];
        ServiceProperties = (List<PropertySymbol>)cache["ServiceProperties"];
        var methodsDependentProperties = (Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>)cache["MethodsDependentProperties"];
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        foreach (var mdp in methodsDependentProperties)
            MethodsDependentProperties.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(PropertySymbolInfo.Get).ToList()).ToList());
        var methodsDependentPropertiesLast = (Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>)cache["MethodsDependentPropertiesLast"];
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        foreach (var mdp in methodsDependentPropertiesLast)
            MethodsDependentPropertiesLast.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(PropertySymbolInfo.Get).ToList()).ToList());
        SemanticModelPerMethods = (ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>)cache["SemanticModelPerMethods"];
        MethodPerMethodSymbols = (ConcurrentDictionary<string, MethodDeclarationSyntax>)cache["MethodPerMethodSymbols"];
        MethodSymbolPerMethods = (ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>)cache["MethodSymbolPerMethods"];
        CompilationUnitPerClass = (Dictionary<string, List<CompilationUnitSyntax>>)cache["CompilationUnitPerClass"];
        var semanticModelPerMetadata = (Dictionary<Dictionary<string, object>, ISemanticModel>)cache["SemanticModelPerMetadata"];
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        foreach (var smpm in semanticModelPerMetadata)
            SemanticModelPerMetadata.Add(metadataValues[(int)smpm.Key["HashCode"]], smpm.Value);
        InterfacesPerClasses = (Dictionary<string, List<NamedTypeSymbol>>)cache["InterfacesPerClasses"];
        ClassesPerInterfaces = (Dictionary<string, List<string>>)cache["ClassesPerInterfaces"];
        ClassTypesPerInterfaces = (Dictionary<string, List<NamedTypeSymbol>>)cache["ClassTypesPerInterfaces"];
        TypeSymbols = (Dictionary<string, TypeSymbol>)cache["TypeSymbols"];
        Documents = (List<IDocument>)cache["Documents"];
        CompilationUnitSyntaxes = (List<CompilationUnitSyntax>)cache["CompilationUnitSyntaxes"];
        SemanticModelPerCompilationUnits = (Dictionary<CompilationUnitSyntax, ISemanticModel>)cache["SemanticModelPerCompilationUnits"];
        SpecificationsNamespaces = (List<string>)cache["SpecificationsNamespaces"];
        SpecificationsTypes = (List<TypeSymbol>)cache["SpecificationsTypes"];
        _servicePropertiesStrings = (List<string>)cache["_servicePropertiesStrings"];
        var classes = (List<Dictionary<string, object>>)cache["_classes"];
        _classes = new List<ClassNames>();
        foreach (var cn in classes)
            _classes.Add(ClassNames.Get(cn));
        _extensionMethodsPerTypes = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["_extensionMethodsPerTypes"];
        _nonValidationExtensionMethodsPerTypes = (Dictionary<string, List<MethodDeclarationSyntax>>)cache["_nonValidationExtensionMethodsPerTypes"];
        _getMethodSymbols = (HashSet<MethodSymbol>)cache["_getMethodSymbols"];
        _allValidateMethods = (HashSet<MethodDeclarationSyntax>)cache["_allValidateMethods"];
        _abstractMethods = (HashSet<MethodDeclarationSyntax>)cache["_abstractMethods"];
        _virtualMethods = (HashSet<MethodDeclarationSyntax>)cache["_virtualMethods"];
        _overrideMethods = (HashSet<MethodDeclarationSyntax>)cache["_overrideMethods"];
        _customMethods = (HashSet<MethodDeclarationSyntax>)cache["_customMethods"];
        _validateFuncMethods = (HashSet<MethodDeclarationSyntax>)cache["_validateFuncMethods"];
        _useServiceProperty = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_useServiceProperty"];
        _isApplicableOnClient = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isApplicableOnClient"];
        _isExposedAsService = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isExposedAsService"];
        _isDefineMethod = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isDefineMethod"];
        _isGetMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>)cache["_isGetMethod"];
        _isValidateMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>)cache["_isValidateMethod"];
        _isServiceMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isServiceMethod"];
        _isSubMethod = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isSubMethod"];
        var overridenMethods = (Dictionary<MethodDeclarationSyntax, List<Dictionary<string, object>>>)cache["_overridenMethods"];
        foreach (var om in overridenMethods)
            _overridenMethods.TryAdd(om.Key, om.Value.Select(MethodWithDepth.Get).ToList());
        _isModeOnInsert = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnInsert"];
        _isModeOnUpdate = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnUpdate"];
        _isModeOnDelete = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isModeOnDelete"];
        _isValidatableOnInsertOutsideTransaction = (ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>)cache["_isValidatableOnInsertOutsideTransaction"];
        _isCriticityError = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isCriticityError"];
        _isValidatedInTransaction = (ConcurrentDictionary<MethodDeclarationSyntax, bool>)cache["_isValidatedInTransaction"];
        _dependentNavigationProperties = (ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>>)cache["_dependentNavigationProperties"];
        _equivalentMethods = (ConcurrentDictionary<MethodSymbol, MethodSymbol>)cache["_equivalentMethods"];
        _typeSymbolPerTypes = (ConcurrentDictionary<TypeSyntax, TypeSymbol>)cache["_typeSymbolPerTypes"];
        ServerFxDALInterfacesNamespace = (string)cache["ServerFxDALInterfacesNamespace"];
        ServerFxServiceInterfacesNamespace = (string)cache["ServerFxServiceInterfacesNamespace"];
        ServerFxSpecificationsNamespace = (string)cache["ServerFxSpecificationsNamespace"];
    }

    public static SpecificationsElements Get(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, SpecificationPath entitiesPath, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, EdmxElements edmxElements, SpecificationsElements.Type type, bool dal = false, bool service = false, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null, bool isInterface = false)
    {
        var sb = new StringBuilder();
        var lastWriteTime = new FileInfo(edmxElements.EdmxPath).LastWriteTime;
        sb.Append(Path.GetFullPath(host.ResolvePath(edmxElements.EdmxPath)));
        if (entitiesPath != null)
        {
            var entitiesPathCsproj = Path.GetFullPath(host.ResolvePath(entitiesPath.Csproj));
            var project = GetProjects(host).First(p => p.FullName == entitiesPathCsproj);
            var entitiesPathFolder = host.ResolvePath(entitiesPath.Folder);
            sb.Append(entitiesPathFolder);
            foreach (var file in GetAllCsItems(project).Select(i => (string)i.Properties.OfType<EnvDTE.Property>().First(p => p.Name == "LocalPath").Value))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationPathFolder = Path.GetFullPath(host.ResolvePath(specificationPath.Folder));
            sb.Append(specificationPathFolder);
            foreach (var file in Directory.GetFiles(host.ResolvePath(specificationPathFolder)).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        string cacheKey = sb.ToString();
        SpecificationsElements value;
        var cache = System.AppDomain.CurrentDomain.GetData(cacheKey) as Dictionary<string, object>;
        if (cache != null && (DateTime)cache["LastWriteTime"] == lastWriteTime)
        {
            value = new SpecificationsElements(cache);
            value.Init(type, dal, service, isInterface, entitiesNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            return value;
        }
        ISolution solution = null;
        IProject entitiesProject = null;
        List<IDocument> entitiesDocuments = null;
        var specificationDocuments = new Dictionary<IDocument, Compilation>();
        if (specificationPathes.Length != 0 && entitiesPath != null)
        {
            var entitiesSlnFilePath = Path.GetFullPath(host.ResolvePath(entitiesPath.Sln));
            var entitiesSolution = LoadSolution(entitiesSlnFilePath, host);
            var entitiesProjectPath = Path.GetFullPath(host.ResolvePath(entitiesPath.Csproj));
            entitiesProject = entitiesSolution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == entitiesProjectPath);
            if (entitiesProject == null)
                goto EntitiesDocumentsNull;
            var entitiesFolderPath = entitiesPath.Folder;
            entitiesFolderPath = Path.GetFullPath(host.ResolvePath(entitiesFolderPath));
            entitiesDocuments = entitiesProject.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(entitiesFolderPath)).ToList();
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationSlnFilePath = Path.GetFullPath(host.ResolvePath(specificationPath.Sln));
            solution = LoadSolution(specificationSlnFilePath, host);
            var specificationProjectPath = Path.GetFullPath(host.ResolvePath(specificationPath.Csproj));
            var project = solution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == specificationProjectPath);
            var specificationFolderPath = specificationPath.Folder;
            specificationFolderPath = Path.GetFullPath(host.ResolvePath(specificationFolderPath));
            var compilation = GetCompilation(project);
            foreach (var document in project.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(specificationFolderPath) && ! Path.GetFullPath(d.FilePath).EndsWith(".Designer.cs")))
                specificationDocuments.Add(document, compilation);
        }
EntitiesDocumentsNull:
        value = new SpecificationsElements(host, specificationPathes, entitiesPath, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, entitiesNamespace, edmxElements, type, dal, service, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol, isInterface, solution, entitiesProject, entitiesDocuments, specificationDocuments);
        Cache(cacheKey, value, lastWriteTime);
        return value;
    }
    private static void Cache(string cacheKey, SpecificationsElements value, DateTime lastWriteTime)
    {
        var cache = new Dictionary<string, object>();
        cache.Add("LastWriteTime", lastWriteTime);
        cache.Add("Solution", value.Solution);
        cache.Add("GetMethods", value.GetMethods);
        cache.Add("ValidateMethods", value.ValidateMethods);
        cache.Add("ServiceMethods", value.ServiceMethods);
        cache.Add("AllServiceMethods", value.AllServiceMethods);
        cache.Add("SubMethods", value.SubMethods);
        cache.Add("Methods", value.Methods);
        var metadata = new Dictionary<string, List<Dictionary<string, object>>>();
        foreach (var m in value.Metadata)
            metadata.Add(m.Key, m.Value.Select(wm => wm.ToCache()).ToList());
        cache.Add("Metadata", metadata);
        cache.Add("ExtensionMethods", value.ExtensionMethods);
        cache.Add("NonExtensionMethods", value.NonExtensionMethods);
        cache.Add("NonEntitiesExtensionMethods", value.NonEntitiesExtensionMethods);
        cache.Add("ServiceProperties", value.ServiceProperties);
        var methodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>();
        foreach (var mdp in value.MethodsDependentProperties)
            methodsDependentProperties.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(mdp2 => mdp2.ToCache()).ToList()).ToList());
        cache.Add("MethodsDependentProperties", methodsDependentProperties);
        var methodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<Dictionary<string, object>>>>();
        foreach (var mdp in value.MethodsDependentPropertiesLast)
            methodsDependentPropertiesLast.Add(mdp.Key, mdp.Value == null ? null : mdp.Value.Select(mdps => mdps.Select(mdp2 => mdp2.ToCache()).ToList()).ToList());
        cache.Add("MethodsDependentPropertiesLast", methodsDependentPropertiesLast);
        cache.Add("SemanticModelPerMethods", value.SemanticModelPerMethods);
        cache.Add("MethodPerMethodSymbols", value.MethodPerMethodSymbols);
        cache.Add("MethodSymbolPerMethods", value.MethodSymbolPerMethods);
        cache.Add("CompilationUnitPerClass", value.CompilationUnitPerClass);
        var semanticModelPerMetadata = new Dictionary<Dictionary<string, object>, ISemanticModel>();
        foreach (var smpm in value.SemanticModelPerMetadata)
            semanticModelPerMetadata.Add(smpm.Key.ToCache(), smpm.Value);
        cache.Add("SemanticModelPerMetadata", semanticModelPerMetadata);
        cache.Add("Usings", value.Usings);
        cache.Add("InterfacesPerClasses", value.InterfacesPerClasses);
        cache.Add("ClassesPerInterfaces", value.ClassesPerInterfaces);
        cache.Add("ClassTypesPerInterfaces", value.ClassTypesPerInterfaces);
        cache.Add("TypeSymbols", value.TypeSymbols);
        cache.Add("Documents", value.Documents);
        cache.Add("CompilationUnitSyntaxes", value.CompilationUnitSyntaxes);
        cache.Add("SemanticModelPerCompilationUnits", value.SemanticModelPerCompilationUnits);
        cache.Add("SpecificationsNamespaces", value.SpecificationsNamespaces);
        cache.Add("SpecificationsTypes", value.SpecificationsTypes);
        cache.Add("InterfaceSpecifications", value.InterfaceSpecifications);
        cache.Add("InterfaceExtensionMethods", value.InterfaceExtensionMethods);
        cache.Add("_servicePropertiesStrings", value._servicePropertiesStrings);
        cache.Add("_classes", value._classes.Select(c => c.ToCache()).ToList());
        cache.Add("_extensionMethodsPerTypes", value._extensionMethodsPerTypes);
        cache.Add("_nonValidationExtensionMethodsPerTypes", value._nonValidationExtensionMethodsPerTypes);
        cache.Add("_getMethodSymbols", value._getMethodSymbols);
        cache.Add("_allValidateMethods", value._allValidateMethods);
        cache.Add("_abstractMethods", value._abstractMethods);
        cache.Add("_virtualMethods", value._virtualMethods);
        cache.Add("_overrideMethods", value._overrideMethods);
        cache.Add("_customMethods", value._customMethods);
        cache.Add("_validateFuncMethods", value._validateFuncMethods);
        cache.Add("_useServiceProperty", value._useServiceProperty);
        cache.Add("_isApplicableOnClient", value._isApplicableOnClient);
        cache.Add("_isExposedAsService", value._isExposedAsService);
        cache.Add("_isDefineMethod", value._isDefineMethod);
        cache.Add("_isGetMethod", value._isGetMethod);
        cache.Add("_isValidateMethod", value._isValidateMethod);
        cache.Add("_isServiceMethod", value._isServiceMethod);
        cache.Add("_isSubMethod", value._isSubMethod);
        var overridenMethods = new Dictionary<MethodDeclarationSyntax, List<Dictionary<string, object>>>();
        foreach (var om in value._overridenMethods)
            overridenMethods.Add(om.Key, om.Value.Select(mwd => mwd.ToCache()).ToList());
        cache.Add("_overridenMethods", overridenMethods);
        cache.Add("_isModeOnInsert", value._isModeOnInsert);
        cache.Add("_isModeOnUpdate", value._isModeOnUpdate);
        cache.Add("_isModeOnDelete", value._isModeOnDelete);
        cache.Add("_isValidatableOnInsertOutsideTransaction", value._isValidatableOnInsertOutsideTransaction);
        cache.Add("_isCriticityError", value._isCriticityError);
        cache.Add("_isValidatedInTransaction", value._isValidatedInTransaction);
        cache.Add("_dependentNavigationProperties", value._dependentNavigationProperties);
        cache.Add("_equivalentMethods", value._equivalentMethods);
        cache.Add("_typeSymbolPerTypes", value._typeSymbolPerTypes);
        cache.Add("ServerFxDALInterfacesNamespace", value.ServerFxDALInterfacesNamespace);
        cache.Add("ServerFxServiceInterfacesNamespace", value.ServerFxServiceInterfacesNamespace);
        cache.Add("ServerFxSpecificationsNamespace", value.ServerFxSpecificationsNamespace);
        System.AppDomain.CurrentDomain.SetData(cacheKey, cache);
    }
    private SpecificationsElements(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, SpecificationPath entitiesPath, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, EdmxElements edmxElements, SpecificationsElements.Type type, bool dal, bool service, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol, bool isInterface, ISolution solution, IProject entitiesProject, List<IDocument> entitiesDocuments, Dictionary<IDocument, Compilation> specificationDocuments)
    {
        ServerFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
        Solution = solution;
        _classes = edmxElements.EntityTypes.Select(e => 
            {
                string name = edmxElements.Code.Escape(e);
                return new ClassNames { Name = name, FullName = string.Concat(entitiesNamespace, ".", name) };
            }).ToList();
        ServerFxSpecificationsNamespace = serverFxSpecificationsNamespace;
        GetMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ValidateMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ServiceMethods = new List<MethodDeclarationSyntax>();
        SubMethods = new List<MethodDeclarationSyntax>();
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        ExtensionMethods = new List<MethodDeclarationSyntax>();
        NonExtensionMethods = new List<MethodDeclarationSyntax>();
        NonEntitiesExtensionMethods = new List<MethodDeclarationSyntax>();
        ServiceProperties = new List<PropertySymbol>();
        SemanticModelPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>();
        MethodPerMethodSymbols = new ConcurrentDictionary<string, MethodDeclarationSyntax>();
        MethodSymbolPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>();
        CompilationUnitPerClass = new Dictionary<string, List<CompilationUnitSyntax>>();
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        Usings = new Dictionary<string, List<string>>();
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        InterfacesPerClasses = new Dictionary<string, List<NamedTypeSymbol>>();
        ClassesPerInterfaces = new Dictionary<string, List<string>>();
        ClassTypesPerInterfaces = new Dictionary<string, List<NamedTypeSymbol>>();
        TypeSymbols = new Dictionary<string, TypeSymbol>();
        Documents = new List<IDocument>();
        CompilationUnitSyntaxes = new List<CompilationUnitSyntax>();
        SemanticModelPerCompilationUnits = new Dictionary<CompilationUnitSyntax, ISemanticModel>();
        if (entitiesDocuments == null)
            Methods = new List<MethodDeclarationSyntax>();
        else
        {
            AllServiceMethods = new List<MethodDeclarationSyntax>();
            foreach (var document in entitiesDocuments)
            {
                var documentTree = GetSyntaxTree(document);
                var compilation = GetCompilation(entitiesProject);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                foreach (var classDeclaration in new ClassesVisitor().Visit(compilationUnit))
                {
                    string className = classDeclaration.Identifier.ValueText;
                    if (edmxElements.EdmTypes.Any(e => edmxElements.Code.Escape(e) == className) && !InterfacesPerClasses.ContainsKey(className))
                    {
                        var typeSymbol = (TypeSymbol)semanticModel.GetDeclaredSymbol(classDeclaration);
                        if (! TypeSymbols.ContainsKey(typeSymbol.Name))
                            TypeSymbols.Add(typeSymbol.Name, typeSymbol);
                        var interfaces = typeSymbol.Interfaces.ToList();
                        InterfacesPerClasses.Add(className, interfaces);
                        foreach (var @interface in interfaces)
                        {
                            List<string> classes;
                            string interfaceName = @interface.ToString();
                            if (! ClassesPerInterfaces.TryGetValue(interfaceName, out classes))
                                ClassesPerInterfaces.Add(interfaceName, classes = new List<string>());
                            if (! classes.Contains(className))
                                classes.Add(className);

                            List<NamedTypeSymbol> classTypes;
                            if (! ClassTypesPerInterfaces.TryGetValue(interfaceName, out classTypes))
                                ClassTypesPerInterfaces.Add(interfaceName, @classTypes = new List<NamedTypeSymbol>());
                            var classType = (NamedTypeSymbol)semanticModel.GetDeclaredSymbol(classDeclaration);
                            if (! classTypes.Contains(classType))
                                classTypes.Add(classType);
                        }
                    }
                }
            }
            SpecificationsNamespaces = new List<string>();
            SpecificationsTypes = new List<TypeSymbol>();
            var definePropertyDependencesMethods = new List<MethodDeclarationSyntax>();
            foreach (var specificationDocument in specificationDocuments)
            {
                var compilation = specificationDocument.Value;
                var document = specificationDocument.Key;
                var documentTree = GetSyntaxTree(document);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                Documents.Add(document);
                CompilationUnitSyntaxes.Add(compilationUnit);
                SemanticModelPerCompilationUnits.Add(compilationUnit, semanticModel);
                var specificationVisitor = new EntitiesSpecificationVisitor(this, semanticModel, edmxElements, entitiesNamespace);
                specificationVisitor.Visit(compilationUnit);
                foreach (var specificationGetMethodsPerClass in specificationVisitor.GetMethods)
                {
                    foreach (var method in specificationGetMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationGetMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationGetMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    if (! compilationUnits.Contains(compilationUnit))
                        compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (GetMethods.TryGetValue(specificationGetMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationGetMethodsPerClass.Value);
                    else
                        GetMethods.Add(specificationGetMethodsPerClass.Key, specificationGetMethodsPerClass.Value);
                }
                foreach (var specificationValidateMethodsPerClass in specificationVisitor.ValidateMethods)
                {
                    foreach (var method in specificationValidateMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationValidateMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationValidateMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    if (! compilationUnits.Contains(compilationUnit))
                        compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (ValidateMethods.TryGetValue(specificationValidateMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationValidateMethodsPerClass.Value);
                    else
                        ValidateMethods.Add(specificationValidateMethodsPerClass.Key, specificationValidateMethodsPerClass.Value);
                }
                foreach (var waqsMetadata in specificationVisitor.WAQSMetadata)
                {
                    List<WAQSMetadata> metadata;
                    if (Metadata.TryGetValue(waqsMetadata.Key, out metadata))
                        metadata.AddRange(waqsMetadata.Value);
                    else
                        Metadata.Add(waqsMetadata.Key, waqsMetadata.Value);
                    foreach (var m in waqsMetadata.Value)
                        SemanticModelPerMetadata.Add(m, semanticModel);
                }
                foreach (var method in specificationVisitor.ServiceMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionTypeName = methodSymbol.Parameters[0].Type.Name;
                        if (edmxElements.EdmTypes.Any(et => edmxElements.Code.Escape(et) == extensionTypeName))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionTypeName, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionTypeName, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                        else
                        {
                            List<string> classes;
                            if (ClassesPerInterfaces.TryGetValue(extensionTypeName, out classes))
                                foreach (var className in classes)
                                {
                                    if (! CompilationUnitPerClass.TryGetValue(className, out compilationUnits))
                                        CompilationUnitPerClass.Add(className, compilationUnits = new List<CompilationUnitSyntax>());
                                    if (! compilationUnits.Contains(compilationUnit))
                                        compilationUnits.Add(compilationUnit);
                                }
                            else if (methodSymbol.Parameters.Any() && ! (edmxElements.EdmTypes.Any(et => methodSymbol.Parameters[0].Type.ToString() == string.Concat(entitiesNamespace, ".", edmxElements.Code.Escape(et)) || ClassesPerInterfaces.Keys.Contains(methodSymbol.Parameters[0].Type.ToString()))))
                                NonEntitiesExtensionMethods.Add(method);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    ServiceMethods.Add(method);
                }
                foreach (var method in specificationVisitor.SubMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionTypeName = methodSymbol.Parameters[0].Type.Name;
                        if (edmxElements.EdmTypes.Any(et => edmxElements.Code.Escape(et) == extensionTypeName))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionTypeName, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionTypeName, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                        else
                        {
                            List<string> classes;
                            if (ClassesPerInterfaces.TryGetValue(methodSymbol.Parameters[0].Type.ToString(), out classes))
                                foreach (var className in classes)
                                {
                                    if (! CompilationUnitPerClass.TryGetValue(className, out compilationUnits))
                                        CompilationUnitPerClass.Add(className, compilationUnits = new List<CompilationUnitSyntax>());
                                    if (! compilationUnits.Contains(compilationUnit))
                                        compilationUnits.Add(compilationUnit);
                                }
                            else
                                NonEntitiesExtensionMethods.Add(method);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    SubMethods.Add(method);
                }
                foreach (var definePropertyDependencesMethod in specificationVisitor.DefinePropertyDependencesMethods)
                {
                    definePropertyDependencesMethods.Add(definePropertyDependencesMethod);
                    SemanticModelPerMethods.TryAdd(definePropertyDependencesMethod, semanticModel);
                }
                foreach (var property in specificationVisitor.ServiceProperties)
                    ServiceProperties.Add((PropertySymbol)semanticModel.GetDeclaredSymbol(property));
            }

            Methods = GetMethods.SelectMany(ms => ms.Value).Union(ServiceMethods).Union(SubMethods).Union(ValidateMethods.SelectMany(ms => ms.Value)).ToList();
            foreach (var m in Methods)
            {
                if (m.ParameterList.Parameters.Any())
                {
                    var definePropertyDependencesMethod = definePropertyDependencesMethods.FirstOrDefault(m2 => m2.Identifier.ValueText == string.Concat("Define", m.Identifier.ValueText, "PropertyDependences"));
                    if (definePropertyDependencesMethod == null)
                    {
                        var semanticModel = SemanticModelPerMethods[m];
                        var methodSymbol = MethodSymbolPerMethods[m];
                        GetMembersVisitor.Reset();
                        if (HasContextOrServiceAsParameter(methodSymbol))
                        {
                            MethodsDependentProperties.Add(m, null);
                            MethodsDependentPropertiesLast.Add(m, null);
                        }
                        else
                        {
                            var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                            membersVisitor.Visit(m.Body);
                            {
                                MethodsDependentProperties.Add(m, membersVisitor.GetProperties());
                                MethodsDependentPropertiesLast.Add(m, membersVisitor.GetReturnProperties());
                            }
                        }
                    }
                    else
                    {
                        var semanticModel = SemanticModelPerMethods[definePropertyDependencesMethod];
                        var definePropertyDependencesMethodVisitor = new DefinePropertyDependencesMethodVisitor(this, semanticModel);
                        definePropertyDependencesMethodVisitor.Visit(definePropertyDependencesMethod);
                        MethodsDependentProperties.Add(m, definePropertyDependencesMethodVisitor.Properties);
                    }
                }
                else
                {
                    MethodsDependentProperties.Add(m, new List<List<PropertySymbolInfo>>());
                    MethodsDependentPropertiesLast.Add(m, new List<List<PropertySymbolInfo>>());
                }
            }
        }
        AllServiceMethods = ServiceMethods.Union(ValidateMethods.SelectMany(kvp => kvp.Value).Where(m => IsExposedAsService(m))).ToList();
        foreach (var metadata in Metadata.SelectMany(kvp => kvp.Value))
            if (metadata.LambdaExpression != null)
            {
                var semanticModel = SemanticModelPerMetadata[metadata];
                var methodSymbol = (MethodSymbol)semanticModel.GetSymbolInfo(metadata.LambdaExpression).Symbol;
                GetMembersVisitor.Reset();
                var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                membersVisitor.Visit(metadata.LambdaExpression.Body);
                metadata.DependentProperties = membersVisitor.GetProperties().Where(d => d[0].Name != metadata.Property).ToList();
            }
            else
                metadata.DependentProperties = new List<List<PropertySymbolInfo>>();
        foreach (var metadata in from m in Metadata.SelectMany(kvp => kvp.Value)
                                 group m by new { PropertyContainingTypeName = m.PropertySymbol.ContainingType.ToString(), m.Property, m.MethodName } into g
                                 where g.Skip(1).Any()
                                 from m2 in g
                                 let minDepth = g.Where(m3 => TypeSymbolHelper.IsInherited(m3.TypeSymbol, m2.TypeSymbol)).Min(m => TypeSymbolHelper.GetTypeInheritanceDepth(m.TypeSymbol))
                                 where TypeSymbolHelper.GetTypeInheritanceDepth(m2.TypeSymbol) != minDepth
                                 select m2)
        metadata.IsOverriden = true;
        Init(type, dal, service, isInterface, entitiesNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
    }

    private void Init(SpecificationsElements.Type type, bool dal, bool service, bool isInterface, string entitiesNamespace, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol)
    {
        Usings = new Dictionary<string, List<string>>();
        foreach (var compilationUnit in CompilationUnitSyntaxes)
            new UsingVisitor(SemanticModelPerCompilationUnits[compilationUnit], this, ServerFxSpecificationsNamespace, ServerFxDALInterfacesNamespace, ServerFxServiceInterfacesNamespace, entitiesNamespace, type, SpecificationsNamespaces, m =>
            {
                ISemanticModel sm;
                if (SemanticModelPerMethods.TryGetValue(m, out sm))
                {
                    switch (type)
                    {
                        case Type.UnitTest:
                        case Type.Server: 
                            return isInterface ? MethodAnalizing.Signature : MethodAnalizing.Method;
                        case Type.Client:
                            if (IsApplicableOnClient(m))
                                return MethodAnalizing.Method;
                            if (m.Modifiers.Any(mo => GetKind(mo) == SyntaxKind.PublicKeyword))
                                return MethodAnalizing.Signature;
                            return MethodAnalizing.None;
                    }
                }
                return MethodAnalizing.Signature;
            }, Usings, dal, service, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol).Visit(compilationUnit);

        InterfaceSpecifications = new List<NamedTypeSymbol>();
        InterfaceExtensionMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        foreach (var @interface in InterfacesPerClasses.SelectMany(ipc => ipc.Value.Where(i => ! i.GetAttributes().Any(a => a.ToString() == ServerFxSpecificationsNamespace + ".IEntityAttribute"))).GroupBy(i => i.ToString()))
        {
            var extensionMethods = ExtensionMethods.Where(m => MethodSymbolPerMethods[m].Parameters[0].Type.ToString () == @interface.Key).ToList();
            if (extensionMethods.Any())
            {
                InterfaceSpecifications.Add(@interface.First());
                InterfaceExtensionMethods.Add(@interface.Key, type == Type.Client ? extensionMethods.Where(m => IsApplicableOnClient(m)).ToList() : extensionMethods);
            }
        }
    }

    public static SpecificationsElements Get(ITextTemplatingEngineHost host, SpecificationPath[] dtoPathes, SpecificationPath[] specificationPathes, IEnumerable<TypeSymbol> dtoTypes, string dtoNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, SpecificationsElements.Type type, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null)
    {
        var sb = new StringBuilder();
        var lastWriteTime = DateTime.MinValue;
        foreach (var dtoPath in dtoPathes)
        {
            var dtoPathFolder = Path.GetFullPath(host.ResolvePath(dtoPath.Folder));
            sb.Append(dtoPathFolder);
            foreach (var file in Directory.GetFiles(dtoPathFolder).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        foreach (var specificationPath in specificationPathes)
        {
            var specificationPathFolder = Path.GetFullPath(host.ResolvePath(specificationPath.Folder));
            sb.Append(specificationPathFolder);
            foreach (var file in Directory.GetFiles(specificationPathFolder).Where(f => f.EndsWith(".cs")))
            {
                sb.Append(file);
                var lastWriteTimeLoop = new FileInfo(file).LastWriteTime;
                if (lastWriteTimeLoop > lastWriteTime)
                    lastWriteTime = lastWriteTimeLoop;
            }
        }
        string cacheKey = sb.ToString();
        var cache = System.AppDomain.CurrentDomain.GetData(cacheKey) as Dictionary<string, object>;
        SpecificationsElements value;
        if (cache != null && (DateTime)cache["LastWriteTime"] == lastWriteTime)
        {
            value = new SpecificationsElements(cache);
            value.SetUsings(type, dtoNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            return value;
        }
        var specificationDocuments = new Dictionary<IDocument, Compilation>();
        ISolution solution = null;
        foreach (var specificationPath in specificationPathes)
        {
            var specificationSlnFilePath = specificationPath.Sln;
            solution = LoadSolution(Path.GetFullPath(host.ResolvePath(specificationSlnFilePath)), host);
            var specificationProjectPath = Path.GetFullPath(host.ResolvePath(specificationPath.Csproj));
            var project = solution.Projects.FirstOrDefault(p => Path.GetFullPath(p.FilePath) == specificationProjectPath);
            var specificationFolderPath = specificationPath.Folder;
            specificationFolderPath = Path.GetFullPath(host.ResolvePath(specificationFolderPath));
            var compilation = GetCompilation(project);
            foreach (var document in project.Documents.Where(d => Path.GetFullPath(d.FilePath).StartsWith(specificationFolderPath) && ! Path.GetFullPath(d.FilePath).EndsWith(".Designer.cs")))
                specificationDocuments.Add(document, compilation);
        }
        value = new SpecificationsElements(host, specificationPathes, dtoTypes, dtoNamespace, serverFxSpecificationsNamespace, serverFxDALInterfacesNamespace, serverFxServiceInterfacesNamespace, type, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol, solution, specificationDocuments);
        Cache(cacheKey, value, lastWriteTime);
        return value;
    }
    private SpecificationsElements(ITextTemplatingEngineHost host, SpecificationPath[] specificationPathes, IEnumerable<TypeSymbol> dtoTypes, string dtoNamespace, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, SpecificationsElements.Type type, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol, ISolution solution, Dictionary<IDocument, Compilation> specificationDocuments)
    {
        ServerFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
        Solution = solution;
        _classes = dtoTypes.Select(dto => new ClassNames { Name = dto.Name, FullName = dto.ToString() }).ToList();
        ServerFxSpecificationsNamespace = serverFxSpecificationsNamespace;
        GetMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ValidateMethods = new Dictionary<string, List<MethodDeclarationSyntax>>();
        ServiceMethods = new List<MethodDeclarationSyntax>();
        SubMethods = new List<MethodDeclarationSyntax>();
        Metadata = new Dictionary<string, List<WAQSMetadata>>();
        ExtensionMethods = new List<MethodDeclarationSyntax>();
        NonExtensionMethods = new List<MethodDeclarationSyntax>();
        ServiceProperties = new List<PropertySymbol>();
        SemanticModelPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel>();
        MethodPerMethodSymbols = new ConcurrentDictionary<string, MethodDeclarationSyntax>();
        MethodSymbolPerMethods = new ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol>();
        CompilationUnitPerClass = new Dictionary<string, List<CompilationUnitSyntax>>();
        SemanticModelPerMetadata = new Dictionary<WAQSMetadata, ISemanticModel>();
        Usings = new Dictionary<string, List<string>>();
        MethodsDependentProperties = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        MethodsDependentPropertiesLast = new Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>>();
        InterfacesPerClasses = new Dictionary<string, List<NamedTypeSymbol>>();
        ClassesPerInterfaces = new Dictionary<string, List<string>>();
        ClassTypesPerInterfaces = new Dictionary<string, List<NamedTypeSymbol>>();
        TypeSymbols = new Dictionary<string, TypeSymbol>();
        Documents = new List<IDocument>();
        CompilationUnitSyntaxes = new List<CompilationUnitSyntax>();
        SemanticModelPerCompilationUnits = new Dictionary<CompilationUnitSyntax, ISemanticModel>();
        SpecificationsNamespaces = new List<string>();
        SpecificationsTypes = new List<TypeSymbol>();
        if (specificationDocuments.Count != 0)
        {
            foreach (var specificationDocument in specificationDocuments)
            {
                var document = specificationDocument.Key;
                var compilation = specificationDocument.Value;
                var documentTree = GetSyntaxTree(document);
                var compilationUnit = (CompilationUnitSyntax)documentTree.GetRoot();
                var semanticModel = compilation.GetSemanticModel(documentTree);
                Documents.Add(document);
                CompilationUnitSyntaxes.Add(compilationUnit);
                SemanticModelPerCompilationUnits.Add(compilationUnit, semanticModel);
                var specificationVisitor = new DTOSpecificationVisitor(this, semanticModel, dtoTypes, dtoNamespace);
                specificationVisitor.Visit(compilationUnit);
                foreach (var specificationGetMethodsPerClass in specificationVisitor.GetMethods)
                {
                    foreach (var method in specificationGetMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationGetMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationGetMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (GetMethods.TryGetValue(specificationGetMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationGetMethodsPerClass.Value);
                    else
                        GetMethods.Add(specificationGetMethodsPerClass.Key, specificationGetMethodsPerClass.Value);
                }
                foreach (var specificationValidateMethodsPerClass in specificationVisitor.ValidateMethods)
                {
                    foreach (var method in specificationValidateMethodsPerClass.Value)
                    {
                        ExtensionMethods.Add(method);
                        GetAndAddMethodSymbol(method, semanticModel);
                    }
                    List<CompilationUnitSyntax> compilationUnits;
                    if (! CompilationUnitPerClass.TryGetValue(specificationValidateMethodsPerClass.Key, out compilationUnits))
                        CompilationUnitPerClass.Add(specificationValidateMethodsPerClass.Key, compilationUnits = new List<CompilationUnitSyntax>());
                    compilationUnits.Add(compilationUnit);

                    List<MethodDeclarationSyntax> methods;
                    if (ValidateMethods.TryGetValue(specificationValidateMethodsPerClass.Key, out methods))
                        methods.AddRange(specificationValidateMethodsPerClass.Value);
                    else
                        ValidateMethods.Add(specificationValidateMethodsPerClass.Key, specificationValidateMethodsPerClass.Value);
                }
                foreach (var method in specificationVisitor.ServiceMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionType = methodSymbol.Parameters[0].Type;
                        if (dtoTypes.Any(t => t.ToString() == extensionType.ToString()))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionType.Name, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionType.Name, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    ServiceMethods.Add(method);
                }
                foreach (var method in specificationVisitor.SubMethods)
                {
                    var methodSymbol = GetAndAddMethodSymbol(method, semanticModel);
                    if (methodSymbol.IsExtensionMethod)
                    {
                        ExtensionMethods.Add(method);
                        List<CompilationUnitSyntax> compilationUnits;
                        var extensionType = methodSymbol.Parameters[0].Type;
                        if (dtoTypes.Any(t => t.ToString() == extensionType.ToString()))
                        {
                            if (! CompilationUnitPerClass.TryGetValue(extensionType.Name, out compilationUnits))
                                CompilationUnitPerClass.Add(extensionType.Name, compilationUnits = new List<CompilationUnitSyntax>());
                            if (! compilationUnits.Contains(compilationUnit))
                                compilationUnits.Add(compilationUnit);
                        }
                    }
                    else
                        NonExtensionMethods.Add(method);
                    SubMethods.Add(method);
                }
                SetUsings(type, dtoNamespace, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            }
            Methods = GetMethods.SelectMany(ms => ms.Value).Union(ServiceMethods).Union(SubMethods).Union(ValidateMethods.SelectMany(ms => ms.Value)).ToList();
            foreach (var m in Methods)
            {
                if (m.ParameterList.Parameters.Count == 0)
                {
                    MethodsDependentProperties.Add(m, new List<List<PropertySymbolInfo>>());
                    MethodsDependentPropertiesLast.Add(m, new List<List<PropertySymbolInfo>>());
                }
                else
                {
                    var semanticModel = SemanticModelPerMethods[m];
                    var methodSymbol = MethodSymbolPerMethods[m];
                    var membersVisitor = new GetMembersVisitor(semanticModel, this, methodSymbol, methodSymbol.Parameters[0].Name, serverFxDALInterfacesNamespace, SemanticModelPerMethods, MethodPerMethodSymbols, GetMethods, ExtensionMethods);
                    membersVisitor.Visit(m.Body);
                    MethodsDependentProperties.Add(m, membersVisitor.GetProperties());
                    MethodsDependentPropertiesLast.Add(m, membersVisitor.GetReturnProperties());
                }
            }
        }
        else
            Methods = new List<MethodDeclarationSyntax>();
        AllServiceMethods = ServiceMethods.Union(ValidateMethods.SelectMany(kvp => kvp.Value).Where(m => IsExposedAsService(m))).ToList();
    }

    private void SetUsings(SpecificationsElements.Type type, string dtoNamespace, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol)
    {
        foreach (var semanticModelPerCompilationUnits in SemanticModelPerCompilationUnits)
        {
            var usingVisitor = new UsingVisitor(semanticModelPerCompilationUnits.Value, this, ServerFxSpecificationsNamespace, ServerFxDALInterfacesNamespace, ServerFxServiceInterfacesNamespace, dtoNamespace, type, SpecificationsNamespaces, m => (type != SpecificationsElements.Type.UnitTest ? ! HasContextAsParameter(m) : IsApplicableOnClient(m)) ? MethodAnalizing.Method : MethodAnalizing.None, Usings, false, false, getNamespaceFromTypeSymbol, getNamespaceFromMethodSymbol);
            usingVisitor.Visit(semanticModelPerCompilationUnits.Key);
        }
    }

    private ConcurrentDictionary<TypeSyntax, TypeSymbol> _typeSymbolPerTypes = new ConcurrentDictionary<TypeSyntax, TypeSymbol>();
    public TypeSymbol GetTypeSymbol(TypeSyntax type, ISemanticModel semanticModel)
    {
        TypeSymbol value;
        if (_typeSymbolPerTypes.TryGetValue(type, out value))
            return value;
        value = semanticModel.GetSymbolInfo(type).Symbol as TypeSymbol;
        if (value != null)
            _typeSymbolPerTypes.TryAdd(type, value);
        return value;
    }

    public bool ReplaceInterface(ref TypeSyntax type, ISemanticModel semanticModel, string defaultEntity = null, bool withInterfaceSpecifications = false)
    {
        try
        {
            var symbol = GetTypeSymbol(type, semanticModel);
            if (symbol == null)
                return false;
            if (symbol.TypeKind == TypeKind.Interface)
            {
                List<string> classes;
                ClassesPerInterfaces.TryGetValue(symbol.ToString(), out classes);
                if (symbol.GetAttributes().Any(a => a.AttributeClass.ToString() == ServerFxSpecificationsNamespace + ".IEntityAttribute")) 
                {
                    if (classes != null && classes.Count == 1)
                    {
                        type = SyntaxFactory.ParseTypeName(classes[0]);
                        return true;
                    }
                    throw new InvalidOperationException();
                }
                if (withInterfaceSpecifications && InterfaceSpecifications != null && InterfaceSpecifications.Any(i => i.ToString() == symbol.ToString()))
                {
                    type = SyntaxFactory.ParseTypeName(symbol.Name + "Specifications");
                    return true;
                }
                if (classes != null)
                {
                    if (classes.Count == 1)
                    {
                        type = SyntaxFactory.ParseTypeName(classes[0]);
                        return true;
                    }
                    if (defaultEntity != null && classes.Any(c => c == defaultEntity))
                    {
                        type = SyntaxFactory.ParseTypeName(defaultEntity);
                        return true;
                    }
                }
            }
            return false;
        }
        catch(Exception)
        {
            return false;
        }
    }
    
    public ISolution Solution { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> GetMethods { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> ValidateMethods { get; private set; }
    public List<MethodDeclarationSyntax> ServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> AllServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> SubMethods { get; private set; }
    public List<MethodDeclarationSyntax> Methods { get; private set; }
    public Dictionary<string, List<WAQSMetadata>> Metadata { get; private set; } 
    public List<MethodDeclarationSyntax> ExtensionMethods { get; private set; }
    public List<MethodDeclarationSyntax> NonExtensionMethods { get; private set; }
    public List<MethodDeclarationSyntax> NonEntitiesExtensionMethods { get; private set; }
    public List<PropertySymbol> ServiceProperties { get; private set; }
    public Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>> MethodsDependentProperties { get; private set; }
    public Dictionary<MethodDeclarationSyntax, List<List<PropertySymbolInfo>>> MethodsDependentPropertiesLast { get; private set; }
    public ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> SemanticModelPerMethods { get; private set; }
    public ConcurrentDictionary<string, MethodDeclarationSyntax> MethodPerMethodSymbols { get; private set; }
    public ConcurrentDictionary<MethodDeclarationSyntax, MethodSymbol> MethodSymbolPerMethods { get; private set; }
    public Dictionary<string, List<CompilationUnitSyntax>> CompilationUnitPerClass { get; private set; }
    public Dictionary<WAQSMetadata, ISemanticModel> SemanticModelPerMetadata { get; private set; }
    public Dictionary<string, List<string>> Usings { get; private set; }
    public Dictionary<string, List<NamedTypeSymbol>> InterfacesPerClasses { get; private set; }
    public Dictionary<string, List<string>> ClassesPerInterfaces { get; private set; }
    public Dictionary<string, List<NamedTypeSymbol>> ClassTypesPerInterfaces { get; private set; }
    public Dictionary<string, TypeSymbol> TypeSymbols { get; private set; }
    public List<IDocument> Documents { get; private set; }
    public List<CompilationUnitSyntax> CompilationUnitSyntaxes { get; private set; }
    public Dictionary<CompilationUnitSyntax, ISemanticModel> SemanticModelPerCompilationUnits { get; private set; }
    public List<string> SpecificationsNamespaces { get; private set; }
    public List<TypeSymbol> SpecificationsTypes { get; private set; }
    public List<NamedTypeSymbol> InterfaceSpecifications { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> InterfaceExtensionMethods { get; private set; }

    public MethodSymbol GetAndAddMethodSymbol(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        MethodSymbol methodSymbol;
        if (MethodSymbolPerMethods.TryGetValue(method, out methodSymbol))
            return methodSymbol;
        methodSymbol = (MethodSymbol)semanticModel.GetDeclaredSymbol(method);
        SemanticModelPerMethods.TryAdd(method, semanticModel);
        MethodPerMethodSymbols.TryAdd(methodSymbol.ToString(), method);
        MethodSymbolPerMethods.TryAdd(method, methodSymbol);
        return methodSymbol;
    }

    public IEnumerable<MethodDeclarationSyntax> AllMethods
    {
        get { return ExtensionMethods.Union(NonExtensionMethods); }
    }

    private List<string> _servicePropertiesStrings;
    public List<string> ServicePropertiesStrings 
    { 
        get { return _servicePropertiesStrings ?? (_servicePropertiesStrings = ServiceProperties.Select(sp => sp.ToString()).ToList()); }
    }

    private List<ClassNames> _classes;

    private object _extensionMethodsPerTypesLock = new object();
    private Dictionary<string, List<MethodDeclarationSyntax>> _extensionMethodsPerTypes;
    public Dictionary<string, List<MethodDeclarationSyntax>> ExtensionMethodsPerTypes
    {
        get
        {
            if (_extensionMethodsPerTypes == null)
                lock(_extensionMethodsPerTypesLock)
                {
                    if (_extensionMethodsPerTypes == null)
                    {
                        _extensionMethodsPerTypes = new Dictionary<string, List<MethodDeclarationSyntax>>();
                        foreach (var m in ExtensionMethods)
                        {
                            var methodSymbol = MethodSymbolPerMethods[m];
                            var extensionType = methodSymbol.Parameters[0].Type;
                            var className = new ClassNames { Name = extensionType.Name, FullName = extensionType.ToString() }; // pas si contexte ou service
                            IEnumerable<ClassNames> classesNames;
                            List<NamedTypeSymbol> classes;
                            if (ClassTypesPerInterfaces.TryGetValue(className.FullName, out classes))
                                classesNames = classes.Select(c => new ClassNames { Name = c.Name, FullName = c.ToString() });
                            else
                                classesNames = new ClassNames[] { className };
                            foreach (var @class in classesNames.Intersect(_classes))
                            {
                                List<MethodDeclarationSyntax> methods;
                                if (! _extensionMethodsPerTypes.TryGetValue(@class.Name, out methods))
                                    _extensionMethodsPerTypes.Add(@class.Name, methods = new List<MethodDeclarationSyntax>());
                                methods.Add(m);
                            }                    
                        }
                    }
                }
            return _extensionMethodsPerTypes;
        }
    }

    private object _nonValidationExtensionMethodsPerTypesLock = new object();
    private Dictionary<string, List<MethodDeclarationSyntax>> _nonValidationExtensionMethodsPerTypes;
    public Dictionary<string, List<MethodDeclarationSyntax>> NonValidationExtensionMethodsPerTypes
    {
        get
        {
            if (_nonValidationExtensionMethodsPerTypes == null)
                lock(_nonValidationExtensionMethodsPerTypesLock)
                {
                    if (_nonValidationExtensionMethodsPerTypes == null)
                        _nonValidationExtensionMethodsPerTypes = ExtensionMethodsPerTypes.ToDictionary(ems => ems.Key, ems => 
                        {
                            List<MethodDeclarationSyntax> validateMethods;
                            if (ValidateMethods.TryGetValue(ems.Key, out validateMethods))
                                return ems.Value.Except(validateMethods).ToList();
                            return ems.Value;
                        });
                }
            return _nonValidationExtensionMethodsPerTypes;
        }
    }

    private object _getMethodSymbolsLock = new object();
    private HashSet<MethodSymbol> _getMethodSymbols;
    public HashSet<MethodSymbol> GetMethodsSymbols
    {
        get 
        {
            if (_getMethodSymbols == null)
                lock(_getMethodSymbolsLock)
                {
                    if (_getMethodSymbols == null)
                        _getMethodSymbols = new HashSet<MethodSymbol>(GetMethods.SelectMany(m => m.Value).Select(m => MethodSymbolPerMethods[m]));
                }
            return _getMethodSymbols;
        }
    }

    private object _allValidateMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _allValidateMethods;
    public HashSet<MethodDeclarationSyntax> AllValidateMethods
    {
        get 
        {
            if (_allValidateMethods == null)
                lock(_allValidateMethodsLock)
                {
                    if (_allValidateMethods == null)
                        _allValidateMethods = new HashSet<MethodDeclarationSyntax>(ValidateMethods.SelectMany(v => v.Value));
                }
            return _allValidateMethods;
        }
    }

    private object _abstractMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _abstractMethods;
    public HashSet<MethodDeclarationSyntax> AbstractMethods
    {
        get 
        {
            if (_abstractMethods == null)
                lock(_abstractMethodsLock)
                {
                    if (_abstractMethods == null)
                        _abstractMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "AbstractAttribute")));
                }
            return _abstractMethods;
        }
    }

    private object _virtualMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _virtualMethods;
    public HashSet<MethodDeclarationSyntax> VirtualMethods
    {
        get 
        {
            if (_virtualMethods == null)
                lock(_virtualMethodsLock)
                {
                    if (_virtualMethods == null)
                        _virtualMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "VirtualAttribute")));
                }
            return _virtualMethods;
        }
    }

    private object _overrideMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _overrideMethods;
    public HashSet<MethodDeclarationSyntax> OverrideMethods
    {
        get 
        {
            if (_overrideMethods == null)
                lock(_overrideMethodsLock)
                {
                    if (_overrideMethods == null)
                        _overrideMethods = new HashSet<MethodDeclarationSyntax>(ExtensionMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "OverrideAttribute")));
                }
            return _overrideMethods;
        }
    }

    private object _customMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _customMethods;
    public HashSet<MethodDeclarationSyntax> CustomMethods
    {
        get 
        {
            if (_customMethods == null)
                lock(_customMethodsLock)
                {
                    if (_customMethods == null)
                        _customMethods = new HashSet<MethodDeclarationSyntax>(AllMethods.Where(m => m.AttributeLists.SelectMany(a => a.Attributes).Any(a => SemanticModelPerMethods[m].GetSymbolInfo(a).Symbol.ContainingType.Name == "CustomAttribute")));
                }
            return _customMethods;
        }
    }

    private object _validateFuncMethodsLock = new object();
    private HashSet<MethodDeclarationSyntax> _validateFuncMethods;
    public HashSet<MethodDeclarationSyntax> ValidateFuncMethods
    {
        get 
        {
            if (_validateFuncMethods == null)
                lock(_validateFuncMethodsLock)
                {
                    if (_validateFuncMethods == null)
                        _validateFuncMethods = new HashSet<MethodDeclarationSyntax>(AllValidateMethods.Where(m => 
                            {
                                NamedTypeSymbol returnTypeAsNamedTypeSymbol;
                                return (returnTypeAsNamedTypeSymbol = MethodSymbolPerMethods[m].ReturnType as NamedTypeSymbol) != null && returnTypeAsNamedTypeSymbol.ConstructedFrom.ToString() == "System.Func<TResult>";
                            }));
                }
            return _validateFuncMethods;
        }
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _useServiceProperty = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool UseServiceProperty(MethodDeclarationSyntax method)
    {
        bool value;
        if (_useServiceProperty.TryGetValue(method, out value))
            return value;
        value = UseServicePropertyVisitor.UseServiceProperty(method, this);
        _useServiceProperty.TryAdd(method, value);
        return value;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isApplicableOnClient = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsApplicableOnClient(MethodDeclarationSyntax method)
    {
        bool value;
        if (_isApplicableOnClient.TryGetValue(method, out value))
            return value;
        var semanticModel = SemanticModelPerMethods[method];
        var methodSymbol = MethodSymbolPerMethods[method];
        var unfoundMethods = new List<MethodSymbol>();
        value = ! (IsMarkedAsNotApplicableOnClient(methodSymbol) || ! IsValidatedOnClient(method) && IsValidatedOnServer(method) || UseServiceProperty(method))/* && GetCalledMethods(method, semanticModel, out unfoundMethods).Where(m => ! m.Equals(method)).All(m => IsApplicableOnClient(m)) && ! unfoundMethods.Any(m => IsMarkedAsNotApplicableOnClient(m))*/;
        _isApplicableOnClient.TryAdd(method, value);
        return value;
    }

    private bool IsMarkedAsNotApplicableOnClient(MethodSymbol methodSymbol)
    {
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "NotApplicableOnClientAttribute") || HasContextOrServiceAsParameter(methodSymbol);
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isExposedAsService = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsExposedAsService(MethodDeclarationSyntax method)
    {
        bool isExposedAsService;
        if (_isExposedAsService.TryGetValue(method, out isExposedAsService))
            return isExposedAsService;
        var methodSymbol = MethodSymbolPerMethods[method];
        isExposedAsService =  methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ExposeAsServiceAttribute");
        _isExposedAsService.TryAdd(method, isExposedAsService);
        return isExposedAsService;
    }

    private bool IsValidatedOnServer(MethodDeclarationSyntax method)
    {
        if (IsValidateFunc(method))
            return true;
        var semanticModel = SemanticModelPerMethods[method];
        return (HasValidateOnServerAttribute(method)/* || GetCalledMethods(method).Where(m => ! m.Equals(method)).Any(m => ! IsApplicableOnClient(m))*/ || IsExposedAsService(method));
    }

    private bool IsValidatedOnClient(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ValidateOnClientAttribute") || ! IsValidatedOnServer(method);
    }

    public bool IsValidateFunc(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        NamedTypeSymbol returnTypeAsNamedTypeSymbol;
        return (returnTypeAsNamedTypeSymbol = methodSymbol.ReturnType as NamedTypeSymbol) != null && returnTypeAsNamedTypeSymbol.ConstructedFrom.ToString() == "System.Func<TResult>";
    }

    private bool HasValidateOnServerAttribute(MethodDeclarationSyntax method)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Name == "ValidateOnServerAttribute");
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isDefineMethod = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsDefineMethod(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isDefineMethod;
        if (_isDefineMethod.TryGetValue(method, out isDefineMethod))
            return isDefineMethod;
        isDefineMethod = IsDefineMethod(GetAndAddMethodSymbol(method, semanticModel));
        _isDefineMethod.TryAdd(method, isDefineMethod);
        return isDefineMethod;
    }
    public bool IsDefineMethod(MethodDeclarationSyntax method, MethodSymbol methodSymbol, ISemanticModel semanticModel)
    {
        bool isDefineMethod;
        if (_isDefineMethod.TryGetValue(method, out isDefineMethod))
            return isDefineMethod;
        isDefineMethod = IsDefineMethod(methodSymbol);
        _isDefineMethod.TryAdd(method, isDefineMethod);
        return isDefineMethod;
    }
    private bool IsDefineMethod(MethodSymbol method)
    {
        return method.IsStatic && method.ReturnsVoid && ! method.Parameters.Any() && Regex.IsMatch(method.Name, "^Define[A-Z]");
    }

    public bool IsGetMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsGetMethod(node, edmxElements, semanticModel, entitiesNamespace, out edmTypeName);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsGetMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName);
    }
    public bool IsGetMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsGetMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>> _isGetMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>();
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isGetMethod;
        if (_isGetMethod.TryGetValue(key, out isGetMethod))
        {
            edmTypeName = isGetMethod.Item1;
            return isGetMethod.Item2;
        }
        var value = IsGetMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
        _isGetMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsGetMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsGetMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, "^Get[A-Z]", m => ! m.ReturnsVoid, className);
    }
    public bool IsGetMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsGetMethod(node, method, types, typesNamespace, out typeName, className);
    }
    private bool IsGetMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string typeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isGetMethod;
        if (_isGetMethod.TryGetValue(key, out isGetMethod))
        {
            typeName = isGetMethod.Item1;
            return isGetMethod.Item2;
        }
        bool value = IsGetMethod(method, types, typesNamespace, out typeName, className);
        _isGetMethod.TryAdd(key, new Tuple<string, bool>(typeName, value));
        return value;
    }
    private bool IsGetMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsGetMethod(method, types, typesNamespace, out typeName, className);
    }
    private bool IsGetMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string typeName, string className = null)
    {
        return IsGetOrValidateMethod(method, types, typesNamespace, out typeName, "^Get[A-Z]", m => ! m.ReturnsVoid, className);
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, string className = null)
    {
        return IsGetOrValidateMethod(method, out edmTypeName, pattern, additionalPredicate, () => IsSpecificationMethod(method, edmxElements, entitiesNamespace), methodParameterTypeName => 
            {
                string edmTypeNameValue = null;
                if (edmxElements.EdmTypes.Any(e => string.Concat(entitiesNamespace, ".", edmTypeNameValue = edmxElements.Code.Escape(e)) == methodParameterTypeName))
                    return edmTypeNameValue;
                return null;
            }, className);
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, string className = null)
    {
        return IsGetOrValidateMethod(method, out edmTypeName, pattern, additionalPredicate, () => IsSpecificationMethod(method, types, typesNamespace), methodParameterTypeName => 
            {
                var type = types.FirstOrDefault(t => t.ToString() == methodParameterTypeName);
                if (type == null)
                    return null;
                return type.Name;
            });
    }

    private bool IsGetOrValidateMethod(MethodSymbol method, out string edmTypeName, string pattern, Predicate<MethodSymbol> additionalPredicate, Func<bool> isSpecificationMethod, Func<string, string> getClassName, string className = null)
    {
        edmTypeName = null;
        var nonContextParameters = method.Parameters.OfType<ParameterSymbol>().Where(p => ! p.Type.AllInterfaces.Any(i => i.ToString() == ServerFxDALInterfacesNamespace + ".IDataContext"));
        var value = isSpecificationMethod() && Regex.IsMatch(method.Name, pattern) && additionalPredicate(method) && nonContextParameters.Count() == 1 && (className != null || (edmTypeName = getClassName(method.Parameters[0].Type.ToString())) != null) && method.IsExtensionMethod;
        return value;
    }

    private bool IsSpecificationMethod(MethodDeclarationSyntax node, ISemanticModel semanticModel, EdmxElements edmxElements, string entitiesNamespace)
    {
        return IsSpecificationMethod(GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace);
    }
    public bool IsSpecificationMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace)
    {
        return IsSpecificationMethod(method, methodClassName => edmxElements.EdmTypes.Any(e => string.Concat(entitiesNamespace, ".", edmxElements.Code.Escape(e)) == methodClassName));
    }
    public bool IsSpecificationMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace)
    {
        return IsSpecificationMethod(method, methodClassName => types.Any(t => string.Concat(typesNamespace, ".", t.Name) == methodClassName));
    }
    private bool IsSpecificationMethod(MethodSymbol method, Func<string, bool> isClassMethod)
    {
        if (method.DeclaredAccessibility != RoslynAccessibility.Public)
            return false;
        if (method.IsStatic)
            return true; 
        return isClassMethod(method.ContainingType.ToString());
    }

    public bool IsValidateMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsValidateMethod(node, edmxElements, semanticModel, entitiesNamespace, out edmTypeName);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace)
    {
        string edmTypeName;
        return IsValidateMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(node, method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>> _isValidateMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, Tuple<string, bool>>();
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isValidateMethod;
        if (_isValidateMethod.TryGetValue(key, out isValidateMethod))
        {
            edmTypeName = isValidateMethod.Item1;
            return isValidateMethod.Item2;
        }
        var value = IsValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
        _isValidateMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, edmxElements, entitiesNamespace, out edmTypeName, "^Validate[A-Z]", m => m.ReturnType.ToString() == ServerFxServiceInterfacesNamespace + ".Error" || m.ReturnType.ToString() == string.Concat("System.Func<", ServerFxServiceInterfacesNamespace, ".Error>"), className);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    public bool IsValidateMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsValidateMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string typeName;
        return IsValidateMethod(node, method, types, typesNamespace, out typeName, className);
    }
    private bool IsValidateMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        Tuple<string, bool> isValidateMethod;
        if (_isValidateMethod.TryGetValue(key, out isValidateMethod))
        {
            edmTypeName = isValidateMethod.Item1;
            return isValidateMethod.Item2;
        }
        var value = IsValidateMethod(method, types, typesNamespace, out edmTypeName, className = null);
        _isValidateMethod.TryAdd(key, new Tuple<string, bool>(edmTypeName, value));
        return value;
    }
    private bool IsValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        string edmTypeName;
        return IsValidateMethod(method, types, typesNamespace, out edmTypeName, className);
    }
    private bool IsValidateMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, out string edmTypeName, string className = null)
    {
        return IsGetOrValidateMethod(method, types, typesNamespace, out edmTypeName, "^Validate[A-Z]", m => m.ReturnType.ToString() == ServerFxServiceInterfacesNamespace + ".Error" || m.ReturnType.ToString() == string.Concat("System.Func<", ServerFxServiceInterfacesNamespace, ".Error>"), className);
    }

    public bool IsServiceMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, string className = null)
    {
        return IsServiceMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace, className);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isServiceMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    private bool IsServiceMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isServiceMethod;
        if (_isServiceMethod.TryGetValue(key, out isServiceMethod))
            return isServiceMethod;
        isServiceMethod = IsServiceMethod(method, edmxElements, entitiesNamespace, className);
        _isServiceMethod.TryAdd(key, isServiceMethod);
        return isServiceMethod;
    }
    private bool IsServiceMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        return IsSpecificationMethod(method, edmxElements, entitiesNamespace) && ! (IsGetMethod(method, edmxElements, entitiesNamespace, className) || IsValidateMethod(method, edmxElements, entitiesNamespace, className) || IsDefineMethod(method));
    }
    public bool IsServiceMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        return IsServiceMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, className);
    }
    private bool IsServiceMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isServiceMethod;
        if (_isServiceMethod.TryGetValue(key, out isServiceMethod))
            return isServiceMethod;
        isServiceMethod = IsServiceMethod(method, types, typesNamespace, className);
        _isServiceMethod.TryAdd(key, isServiceMethod);
        return isServiceMethod;
    }
    private bool IsServiceMethod(MethodSymbol method, IEnumerable<TypeSymbol> types, string typesNamespace, string className = null)
    {
        return IsSpecificationMethod(method, types, typesNamespace) && ! (IsGetMethod(method, types, typesNamespace, className) || IsValidateMethod(method, types, typesNamespace, className));
    }

    public bool IsSubMethod(MethodDeclarationSyntax node, EdmxElements edmxElements, ISemanticModel semanticModel, string entitiesNamespace, string className = null)
    {
        return IsSubMethod(node, GetAndAddMethodSymbol(node, semanticModel), edmxElements, entitiesNamespace);
    }
    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isSubMethod = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    private bool IsSubMethod(MethodDeclarationSyntax node, MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isSubMethod;
        if (_isSubMethod.TryGetValue(key, out isSubMethod))
            return isSubMethod;
        isSubMethod = IsSubMethod(method, edmxElements, entitiesNamespace, className);
        _isSubMethod.TryAdd(key, isSubMethod);
        return isSubMethod;
    }
    private bool IsSubMethod(MethodSymbol method, EdmxElements edmxElements, string entitiesNamespace, string className = null)
    {
        return ! IsSpecificationMethod(method, edmxElements, entitiesNamespace);
    }
    public bool IsSubMethod(MethodDeclarationSyntax node, IEnumerable<TypeSymbol> types, ISemanticModel semanticModel, string typesNamespace, string className = null)
    {
        return IsSubMethod(node, GetAndAddMethodSymbol(node, semanticModel), types, typesNamespace, className);
    }
    private bool IsSubMethod(MethodDeclarationSyntax node, MethodSymbol method, IEnumerable<TypeSymbol> edmTypes, string typesNamespace, string className = null)
    {
        var key = new Tuple<MethodDeclarationSyntax, bool>(node, className == null);
        bool isSubMethod;
        if (_isSubMethod.TryGetValue(key, out isSubMethod))
            return isSubMethod;
        isSubMethod = IsSubMethod(method, edmTypes, typesNamespace, className);
        _isSubMethod.TryAdd(key, isSubMethod);
        return isSubMethod;
    }
    private bool IsSubMethod(MethodSymbol method, IEnumerable<TypeSymbol> edmTypes, string typesNamespace, string className = null)
    {
        return ! (IsSpecificationMethod(method, edmTypes, typesNamespace) || IsDefineMethod(method));
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, List<MethodWithDepth>> _overridenMethods = new ConcurrentDictionary<MethodDeclarationSyntax, List<MethodWithDepth>>();
    public IEnumerable<MethodWithDepth> GetOverridenMethods(MethodDeclarationSyntax method)
    {
        return GetOverridenMethods(method, MethodSymbolPerMethods[method]);
    }
    public IEnumerable<MethodWithDepth> GetOverridenMethods(MethodDeclarationSyntax method, MethodSymbol methodSymbol)
    {
        List<MethodWithDepth> value;
        if (_overridenMethods.TryGetValue(method, out value))
            return value;
        value = new List<MethodWithDepth>();
        string methodSymbolFirstParameterTypeName = methodSymbol.Parameters[0].Type.ToString();
        foreach (var m in ExtensionMethods)
        {
            var mSemanticModel = SemanticModelPerMethods[m];
            MethodSymbol mSymbol;
            if (! (OverrideMethods.Contains(m) && methodSymbol.Name == (mSymbol = MethodSymbolPerMethods[m]).Name && methodSymbol.Parameters.OfType<ParameterSymbol>().Count() == mSymbol.Parameters.OfType<ParameterSymbol>().Count()))
                continue;
            var parameterType = mSymbol.Parameters[0].Type;
            bool ok = false;
            int depth = 1;
            while (parameterType.BaseType != null)
            {
                if (parameterType.ToString() == methodSymbolFirstParameterTypeName)
                {
                    ok = true;
                    break;
                }
                depth ++;
                parameterType = parameterType.BaseType;
            }
            if (! ok)
                continue;
            int parametersCount = methodSymbol.Parameters.OfType<ParameterSymbol>().Count(); 
            for (int i = 1 ; i < parametersCount ; i ++)
                if (mSymbol.Parameters[i].Type.ToString() != methodSymbol.Parameters[i].Type.ToString())
                    continue;
            value.Add(new MethodWithDepth { Method = mSymbol, Depth = depth });
        }
        _overridenMethods.TryAdd(method, value);
        return value;
    }

    public class MethodWithDepth
    {
        public static MethodWithDepth Get(Dictionary<string, object> cache)
        {
            return new MethodWithDepth { Method = (MethodSymbol)cache["Method"], Depth = (int)cache["Depth"] };
        }

        public Dictionary<string, object> ToCache()
        {
            return new Dictionary<string, object>() 
                {
                    { "Method", Method },
                    { "Depth", Depth }
                };
        }

        public MethodSymbol Method { get; set; }
        public int Depth { get; set; }
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnInsert = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnInsert(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnInsert;
        if (_isModeOnInsert.TryGetValue(method, out isModeOnInsert))
            return isModeOnInsert;
        isModeOnInsert = IsMode(method, semanticModel, "OnInsert");
        _isModeOnInsert.TryAdd(method, isModeOnInsert);
        return isModeOnInsert;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnUpdate = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnUpdate(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnUpdate;
        if (_isModeOnUpdate.TryGetValue(method, out isModeOnUpdate))
            return isModeOnUpdate;
        isModeOnUpdate = IsMode(method, semanticModel, "OnUpdate");
        _isModeOnUpdate.TryAdd(method, isModeOnUpdate);
        return isModeOnUpdate;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isModeOnDelete = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsModeOnDelete(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isModeOnDelete;
        if (_isModeOnDelete.TryGetValue(method, out isModeOnDelete))
            return isModeOnDelete;
        isModeOnDelete = IsMode(method, semanticModel, "OnDelete");
        _isModeOnDelete.TryAdd(method, isModeOnDelete);
        return isModeOnDelete;
    }

    private bool IsMode(MethodDeclarationSyntax method, ISemanticModel semanticModel, string mode)
    {
        return method.AttributeLists != null && method.AttributeLists.Any(al => al.Attributes.Any(a => a.ArgumentList != null && a.ArgumentList.Arguments.Any(ar => new PartialValidationMode(semanticModel, ServerFxSpecificationsNamespace, mode).Visit(ar))));
    }

    class PartialValidationMode : SyntaxVisitorOfBool
    {
        private ISemanticModel _semanticModel;
        private string _serverFxSpecificationsNamespace;
        private string _mode;

        public PartialValidationMode(ISemanticModel semanticModel, string serverFxSpecificationsNamespace, string mode)
        {
            _semanticModel = semanticModel;
            _serverFxSpecificationsNamespace = serverFxSpecificationsNamespace;
            _mode = mode;
        }

        public override bool Visit(SyntaxNode node)
        {
            return base.Visit(node) || node.ChildNodes().Any(c => Visit(c));
        }

        public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            var symbol = _semanticModel.GetSymbolInfo(node).Symbol;
            if (symbol != null && symbol.ToString() == string.Concat(_serverFxSpecificationsNamespace, ".ValidateMode.", _mode))
                return true;
            return base.VisitMemberAccessExpression(node);
        }
    }

    private ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool> _isValidatableOnInsertOutsideTransaction = new ConcurrentDictionary<Tuple<MethodDeclarationSyntax, bool>, bool>();
    public bool IsValidatableOnInsertOutsideTransaction(MethodDeclarationSyntax method, StructuralType edmType, EdmxElements edmxElements, bool withNotInTransactionMethods = true)
    {
        bool isValidatableOnInsertOutsideTransaction;
        if (_isValidatableOnInsertOutsideTransaction.TryGetValue(new Tuple<MethodDeclarationSyntax, bool>(method, withNotInTransactionMethods), out isValidatableOnInsertOutsideTransaction))
            return isValidatableOnInsertOutsideTransaction;
        var entityType = edmType as EntityType;
        bool isTransactionalMethod = false;
        isValidatableOnInsertOutsideTransaction = ! IsValidateFunc(method) && (withNotInTransactionMethods && ! IsValidatedInTransaction(method, entityType, edmxElements) || entityType != null && GetDependentNavigationProperties(method, entityType, edmxElements).All(np => 
            {
                isTransactionalMethod = true;
                return np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many;
            }) && isTransactionalMethod);
        _isValidatableOnInsertOutsideTransaction.TryAdd(new Tuple<MethodDeclarationSyntax, bool>(method, withNotInTransactionMethods), isValidatableOnInsertOutsideTransaction);
        return isValidatableOnInsertOutsideTransaction;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isCriticityError = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsCriticityError(MethodDeclarationSyntax method, ISemanticModel semanticModel)
    {
        bool isCriticityError;
        if (_isCriticityError.TryGetValue(method, out isCriticityError))
            return isCriticityError;
        isCriticityError = new IsCriticityErrorVisitor(semanticModel, this, ServerFxServiceInterfacesNamespace).Visit(method);
        _isCriticityError.TryAdd(method, isCriticityError);
        return isCriticityError;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, bool> _isValidatedInTransaction = new ConcurrentDictionary<MethodDeclarationSyntax, bool>();
    public bool IsValidatedInTransaction(MethodDeclarationSyntax method, StructuralType edmType, EdmxElements edmxElements)
    {
        bool isValidatedInTransaction;
        if (_isValidatedInTransaction.TryGetValue(method, out isValidatedInTransaction))
            return isValidatedInTransaction;
        if (IsValidateFunc(method))
            return true;
        var entityType = edmType as EntityType;
        isValidatedInTransaction = ! (HasValidateOnServerAttribute(method) || entityType == null) && GetDependentNavigationProperties(method, entityType, edmxElements).Any();
        _isValidatedInTransaction.TryAdd(method, isValidatedInTransaction);
        return isValidatedInTransaction;
    }

    private ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>> _dependentNavigationProperties = new ConcurrentDictionary<MethodDeclarationSyntax, List<NavigationProperty>>();
    public IEnumerable<NavigationProperty> GetDependentNavigationProperties(MethodDeclarationSyntax method, EntityType entityType, EdmxElements edmxElements) 
    {
        List<NavigationProperty> dependentNavigationProperties;
        if (_dependentNavigationProperties.TryGetValue(method, out dependentNavigationProperties))
            return dependentNavigationProperties;
        List<List<PropertySymbolInfo>> pss;
        if (MethodsDependentProperties.TryGetValue(method, out pss) && pss != null)
        {
            dependentNavigationProperties = pss.Where(ps => edmxElements.Code.Escape(entityType) == ps[0].ContainingType.Name).Select(ps => entityType.NavigationProperties.FirstOrDefault(np => edmxElements.Code.Escape(np) == ps[0].Name)).Where(np => np != null).ToList();
            _dependentNavigationProperties.TryAdd(method, dependentNavigationProperties);
            return dependentNavigationProperties;
        }
        dependentNavigationProperties = new List<NavigationProperty>();
        _dependentNavigationProperties.TryAdd(method, dependentNavigationProperties);
        return dependentNavigationProperties;
    }

    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, List<TypeSymbol> argumentTypes = null)
    {
        var methodSymbolInitial = methodSymbol;
        return GetSpecificationEquivalentMethod(ref methodSymbol, () => 
            {
                List<MethodDeclarationSyntax> candidatesMethods = null;
                // Fix Roslyn BUG
                var displayParts = methodSymbolInitial.ToDisplayParts();
                int methodNameIndex = -1;
                int methodNameLoopIndex = 0;
                foreach (var dp in displayParts)
                {
                    if (dp.ToString() == methodSymbolInitial.Name)
                    {
                        methodNameIndex = methodNameLoopIndex;
                        break;
                    }
                    methodNameLoopIndex ++;
                }
                if (methodNameIndex == -1)
                    return null;
                string entityName = displayParts[methodNameIndex - 2].ToString();
                var typeNameSB = new StringBuilder();
                for (int partIndex = 0 ; partIndex < methodNameIndex - 1 ; partIndex ++)
                    typeNameSB.Append(displayParts[partIndex]);
                List<string> interfaceEntitiesName;
                if (ClassesPerInterfaces.TryGetValue(typeNameSB.ToString(), out interfaceEntitiesName))
                {
                    if (interfaceEntitiesName.Count != 1)
                    {
                        if (argumentTypes != null)
                            interfaceEntitiesName = new List<string>() { argumentTypes[0].Name };
                        else
                            throw new NotImplementedException();
                    }
                    entityName = interfaceEntitiesName[0];
                }
                GetMethods.TryGetValue(entityName, out candidatesMethods);
                if (candidatesMethods == null)
                    return null;
                return candidatesMethods.Where(m => m.Identifier.ValueText == methodSymbolInitial.Name);
            });
    }

    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, Func<IEnumerable<MethodDeclarationSyntax>> getMethods)
    {
        return GetSpecificationEquivalentMethod(ref methodSymbol, getMethods());
    }

    private ConcurrentDictionary<MethodSymbol, MethodSymbol> _equivalentMethods = new ConcurrentDictionary<MethodSymbol, MethodSymbol>();
    public bool GetSpecificationEquivalentMethod(ref MethodSymbol methodSymbol, IEnumerable<MethodDeclarationSyntax> candidatesMethods, string defaultClassName = null)
    {
        MethodSymbol value;
        if (_equivalentMethods.TryGetValue(methodSymbol, out value))
        {
            methodSymbol = value;
            return true;
        }
        if (! methodSymbol.IsStatic)
        {
            if (candidatesMethods != null)
            {
                MethodSymbol candidateMethodSymbolValue = null;
                foreach (var candidateMethod in candidatesMethods)
                {
                    if (candidateMethod.Identifier.ValueText != methodSymbol.Name || candidateMethod.ParameterList.Parameters.Count != methodSymbol.Parameters.OfType<ParameterSymbol>().Count() + 1)
                        continue;
                    var candidateMethodSymbol = MethodSymbolPerMethods[candidateMethod];
                    List<NamedTypeSymbol> typesName;
                    var parameterType = candidateMethodSymbol.Parameters[0].Type;
                    if (ClassTypesPerInterfaces.TryGetValue(parameterType.ToString(), out typesName))
                    {
                        if (typesName.Count == 1)
                            parameterType = typesName[0];
                        else if (defaultClassName == null)
                            return false;
                        else
                        {
                            typesName = typesName.Where(tn => tn.Name == defaultClassName).ToList();
                            if (typesName.Count == 1)
                                parameterType = typesName[0];
                            else
                                return false;
                        }
                    }
                    List<NamedTypeSymbol> parameterTypeInterfaces;
                    var methodSignature = methodSymbol.ToString();
                    var methodSymbolName = methodSymbol.Name;
                    if (! (methodSignature.StartsWith(string.Concat(parameterType.ToString(), ".", methodSymbolName)) || InterfacesPerClasses.TryGetValue(parameterType.Name, out parameterTypeInterfaces) && parameterTypeInterfaces.Any(tn => methodSignature.StartsWith(string.Concat(tn.ToString(), ".", methodSymbolName)))))
                        continue;
                    int parametersCount = methodSymbol.Parameters.OfType<ParameterSymbol>().Count();
                    for (int parameterIndex = 0 ; parameterIndex < parametersCount ; )
                        if (methodSymbol.Parameters[parameterIndex++].Type.ToString() != candidateMethodSymbol.Parameters[parameterIndex].Type.ToString())
                            goto fail;
                    candidateMethodSymbolValue = candidateMethodSymbol;
                    break;
        fail:;
                }
                if (candidateMethodSymbolValue != null)
                {
                    if (candidateMethodSymbolValue != null)
                        _equivalentMethods.TryAdd(methodSymbol, candidateMethodSymbolValue);
                    methodSymbol = candidateMethodSymbolValue;
                    return true;
                }
            }
            var methodSymbolValue = methodSymbol;
            if (Methods != null && Methods.Any(m => m.Identifier.ValueText == methodSymbolValue.Name))
            {
                var newMethodSymbol = (MethodSymbol)FindSourceDefinition(methodSymbol, Solution);
                if (newMethodSymbol != null && newMethodSymbol.IsStatic)
                {
                    if (newMethodSymbol.IsStatic)
                    {
                        if (newMethodSymbol != null)
                            _equivalentMethods.TryAdd(methodSymbol, newMethodSymbol);
                        methodSymbol = newMethodSymbol;
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public bool IsContext(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => i.ToString() == ServerFxDALInterfacesNamespace + ".IDataContext");
    }

    public bool IsService(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => i.ToString() == ServerFxServiceInterfacesNamespace + ".IService");
    }

    public bool IsContextOrService(ITypeSymbol type)
    {
        return type.AllInterfaces.Any(i => 
            {
                var interfaceString = i.ToString();
                return interfaceString == ServerFxDALInterfacesNamespace + ".IDataContext" || interfaceString == ServerFxServiceInterfacesNamespace + ".IService";
            });
    }

    public bool HasContextAsParameter(MethodDeclarationSyntax method)
    {
        return HasContextAsParameter(MethodSymbolPerMethods[method]);
    }

    public bool HasContextOrServiceAsParameter(MethodDeclarationSyntax method)
    {
        return HasContextOrServiceAsParameter(MethodSymbolPerMethods[method]);
    }

    public bool HasContextAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsContext(p.Type));
    }

    public bool HasContextOrServiceAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsContextOrService(p.Type));
    }

    private bool HasServiceAsParameter(MethodSymbol method)
    {
        return method.Parameters.Any(p => IsService(p.Type));
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, out bool hasContext, out string contextName)
    {
        return GetParametersWithoutContext(method, method.ParameterList.Parameters, out hasContext, out contextName);
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, IEnumerable<ParameterSyntax> parameters, out bool hasContext, out string contextName, Func<ParameterSyntax, ParameterSyntax> transformParameter = null)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        bool hasContextLambda = false;
        string contextNameLambda = null;
        var value = parameters
            .Where(p => 
                {
                    var pSymbol = methodSymbol.Parameters.First(p2 => p2.Name == p.Identifier.ValueText);
                    if (IsContext(pSymbol.Type))
                    {
                        hasContextLambda = true;
                        contextNameLambda = pSymbol.Name;
                        return false;
                    }
                    else
                        return true;
                })
            .Select(p => transformParameter == null ? SyntaxFactory.Parameter(p.Identifier).WithType(p.Type) : transformParameter(p)).ToList();
        hasContext = hasContextLambda;
        contextName = contextNameLambda;
        return value;
    }

    public IEnumerable<ParameterSyntax> GetParametersWithoutContextAndService(MethodDeclarationSyntax method, IEnumerable<ParameterSyntax> parameters, IEnumerable<TypeSymbol> dtoTypes, out bool hasContext, out string contextName, out bool hasService, out string serviceName, Dictionary<string, string>  namespacesReplacement, Func<ParameterSyntax, ParameterSyntax> transformParameter = null)
    {
        var methodSymbol = MethodSymbolPerMethods[method];
        var semanticModel = SemanticModelPerMethods[method];
        bool hasContextLambda = false;
        string contextNameLambda = null;
        bool hasServiceLambda = false;
        string serviceNameLambda = null;
        var value = parameters
            .Where(p => 
                {
                    var pSymbol = methodSymbol.Parameters.First(p2 => p2.Name == p.Identifier.ValueText);
                    if (IsContext(pSymbol.Type))
                    {
                        hasContextLambda = true;
                        contextNameLambda = pSymbol.Name;
                        return false;
                    }
                    if (IsService(pSymbol.Type))
                    {
                        hasServiceLambda = true;
                        serviceNameLambda = pSymbol.Name;
                        return false;
                    }
                    return true;
                })
            .Select(p => transformParameter == null ? SyntaxFactory.Parameter(p.Identifier).WithType((TypeSyntax)new DTOAndInterfacesTypesRewriter(semanticModel, this, dtoTypes, namespacesReplacement).Visit(p.Type)).WithDefault(p.Default) : transformParameter(p)).ToList();
        hasContext = hasContextLambda;
        contextName = contextNameLambda;
        hasService = hasServiceLambda;
        serviceName = serviceNameLambda;
        return value;
    }

    private ParameterListSyntax GetParameterListWithoutContext(MethodDeclarationSyntax method, ParameterListSyntax parameterList, out string contextName)
    {
        bool hasContext;
        var parameters = GetParametersWithoutContext(method, parameterList.Parameters, out hasContext, out contextName);
        return SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(parameters, parameters.Skip(1).Select(v => SyntaxFactory.Token(SyntaxKind.CommaToken))));
    }

    private IEnumerable<ParameterSyntax> GetParametersWithoutContext(MethodDeclarationSyntax method, out bool hasContext)
    {
        string contextName;
        return GetParametersWithoutContext(method, method.ParameterList.Parameters, out hasContext, out contextName);
    }

    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    public void GetParametersWithoutContextTransformInterfaces(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, string entitiesNamespace, string defaultEntity = null)
    {
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName)
    {
        bool useOtherService;
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, null, null);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName)
    {
        bool useOtherService;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, null, null);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        List<string> parameterTypesList;
        GetParametersWithoutContext(method, out parameterTypesList, out parameterTypes, out parameterNames, out hasContext, out contextParameterName, out useOtherService, entitiesNamespace, defaultEntity);
    }
    private void GetParametersWithoutContext(MethodDeclarationSyntax method, out List<string> parameterTypesList, out StringBuilder parameterTypes, out StringBuilder parameterNames, out bool hasContext, out string contextParameterName, out bool useOtherService, string entitiesNamespace, string defaultEntity = null)
    {
        var semanticModel = SemanticModelPerMethods[method];
        parameterTypesList = new List<string>();
        hasContext = false;
        contextParameterName = null;
        bool hasContextValue = false;
        string contextParameterNameValue = null;
        var methodSymbol = MethodSymbolPerMethods[method];
        var parameters = methodSymbol.Parameters.OfType<ParameterSymbol>().Where(p => 
            {
                if (IsContext(p.Type))
                {
                    hasContextValue = true;
                    contextParameterNameValue = p.Name;
                    return false;
                }
                return true;
            }).ToList();
        hasContext = hasContextValue;
        contextParameterName = contextParameterNameValue;
        useOtherService = new UseServiceVisitor(semanticModel, ServicePropertiesStrings).Visit(method.Body);
        parameterTypes = new StringBuilder();
        parameterNames = new StringBuilder();
        var parametersEnumerator = parameters.GetEnumerator();
        var syntaxParametersEnumerator = method.ParameterList.Parameters.GetEnumerator();
        if (parametersEnumerator.MoveNext() && syntaxParametersEnumerator.MoveNext())
        {
            parameterTypes.Append(GetTypeString(syntaxParametersEnumerator.Current.Type, semanticModel, parametersEnumerator.Current.Type, entitiesNamespace, defaultEntity));
            parameterNames.Append(parametersEnumerator.Current.Name);
            while (parametersEnumerator.MoveNext() && syntaxParametersEnumerator.MoveNext())
            {
                parameterTypes.Append(", ");
                var typeName = GetTypeString(syntaxParametersEnumerator.Current.Type, semanticModel, parametersEnumerator.Current.Type, entitiesNamespace, defaultEntity);
                parameterTypesList.Add(typeName);
                parameterTypes.Append(typeName);
                parameterNames.Append(", ");
                parameterNames.Append(parametersEnumerator.Current.Name);
            }
        }
    }

    public string GetTypeString(TypeSyntax type, ISemanticModel semanticModel, TypeSymbol typeSymbol, string entitiesNamespace, string defaultEntity = null)
    {
        var value = typeSymbol.ToString();
        var newType = new TypeRewriter(semanticModel, ns =>
            {
                var t = (TypeSyntax)ns;
                ReplaceInterface(ref t, semanticModel, defaultEntity);
                return (NameSyntax)t;
            }).Visit(type);
        if (newType != type)
            return newType.NormalizeWhitespace().ToString();
        return value;
    }

    public string ServerFxDALInterfacesNamespace { get; set; }
    public string ServerFxServiceInterfacesNamespace { get; set; }
    public string ServerFxSpecificationsNamespace { get; set; }
}

public struct ClassNames
{
    public static ClassNames Get(Dictionary<string, object> cache)
    {
        return new ClassNames { Name = (string)cache["Name"], FullName = (string)cache["FullName"] };
    }
    public Dictionary<string, object> ToCache()
    {
        return new Dictionary<string, object>() { {"Name", Name}, {"FullName", FullName} };
    }

    public string Name { get; set; }
    public string FullName { get; set; }
}

public static EdmType GetBaseTypeWithExtensionMethods(EdmType edmType, SpecificationsElements specificationsElements, CodeGenerationTools code, string serverEntitiesNamespace)
{
    var baseType = edmType.BaseType;
    var baseTypeLoop = baseType;
    while (baseTypeLoop != null)
    {
        foreach (var method in specificationsElements.Methods)
        {
            var methodSymbol = specificationsElements.MethodSymbolPerMethods[method];
            if (methodSymbol.IsExtensionMethod && methodSymbol.Parameters[0].Type.ToString() == string.Concat(serverEntitiesNamespace, ".", code.Escape(baseTypeLoop)))
                return baseTypeLoop;
        }
        baseTypeLoop = baseTypeLoop.BaseType;
    }
    return null;
}

public IEnumerable<MethodDeclarationSyntax> GetExtensionMethodsPerClass(string className, SpecificationsElements specificationsElements, string serverEntitiesNamespace)
{
    List<MethodDeclarationSyntax> value;
    if (specificationsElements.ExtensionMethodsPerTypes.TryGetValue(className, out value))
        return value;
    return new MethodDeclarationSyntax[0];
}

public class WAQSMetadata
{
    public WAQSMetadata()
    {
    }

    private WAQSMetadata(Dictionary<string, object> cache)
    {
        TypeName = (string)cache["TypeName"];
        TypeSymbol = (TypeSymbol)cache["TypeSymbol"];
        MethodName = (string)cache["MethodName"];
        Property = (string)cache["Property"];
        PropertySymbol = (PropertySymbol)cache["PropertySymbol"];
        LambdaExpression = (SimpleLambdaExpressionSyntax)cache["LambdaExpression"];
        ConstantExpression = (LiteralExpressionSyntax)cache["ConstantExpression"];
        IsOverriden = (bool)cache["IsOverriden"];
        DependentProperties = ((List<List<Dictionary<string, object>>>)cache["DependentProperties"]).Select(ps => ps.Select(p => PropertySymbolInfo.Get(p)).ToList()).ToList();
    }

    public static WAQSMetadata Get(Dictionary<string, object> cache)
    {
        return new WAQSMetadata(cache);
    }

    public Dictionary<string, object> ToCache()
    {
        var value = new Dictionary<string, object>();
        value.Add("TypeName", TypeName);
        value.Add("TypeSymbol", TypeSymbol);
        value.Add("MethodName", MethodName);
        value.Add("Property", Property);
        value.Add("PropertySymbol", PropertySymbol);
        value.Add("LambdaExpression", LambdaExpression);
        value.Add("ConstantExpression", ConstantExpression);
        value.Add("IsOverriden", IsOverriden);
        value.Add("DependentProperties", DependentProperties.Select(ps => ps.Select(p => p.ToCache()).ToList()).ToList());
        value.Add("HashCode", GetHashCode());
        return value;
    }

    public string TypeName { get; set; }
    public TypeSymbol TypeSymbol { get; set; }
    public string MethodName { get; set; }
    public string Property { get; set; }
    public PropertySymbol PropertySymbol { get; set; }
    public SimpleLambdaExpressionSyntax LambdaExpression { get; set; }
    public LiteralExpressionSyntax ConstantExpression { get; set; }
    public bool IsOverriden { get; set; }
    public List<List<PropertySymbolInfo>> DependentProperties { get; set; }
}

public static class TypeSymbolHelper
{
    public static int GetTypeInheritanceDepth(ITypeSymbol type)
    {
        int depth = 0;
        while ((type = type.BaseType) != null)
            depth ++;
        return depth;
    }

    public static bool IsInherited(ITypeSymbol baseType, TypeSymbol inheritedType)
    {
        string baseTypeFullName = baseType.ToString();
        do 
        {
            if (inheritedType.ToString() == baseTypeFullName)
                return true;
        } while ((inheritedType = inheritedType.BaseType) != null);
        return false;
    }
}

public static TypeSymbol GetClassExtensionMethodClass(MethodSymbol methodSymbol, SpecificationsElements specificationsElements, string serverFxSpecificationsNamespace, string serverEntitiesNamespace)
{
    if (! (methodSymbol.IsStatic && methodSymbol.IsExtensionMethod))
        return null;
    var parameterType = methodSymbol.Parameters[0].Type;
    if (parameterType.ContainingNamespace.ToString() == serverEntitiesNamespace)
        return parameterType;
    if (! parameterType.GetAttributes().Any(a => a.ToString() == serverFxSpecificationsNamespace + ".IEntityAttribute"))
        return null;
    return specificationsElements.ClassTypesPerInterfaces[parameterType.ToString()].Single();
}

public static string GetPropertyNameFromMethodName(string methodName)
{
    return SpecificationMethods.GetPropertyNameFromMethodName(methodName);
}

public static string GetPropertyNameFromMethod(MethodDeclarationSyntax method)
{
    return SpecificationMethods.GetPropertyNameFromMethod(method);
}

public class SpecificationMethods
{
    public static string GetPropertyNameFromMethodName(string methodName)
    {
        return Regex.Replace(methodName, "^Get([A-Z])", m => m.Groups[1].Value);
    }

    public static string GetPropertyNameFromMethod(MethodDeclarationSyntax method)
    {
        return GetPropertyNameFromMethodName(method.Identifier.ValueText);
    }
}

abstract class SpecificationVisitor : SyntaxVisitor
{
    protected SpecificationsElements SpecificationsElements { get; set; }
    protected ISemanticModel SemanticModel { get; set; }
    protected string Namespace { get; set; }
    protected bool _proceed;

    public SpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, string @namespace)
    {
        SpecificationsElements = specificationsElements;
        SemanticModel = semanticModel;
        GetMethods = getMethods;
        ValidateMethods = validateMethods;
        WAQSMetadata = waqsMetadata;
        ServiceMethods = serviceMethods;
        SubMethods = subMethods;
        DefinePropertyDependencesMethods = definePropertyDependencesMethods;
        ServiceProperties = serviceProperties;
        Namespace = @namespace;
        Namespaces = specificationsElements.SpecificationsNamespaces;
        SpecificationsTypes = specificationsElements.SpecificationsTypes;
    }

    public List<string> Namespaces { get; private set; } 
    public List<TypeSymbol> SpecificationsTypes { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> GetMethods { get; private set; }
    public Dictionary<string, List<MethodDeclarationSyntax>> ValidateMethods { get; private set; }
    public Dictionary<string, List<WAQSMetadata>> WAQSMetadata { get; private set; } 
    public List<MethodDeclarationSyntax> ServiceMethods { get; private set; }
    public List<MethodDeclarationSyntax> SubMethods { get; private set; }
    public List<MethodDeclarationSyntax> DefinePropertyDependencesMethods { get; private set; }
    public List<PropertyDeclarationSyntax> ServiceProperties { get; private set; }

    protected abstract SpecificationVisitor NewSpecificationVisitor();
    protected abstract bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className);
    protected abstract bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className);
    protected bool IsDefineMethod(MethodDeclarationSyntax node)
    {
        return SpecificationsElements.IsDefineMethod(node, SemanticModel);
    }
    protected abstract bool IsServiceMethod(MethodDeclarationSyntax node, string @class);
    protected abstract bool IsSubMethod(MethodDeclarationSyntax node, string @class);

    public override void Visit(SyntaxNode node)
    {
        base.Visit(node);
        if (!_proceed)
            foreach (var childNode in node.ChildNodes().Where(c => c != null))
                NewSpecificationVisitor().Visit(childNode);
    }

    public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        string name = node.Name.ToString();
        if (! Namespaces.Contains(name))
            Namespaces.Add(name);
        base.VisitNamespaceDeclaration(node);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitClassDeclaration(node);
    }
    public override void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitInterfaceDeclaration(node);
    }
    public override void VisitStructDeclaration(StructDeclarationSyntax node)
    {
        VisitTypeDeclaration(node);
        base.VisitStructDeclaration(node);
    }
    private void VisitTypeDeclaration(TypeDeclarationSyntax node)
    {
        var typeSymbol = (TypeSymbol)SemanticModel.GetDeclaredSymbol(node);
        if (typeSymbol.GetAttributes().Any(a => a.AttributeClass.ToString() == "System.CodeDom.Compiler.GeneratedCodeAttribute"))
            _proceed = true;
        else
            SpecificationsTypes.Add(typeSymbol);
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (Regex.IsMatch(node.Identifier.ValueText, @"^Define[^\s]+PropertyDependences$"))
        {
            _proceed = true;
            DefinePropertyDependencesMethods.Add(node);
            return;
        }
        string className = null;
        List<string> classes;
        NamedTypeSymbol namedTypeSymbol;
        if (node.ParameterList.Parameters.Count != 0)
        {
            if (IsGetMethod(node, null, out className))
            {
                AddGetMethods(className, node);
                _proceed = true;
            }
            else if ((namedTypeSymbol = ((ParameterSymbol)SemanticModel.GetDeclaredSymbol(node.ParameterList.Parameters[0])).Type as NamedTypeSymbol) != null && SpecificationsElements.ClassesPerInterfaces.TryGetValue(namedTypeSymbol.ToString(), out classes))
            {
                foreach (var @class in classes)
                    if (IsGetMethod(node, @class, out className))
                    {
                        AddGetMethods(@class, node);
                        _proceed = true;
                    }
            }
            if (_proceed)
                return;
            if (IsValidateMethod(node, null, out className))
            {
                AddValidateMethods(className, node);
                _proceed = true;
            }
            else if ((namedTypeSymbol = ((ParameterSymbol)SemanticModel.GetDeclaredSymbol(node.ParameterList.Parameters[0])).Type as NamedTypeSymbol) != null && SpecificationsElements.ClassesPerInterfaces.TryGetValue(namedTypeSymbol.ToString(), out classes))
            {
                foreach (var @class in classes)
                    if (IsValidateMethod(node, @class, out className))
                    {
                        AddValidateMethods(@class, node);
                        _proceed = true;
                    }
            }
            if (_proceed)
                return;
        }
        if (IsDefineMethod(node))
            foreach (var statement in node.Body.Statements)
            {
                var invocation = (InvocationExpressionSyntax)statement.ChildNodes().Single();
                var invocationMethod = (MethodSymbol)SemanticModel.GetSymbolInfo(invocation).Symbol;
                var type = (invocationMethod.ContainingType).TypeArguments.Single();
                var expression = invocation.ArgumentList.Arguments[1].Expression;
                var property = ((MemberAccessExpressionSyntax)((SimpleLambdaExpressionSyntax)invocation.ArgumentList.Arguments[0].Expression).Body);
                var metadata = new WAQSMetadata { TypeSymbol = type, TypeName = type.Name, MethodName = invocationMethod.Name, Property = property.Name.Identifier.ValueText, PropertySymbol = (PropertySymbol)SemanticModel.GetSymbolInfo(property).Symbol, ConstantExpression = expression as LiteralExpressionSyntax, LambdaExpression = expression as SimpleLambdaExpressionSyntax };
                if (SpecificationsElements.ClassesPerInterfaces.TryGetValue(type.Name, out classes))
                    foreach (var @class in classes)
                    {
                        List<WAQSMetadata> waqsMetadata;
                        if (! WAQSMetadata.TryGetValue(@class, out waqsMetadata))
                            WAQSMetadata.Add(@class, waqsMetadata = new List<WAQSMetadata>());
                        waqsMetadata.Add(metadata);
                    }
                else
                {
                    var typeName = type.Name;
                    List<WAQSMetadata> waqsMetadata;
                    if (! WAQSMetadata.TryGetValue(typeName, out waqsMetadata))
                        WAQSMetadata.Add(typeName, waqsMetadata = new List<WAQSMetadata>());
                    waqsMetadata.Add(metadata);
                }
            }
        else if (IsServiceMethod(node, null))
            ServiceMethods.Add(node);
        else if (IsSubMethod(node, null))
            SubMethods.Add(node);
        else
            throw new NotImplementedException();
        _proceed = true;
    }

    private void AddGetMethods(string edmTypeName, MethodDeclarationSyntax node)
    {
        List<MethodDeclarationSyntax> methods;
        if (!GetMethods.TryGetValue(edmTypeName, out methods))
        {
            methods = new List<MethodDeclarationSyntax>();
            GetMethods.Add(edmTypeName, methods);
        }
        methods.Add(node);
    }

    private void AddValidateMethods(string edmTypeName, MethodDeclarationSyntax node)
    {
        List<MethodDeclarationSyntax> methods;
        if (!ValidateMethods.TryGetValue(edmTypeName, out methods))
        {
            methods = new List<MethodDeclarationSyntax>();
            ValidateMethods.Add(edmTypeName, methods);
        }
        methods.Add(node);
    }

    public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        ServiceProperties.Add(node);
        _proceed = true;
    }
}

class EntitiesSpecificationVisitor : SpecificationVisitor
{
    private EdmxElements _edmxElements;

    public EntitiesSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, EdmxElements edmxElements, string entitiesNamespace)
        : this(specificationsElements, semanticModel, new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<WAQSMetadata>>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<PropertyDeclarationSyntax>(), edmxElements, entitiesNamespace)
    {
    }
    public EntitiesSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, EdmxElements edmxElements, string entitiesNamespace)
        : base(specificationsElements, semanticModel, getMethods, validateMethods, waqsMetadata, serviceMethods, subMethods, definePropertyDependencesMethods, serviceProperties, entitiesNamespace)
    {
        _edmxElements = edmxElements;
    }

    protected override SpecificationVisitor NewSpecificationVisitor()
    {
        return new EntitiesSpecificationVisitor(SpecificationsElements, SemanticModel, GetMethods, ValidateMethods, WAQSMetadata, ServiceMethods, SubMethods, DefinePropertyDependencesMethods, ServiceProperties, _edmxElements, Namespace);
    }

    protected override bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsGetMethod(node, _edmxElements, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsValidateMethod(node, _edmxElements, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsServiceMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsServiceMethod(node, _edmxElements, SemanticModel, Namespace, @class);
    }

    protected override bool IsSubMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsSubMethod(node, _edmxElements, SemanticModel, Namespace);
    }
}

class DTOSpecificationVisitor : SpecificationVisitor
{
    private IEnumerable<TypeSymbol> _dtoTypes;

    public DTOSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, IEnumerable<TypeSymbol> dtoTypes, string dtoTypesNamespace)
        : this(specificationsElements, semanticModel, new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<MethodDeclarationSyntax>>(), new Dictionary<string, List<WAQSMetadata>>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<MethodDeclarationSyntax>(), new List<PropertyDeclarationSyntax>(), dtoTypes, dtoTypesNamespace)
    {
    }
    public DTOSpecificationVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, Dictionary<string, List<MethodDeclarationSyntax>> getMethods, Dictionary<string, List<MethodDeclarationSyntax>> validateMethods, Dictionary<string, List<WAQSMetadata>> waqsMetadata, List<MethodDeclarationSyntax> serviceMethods, List<MethodDeclarationSyntax> subMethods, List<MethodDeclarationSyntax> definePropertyDependencesMethods, List<PropertyDeclarationSyntax> serviceProperties, IEnumerable<TypeSymbol> dtoTypes, string dtoTypesNamespace)
        : base(specificationsElements, semanticModel, getMethods, validateMethods, waqsMetadata, serviceMethods, subMethods, definePropertyDependencesMethods, serviceProperties, dtoTypesNamespace)
    {
        _dtoTypes = dtoTypes;
    }

    protected override SpecificationVisitor NewSpecificationVisitor()
    {
        return new DTOSpecificationVisitor(SpecificationsElements, SemanticModel, GetMethods, ValidateMethods, WAQSMetadata, ServiceMethods, SubMethods, DefinePropertyDependencesMethods, ServiceProperties, _dtoTypes, Namespace);
    }

    protected override bool IsGetMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsGetMethod(node, _dtoTypes, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsValidateMethod(MethodDeclarationSyntax node, string @class, out string className)
    {
        return SpecificationsElements.IsValidateMethod(node, _dtoTypes, SemanticModel, Namespace, out className, @class);
    }

    protected override bool IsServiceMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsServiceMethod(node, _dtoTypes, SemanticModel, Namespace, @class);
    }

    protected override bool IsSubMethod(MethodDeclarationSyntax node, string @class)
    {
        return SpecificationsElements.IsSubMethod(node, _dtoTypes, SemanticModel, Namespace);
    }
}

partial class GetMembersVisitor : SyntaxVisitor
{
    private const int MaxFailed = 50;

    private bool _proceed;
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _serverFxDALInterfacesNamespace;
    private ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> _semanticModelPerMethods;
    private ConcurrentDictionary<string, MethodDeclarationSyntax> _methodPerMethodSymbols;
    private List<MethodDeclarationSyntax> _extensionMethods;
    private Dictionary<string, List<MethodDeclarationSyntax>> _getMethods;
    private Dictionary<string, PropertyDependence> _variables;
    private Dictionary<string, int> _fromVariables;
    private int _linqIndex;
    private List<MethodSymbol> _alreadyCalledMethods;
    private bool _fromOriginalMethod;
    private bool _definePropertyDependences;
    private PropertyDependence _returnProperties;
    private PropertyDependence _properties;
    private int _failed = 0;

    public GetMembersVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements,
        MethodSymbol methodSymbol, string variableName, string serverFxDALInterfacesNamespace,
        ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> semanticModelPerMethods,
        ConcurrentDictionary<string, MethodDeclarationSyntax> methodPerMethodSymbols,
        Dictionary<string, List<MethodDeclarationSyntax>> getMethods, List<MethodDeclarationSyntax> extensionMethods)
        : this(
            semanticModel, specificationsElements, serverFxDALInterfacesNamespace, semanticModelPerMethods,
            methodPerMethodSymbols, getMethods, extensionMethods,
            new Dictionary<string, PropertyDependence>() { { variableName, null } },
            new Dictionary<string, int>(), 0, new List<MethodSymbol>() { methodSymbol }, false)
    {
        _fromOriginalMethod = true;
    }

    public GetMembersVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements,
        MethodSymbol methodSymbol, string serverFxDALInterfacesNamespace,
        ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> semanticModelPerMethods,
        ConcurrentDictionary<string, MethodDeclarationSyntax> methodPerMethodSymbols,
        Dictionary<string, List<MethodDeclarationSyntax>> getMethods, List<MethodDeclarationSyntax> extensionMethods)
        : this(
            semanticModel, specificationsElements, serverFxDALInterfacesNamespace, semanticModelPerMethods,
            methodPerMethodSymbols, getMethods, extensionMethods,
            new Dictionary<string, PropertyDependence>(), new Dictionary<string, int>(), 0,
            new List<MethodSymbol>() { methodSymbol }, true)
    {
        _fromOriginalMethod = true;
    }

    private GetMembersVisitor(GetMembersVisitor @base,
        Dictionary<string, PropertyDependence> variables = null)
        : this(
            @base._semanticModel, @base._specificationsElements, @base._serverFxDALInterfacesNamespace,
            @base._semanticModelPerMethods, @base._methodPerMethodSymbols, @base._getMethods,
            @base._extensionMethods, variables ?? @base._variables, @base._fromVariables, @base._linqIndex,
            @base._alreadyCalledMethods, @base._definePropertyDependences, @base._failed)
    {
        _fromOriginalMethod = false;
        _returnProperties = @base._returnProperties;
    }

    private GetMembersVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements,
        string serverFxDALInterfacesNamespace,
        ConcurrentDictionary<MethodDeclarationSyntax, ISemanticModel> semanticModelPerMethods,
        ConcurrentDictionary<string, MethodDeclarationSyntax> methodPerMethodSymbols,
        Dictionary<string, List<MethodDeclarationSyntax>> getMethods, List<MethodDeclarationSyntax> extensionMethods,
        Dictionary<string, PropertyDependence> variables, Dictionary<string, int> fromVariables,
        int linqIndex, List<MethodSymbol> alreadyCalledMethods, bool definePropertyDependences, int failed = 0)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _serverFxDALInterfacesNamespace = serverFxDALInterfacesNamespace;
        _semanticModelPerMethods = semanticModelPerMethods;
        _methodPerMethodSymbols = methodPerMethodSymbols;
        _getMethods = getMethods;
        _extensionMethods = extensionMethods;
        _variables = variables;
        _fromVariables = fromVariables;
        _linqIndex = linqIndex;
        _alreadyCalledMethods = alreadyCalledMethods;
        _properties = new PropertyDependence();
        _definePropertyDependences = definePropertyDependences;
        _failed = failed;
    }

    public List<List<PropertySymbolInfo>> GetProperties()
    {
        return GetProperties(_properties);
    }

    public List<List<PropertySymbolInfo>> GetReturnProperties()
    {
        if (_returnProperties == null)
            return null;
        return GetProperties(_returnProperties);
    }

    private List<List<PropertySymbolInfo>> GetProperties(PropertyDependence properties)
    {
        var value = new List<List<PropertySymbolInfo>>();
        GetPropertiesRecursive(properties, value);
        return value;
    }

    private void GetPropertiesRecursive(PropertyDependence dependences, List<List<PropertySymbolInfo>> value)
    {
        AddProperties(dependences.Dependences, value);
        foreach (var propertyDependences in dependences.PropertiesDependences)
            GetPropertiesRecursive(propertyDependences.Value, value);
    }

    public static void Reset()
    {
    }

    public override void Visit(SyntaxNode node)
    {
        if (node == null)
            return;
        if (node is StatementSyntax)
            _properties.ResetLast();
        base.Visit(node);
        if (!_proceed)
            foreach (var childNode in node.ChildNodes())
            {
                var getMembersVisitor = new GetMembersVisitor(this);
                getMembersVisitor.Visit(childNode);
                AddProperties(getMembersVisitor._properties);
                if (_returnProperties != getMembersVisitor._returnProperties && getMembersVisitor._returnProperties != null)
                    AddReturnProperties(getMembersVisitor._returnProperties);
            }
    }

    public override void VisitQueryExpression(QueryExpressionSyntax node)
    {
        _linqIndex++;
        var getMembersVisitor = new GetMembersVisitor(this);
        getMembersVisitor.Visit(node.FromClause);
        AddProperties(getMembersVisitor._properties);
        getMembersVisitor = new GetMembersVisitor(this);
        getMembersVisitor.Visit(node.Body);
        AddProperties(getMembersVisitor._properties);
        _properties.Last = getMembersVisitor._properties.Last;
        _proceed = true;
    }

    public override void VisitQueryContinuation(QueryContinuationSyntax node)
    {
        Visit(node.Body);
        _proceed = true;
    }

    public override void VisitJoinClause(JoinClauseSyntax node)
    {
        var membersVisitor = new GetMembersVisitor(this);
        membersVisitor.Visit(node.InExpression);
        _variables.Add(node.Identifier.ValueText, membersVisitor._properties);
        _fromVariables.Add(node.Identifier.ValueText, _linqIndex);
        AddProperties(membersVisitor._properties);
        Visit(node.LeftExpression);
        _proceed = false;
        Visit(node.RightExpression);
        if (node.Into != null)
        {
            _variables.Add(node.Into.Identifier.ValueText, membersVisitor._properties);
            _fromVariables.Add(node.Into.Identifier.ValueText, _linqIndex);
            _fromVariables.Remove(node.Identifier.ValueText);
            _variables.Remove(node.Identifier.ValueText);
        }
        _proceed = true;
    }

    public override void VisitQueryBody(QueryBodySyntax node)
    {
        foreach (var clause in node.Clauses)
            Visit(clause);
        _proceed = false;

        if (node.Continuation == null)
        {
            Visit(node.SelectOrGroup);
            _proceed = true;
            return;
        }

        Visit(node.SelectOrGroup);
        _properties.Last = _properties.Last;
        foreach (string variable in _fromVariables.Where(v => v.Value == _linqIndex).Select(v => v.Key).ToList())
        {
            AddProperties(GetProperties(_variables[variable]));
            _fromVariables.Remove(variable);
            _variables.Remove(variable);
        }
        var variableDependences = new PropertyDependence();
        AddProperties(_properties.Last, variableDependences);
        _variables.Add(node.Continuation.Identifier.ValueText, variableDependences);
        _fromVariables.Add(node.Continuation.Identifier.ValueText, _linqIndex);
        Visit(node.Continuation);
        _proceed = true;
    }

    public override void VisitFromClause(FromClauseSyntax node)
    {
        var membersVisitor = new GetMembersVisitor(this);
        membersVisitor.Visit(node.Expression);
        _variables.Add(node.Identifier.ValueText, membersVisitor._properties);
        _fromVariables.Add(node.Identifier.ValueText, _linqIndex);
        AddProperties(membersVisitor._properties);
        _proceed = true;
    }

    public override void VisitLetClause(LetClauseSyntax node)
    {
        var membersVisitor = new GetMembersVisitor(this);
        membersVisitor.Visit(node.Expression);
        _variables.Add(node.Identifier.ValueText, membersVisitor._properties);
        AddProperties(membersVisitor._properties);
        _fromVariables.Add(node.Identifier.ValueText, _linqIndex);
        _proceed = true;
    }

    public override void VisitWhereClause(WhereClauseSyntax node)
    {
        var membersVisitor = new GetMembersVisitor(this);
        membersVisitor.Visit(node.Condition);
        AddProperties(membersVisitor._properties);
        _proceed = true;
    }

    public override void VisitSelectClause(SelectClauseSyntax node)
    {
        Visit(node.Expression);
        foreach (string variable in _fromVariables.Where(v => v.Value == _linqIndex).Select(v => v.Key).ToList())
        {
            AddProperties(GetProperties(_variables[variable]));
            _fromVariables.Remove(variable);
            _variables.Remove(variable);
        }
        _linqIndex--;
        _proceed = true;
    }

    public override void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        if (node.Initializer != null)
        {
            _properties.Last = _properties.Last;
            foreach (var m in node.Initializer.Expressions)
            {
                var binary = m as BinaryExpressionSyntax;
                if (binary != null && IsAssignExpression(GetKind(binary)))
                {
                    var initializerVisitor = new GetMembersVisitor(this);
                    initializerVisitor.Visit(binary.Right);
                    var propertyName = ((IdentifierNameSyntax)binary.Left).Identifier.ValueText;
                    if (_properties.PropertiesDependences.ContainsKey(propertyName))
                        _properties.PropertiesDependences[propertyName] = initializerVisitor._properties;
                    else
                        _properties.PropertiesDependences.Add(propertyName, initializerVisitor._properties);
                }
                else
                    Visit(m);
            }
            _properties.Last = new PropertyDependence { PropertiesDependences = _properties.PropertiesDependences };
            _proceed = true;
        }
    }

    public override void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
        _properties.Last = _properties.Last;
        foreach (var m in node.Initializers)
        {
            var initializerVisitor = new GetMembersVisitor(this);
            initializerVisitor.Visit(m);
            AddProperties(initializerVisitor._properties);
        }
        _properties.Last = new PropertyDependence { PropertiesDependences = _properties.PropertiesDependences };
        _proceed = true;
    }

    public override void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
        var expressionVisitor = new GetMembersVisitor(this);
        expressionVisitor.Visit(node.Expression);
        _properties.PropertiesDependences.Add(node.NameEquals == null ? ((MemberAccessExpressionSyntax)node.Expression).Name.Identifier.ValueText : node.NameEquals.Name.Identifier.ValueText, expressionVisitor._properties);
    }

    public override void VisitGroupClause(GroupClauseSyntax node)
    {
        var groupExpressionVisitor = new GetMembersVisitor(this);
        groupExpressionVisitor.Visit(node.GroupExpression);
        var byExpressionVisitor = new GetMembersVisitor(this);
        byExpressionVisitor.Visit(node.ByExpression);
        AddProperties(groupExpressionVisitor._properties);
        _properties.PropertiesDependences.Add("Key", byExpressionVisitor._properties);
        _proceed = true;
    }

    public override void VisitBlock(BlockSyntax node)
    {
        var membersVisitor = new GetMembersVisitor(this, new Dictionary<string, PropertyDependence>(_variables));
        foreach (var statement in node.Statements)
        {
            membersVisitor.Visit(statement);
            membersVisitor._proceed = false;
        }
        AddProperties(membersVisitor._properties);
        AddReturnProperties(membersVisitor._returnProperties);
        _proceed = true;
    }

    public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        var expressionSymbol = _semanticModel.GetSymbolInfo(node.Expression).Symbol;
        if (expressionSymbol is ITypeSymbol)
            return;
        var parameterSymbol = expressionSymbol as IParameterSymbol;
        PropertyDependence variableProperties;
        var propertySymbol = _semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol;
        if (propertySymbol == null)
            return;
        bool systemProperty = propertySymbol.ContainingType.ContainingNamespace != null && propertySymbol.ContainingType.ContainingNamespace.ToString().StartsWith("System");
        if (systemProperty)
        {
            switch (propertySymbol.ContainingType.ConstructedFrom.ToString())
            {
                case "System.Collections.Generic.KeyValuePair<TKey, TValue>":
                    _properties.Error = true;
                    _properties.Last.Error = true;
                    _proceed = true;
                    return;
            }
        }

        Action applyOnParameter = () =>
        {
            bool knownVariable = _variables.TryGetValue(parameterSymbol.Name, out variableProperties);
            if (knownVariable && variableProperties != null)
            {
                PropertyDependence newLast;
                if (variableProperties.PropertiesDependences.TryGetValue(propertySymbol.Name, out newLast))
                {
                    _properties.Last = newLast.Last;
                    _properties = newLast;
                    _proceed = true;
                    return;
                }
            }
            if (systemProperty)
            {
                _proceed = true;
                return;
            }
            if (knownVariable)
            {
                if (variableProperties == null || variableProperties.Last.Dependences.Count == 0)
                    AddProperty(new List<PropertySymbolInfo>() { PropertySymbolInfo.Get(propertySymbol) });
                else
                    foreach (var dp in variableProperties.Last.Dependences)
                        AddProperty(new List<PropertySymbolInfo>(dp) { PropertySymbolInfo.Get(propertySymbol) });
                _proceed = true;
            }
        };
        if (parameterSymbol != null)
        {
            applyOnParameter();
            if (_proceed)
                return;
        }

        {
            var membersVisitor = new GetMembersVisitor(this);
            membersVisitor.Visit(node.Expression);
            if ((parameterSymbol = membersVisitor._properties.ParameterSymbol) != null)
            {
                applyOnParameter();
                if (_proceed)
                    return;
            }
            AddProperties(membersVisitor._properties, _properties);
            PropertyDependence newLast;
            if (membersVisitor._properties.Last.PropertiesDependences.TryGetValue(propertySymbol.Name, out newLast))
            {
                AddProperties(newLast);
                _properties.Last = newLast.Last;
                _proceed = true;
                return;
            }
            if (systemProperty)
            {
                _proceed = true;
                return;
            }
            if (membersVisitor._properties.Dependences.Count != 0 || membersVisitor._properties.PropertiesDependences.Count != 0)
            {
                var dependencesList = new List<List<PropertySymbolInfo>>();
                foreach (var pd in membersVisitor._properties.Last.Dependences)
                {
                    var dependences = new List<PropertySymbolInfo>(pd);
                    dependences.Add(PropertySymbolInfo.Get(propertySymbol));
                    AddProperty(dependences);
                    dependencesList.Add(dependences);
                }
                _properties.Last = new PropertyDependence { Dependences = dependencesList };
                _proceed = true;
            }
        }
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        if (methodSymbol == null || !(methodSymbol.IsStatic || _specificationsElements.GetSpecificationEquivalentMethod(ref methodSymbol) || methodSymbol.ContainingNamespace.ToString() == "System.Linq"))
            return;
        var argumentExpressions = node.ArgumentList.Arguments.Select(a => a.Expression).ToList();
        var memberAccessExpression = node.Expression as MemberAccessExpressionSyntax;
        if (memberAccessExpression != null && (_semanticModel.GetSymbolInfo(memberAccessExpression.Expression).Symbol as ITypeSymbol) == null)
            argumentExpressions.Insert(0, memberAccessExpression.Expression);
        string methodSymbolString = methodSymbol.ToString();
        MethodDeclarationSyntax method;
        if (_methodPerMethodSymbols.TryGetValue(methodSymbolString, out method))
        {
            if (_alreadyCalledMethods.Contains(methodSymbol))
            {
                if (++_failed > MaxFailed)
                    return;
            }
            else
                _alreadyCalledMethods.Add(methodSymbol);
            if (_getMethods.Values.SelectMany(m => m).Contains(method))
            {
                var membersVisitor = new GetMembersVisitor(this);
                membersVisitor.Visit(argumentExpressions[0]);
                AddProperties(membersVisitor._properties);
                AddProperty(new List<PropertySymbolInfo>(LastOrDefault(membersVisitor._properties.Dependences))
                {
                    new PropertySymbolInfo(TypeSymbolInfo.Get(methodSymbol.ReturnType),
                        SpecificationMethods.GetPropertyNameFromMethod(method), TypeSymbolInfo.Get(methodSymbol.Parameters[0].Type),
                        method)
                });
            }
            else
            {
                var variables = new Dictionary<string, PropertyDependence>();
                int index = 0;
                foreach (var argumentExpression in argumentExpressions)
                {
                    var membersVisitor = new GetMembersVisitor(this);
                    membersVisitor.Visit(argumentExpression);
                    AddProperties(membersVisitor._properties);
                    if (membersVisitor._properties.Dependences.GroupBy(p => p.Count).All(g => g.Count() == 1))
                        variables.Add(methodSymbol.Parameters[index].Name, membersVisitor._properties);
                    index++;
                }
                {
                    var semanticModel = _semanticModelPerMethods[method];
                    var membersVisitor = new GetMembersVisitor(semanticModel, _specificationsElements,
                        _serverFxDALInterfacesNamespace, _semanticModelPerMethods, _methodPerMethodSymbols,
                        _getMethods, _extensionMethods, variables, _fromVariables, _linqIndex, _alreadyCalledMethods,
                        _definePropertyDependences, _failed);
                    membersVisitor._returnProperties = new PropertyDependence();
                    membersVisitor.Visit(method.Body);
                    AddProperties(membersVisitor._properties);
                    if (!(membersVisitor._returnProperties.Dependences.Count == 0 && membersVisitor._returnProperties.PropertiesDependences.Count == 0))
                        _properties.Last = membersVisitor._returnProperties;
                    _proceed = true;
                }
            }
        }
        else
        {
            if (methodSymbol.ContainingNamespace.ToString() == "System.Linq")
            {
                var membersVisitor = new GetMembersVisitor(this);
                membersVisitor.Visit(argumentExpressions[0]);
                if (membersVisitor._properties.Last != null)
                    _properties.Last = membersVisitor._properties.Last;
                AddProperties(membersVisitor._properties);
                Action<int, Action<PropertyDependence>> visitLambda = (argumentIndex, addProperties) =>
                {
                    var lambdaExpression = argumentExpressions[argumentIndex] as SimpleLambdaExpressionSyntax;
                    if (lambdaExpression != null)
                    {
                        var variables = new Dictionary<string, PropertyDependence>(_variables);
                        if (!variables.ContainsKey(lambdaExpression.Parameter.Identifier.ValueText))
                            variables.Add(lambdaExpression.Parameter.Identifier.ValueText, _properties);
                        else
                            variables[lambdaExpression.Parameter.Identifier.ValueText] = _properties;
                        membersVisitor = new GetMembersVisitor(this, variables);
                        membersVisitor._returnProperties = null;
                        membersVisitor.Visit(lambdaExpression.Body);
                        addProperties(membersVisitor._properties);
                        _proceed = true;
                    }
                };
                switch (argumentExpressions.Count)
                {
                    case 1:
                        _properties.Last = membersVisitor._properties.Last;
                        _proceed = true;
                        break;
                    case 2:
                        bool applyLast = false;
                        switch (methodSymbol.Name)
                        {
                            case "Where":
                            case "OrderBy":
                            case "OrderByDescending":
                            case "ThenBy":
                            case "ThenByDescending":
                            case "Take":
                            case "Skip":
                            case "First":
                            case "FirstOrDefault":
                            case "Last":
                            case "LastOrDefault":
                            case "Single":
                            case "SingleOrDefault":
                                _properties.Last = membersVisitor._properties.Last;
                                break;
                            case "GroupBy":
                                _properties.Last = membersVisitor._properties.Last;
                                visitLambda(1, pd =>
                                {
                                    if (_properties.PropertiesDependences.ContainsKey("Key"))
                                        _properties.PropertiesDependences["Key"] = pd;
                                    else
                                        _properties.PropertiesDependences.Add("Key", pd);
                                });
                                _properties.ResetLast();
                                return;
                            case "Union":
                            case "Intersect":
                                membersVisitor = new GetMembersVisitor(this);
                                membersVisitor.Visit(argumentExpressions[1]);
                                AddProperties(membersVisitor._properties);
                                AddProperties(membersVisitor._properties.Last, _properties.Last);
                                _proceed = true;
                                return;
                            default:
                                applyLast = true;
                                break;
                        }
                        visitLambda(1, pd =>
                        {
                            AddProperties(pd);
                            if (applyLast)
                                _properties.Last = pd.Last;
                        });
                        break;
                    case 3:
                        switch (methodSymbol.Name)
                        {
                            case "SelectMany":
                                var last = membersVisitor._properties.Last;
                                _properties.Last = last;
                                var collectionDependence = new PropertyDependence();
                                visitLambda(1, pd =>
                                {
                                    AddProperties(pd);
                                    AddProperties(pd, collectionDependence);
                                });
                                _properties.ResetLast();
                                var lambdaExpression = (ParenthesizedLambdaExpressionSyntax)argumentExpressions[2];
                                var variables = new Dictionary<string, PropertyDependence>(_variables);
                                var parameter = lambdaExpression.ParameterList.Parameters[0];
                                if (!variables.ContainsKey(parameter.Identifier.ValueText))
                                    variables.Add(parameter.Identifier.ValueText, last);
                                else
                                    variables[parameter.Identifier.ValueText] = last;
                                parameter = lambdaExpression.ParameterList.Parameters[1];
                                if (!variables.ContainsKey(parameter.Identifier.ValueText))
                                    variables.Add(parameter.Identifier.ValueText, collectionDependence.Last);
                                else
                                    variables[parameter.Identifier.ValueText] = collectionDependence.Last;
                                membersVisitor = new GetMembersVisitor(this, variables);
                                membersVisitor.Visit(lambdaExpression.Body);
                                AddProperties(membersVisitor._properties);
                                _properties.Last = membersVisitor._properties;
                                _proceed = true;
                                return;
                        }
                        break;
                    case 5:
                        switch (methodSymbol.Name)
                        {
                            case "Join":
                            case "GroupJoin":
                                var last = membersVisitor._properties.Last;
                                membersVisitor = new GetMembersVisitor(this);
                                membersVisitor.Visit(argumentExpressions[1]);
                                AddProperties(membersVisitor._properties);
                                var joinLast = membersVisitor._properties.Last;
                                _properties.Last = last;
                                visitLambda(2, pd => AddProperties(pd));
                                _proceed = false;
                                _properties.Last = joinLast;
                                visitLambda(3, pd => AddProperties(pd));
                                _proceed = false;
                                _properties.ResetLast();
                                var lambdaExpression = (ParenthesizedLambdaExpressionSyntax)argumentExpressions[4];
                                var variables = new Dictionary<string, PropertyDependence>(_variables);
                                var parameter = lambdaExpression.ParameterList.Parameters[0];
                                if (!variables.ContainsKey(parameter.Identifier.ValueText))
                                    variables.Add(parameter.Identifier.ValueText, last);
                                else
                                    variables[parameter.Identifier.ValueText] = last;
                                parameter = lambdaExpression.ParameterList.Parameters[1];
                                if (!variables.ContainsKey(parameter.Identifier.ValueText))
                                    variables.Add(parameter.Identifier.ValueText, joinLast);
                                else
                                    variables[parameter.Identifier.ValueText] = joinLast;
                                membersVisitor = new GetMembersVisitor(this, variables);
                                membersVisitor.Visit(lambdaExpression.Body);
                                AddProperties(membersVisitor._properties);
                                _properties.Last = membersVisitor._properties;
                                _proceed = true;
                                return;
                        }
                        break;
                }
            }
        }
    }

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        PropertyDependence identifierProperties;
        if (_variables.TryGetValue(node.Identifier.ValueText, out identifierProperties))
        {
            if (identifierProperties != null)
            {
                AddProperties(identifierProperties);
                _properties.ParameterSymbol = identifierProperties.ParameterSymbol;
            }
            _proceed = true;
        }
    }

    public override void VisitForEachStatement(ForEachStatementSyntax node)
    {
        var getInitializerMembersVisitor = new GetMembersVisitor(this);
        getInitializerMembersVisitor.Visit(node.Expression);
        var variables = new Dictionary<string, PropertyDependence>(_variables);
        variables.Add(node.Identifier.ValueText, getInitializerMembersVisitor._properties.Last);
        AddProperties(getInitializerMembersVisitor._properties);
        var statementVisitor = new GetMembersVisitor(this, variables);
        statementVisitor.Visit(node.Statement);
        AddProperties(statementVisitor._properties);
        AddReturnProperties(statementVisitor._returnProperties);
        _proceed = true;
    }

    public override void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
        foreach (var variable in node.Declaration.Variables)
            Visit(variable);
        _proceed = true;
    }

    public override void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
        PropertyDependence initializerProperties;
        if (node.Initializer == null)
            initializerProperties = new PropertyDependence();
        else
        {
            var parameter = _semanticModel.GetSymbolInfo(node.Initializer).Symbol as ParameterSymbol;
            if (parameter == null)
            {
                var getInitializerMembersVisitor = new GetMembersVisitor(this);
                getInitializerMembersVisitor.Visit(node.Initializer);
                initializerProperties = getInitializerMembersVisitor._properties;
                AddProperties(getInitializerMembersVisitor._properties);
            }
            else
                initializerProperties = new PropertyDependence { ParameterSymbol = parameter };
        }
        _variables.Add(node.Identifier.ValueText, initializerProperties);
        _proceed = true;
    }

    public override void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
        Visit(node.Value);
        _proceed = true;
    }

    public override void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
        var variable = node.Left as IdentifierNameSyntax;
        if (variable != null)
        {
            var variableName = variable.Identifier.ValueText;
            switch ((RoslynSyntaxKind)GetKind(node))
            {
                case RoslynSyntaxKind.AssignExpression:
                    PropertyDependence rightProperties;
                    if (_variables.TryGetValue(variableName, out rightProperties) && rightProperties != null)
                    {
                        rightProperties.Dependences.Clear();
                        rightProperties.PropertiesDependences.Clear();
                    }
                    goto case RoslynSyntaxKind.AddAssignExpression;
                case RoslynSyntaxKind.AddAssignExpression:
                case RoslynSyntaxKind.SubtractAssignExpression:
                case RoslynSyntaxKind.MultiplyAssignExpression:
                case RoslynSyntaxKind.DivideAssignExpression:
                case RoslynSyntaxKind.ModuloAssignExpression:
                    var getRightMembersVisitor = new GetMembersVisitor(this);
                    getRightMembersVisitor.Visit(node.Right);
                    AddProperties(getRightMembersVisitor._properties);
                    if (_variables.TryGetValue(variableName, out rightProperties))
                        AddProperties(getRightMembersVisitor._properties, rightProperties);
                    _proceed = true;
                    break;
                case RoslynSyntaxKind.AsExpression:
                    var parameter = _semanticModel.GetSymbolInfo(variable).Symbol as ParameterSymbol;
                    if (parameter != null)
                    {
                        _properties.ParameterSymbol = parameter;
                        _proceed = true;
                    }
                    break;
            }
        }
        if (!_proceed)
            switch (GetKind(node))
            {
                case SyntaxKind.AsExpression:
                    Visit(node.Left);
                    _proceed = true;
                    break;
            }
    }

    public override void VisitReturnStatement(ReturnStatementSyntax node)
    {
        var getReturnMembers = new GetMembersVisitor(this);
        getReturnMembers.Visit(node.Expression);
        AddProperties(getReturnMembers._properties);
        AddReturnProperties(getReturnMembers._properties);

        _proceed = true;
    }

    public override void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
        var getConditionMembers = new GetMembersVisitor(this);
        getConditionMembers.Visit(node.Condition);
        AddProperties(getConditionMembers._properties);

        var getWhenTrueMembers = new GetMembersVisitor(this);
        getWhenTrueMembers.Visit(node.WhenTrue);
        AddProperties(getWhenTrueMembers._properties);

        var getWhenFalseMembers = new GetMembersVisitor(this);
        getWhenFalseMembers.Visit(node.WhenFalse);
        AddProperties(getWhenFalseMembers._properties);

        var last = new PropertyDependence();
        AddProperties(getWhenFalseMembers._properties.Last, last);
        AddProperties(getWhenTrueMembers._properties.Last, last);
        _properties.Last = last;

        _proceed = true;
    }

    private List<PropertySymbolInfo> LastOrDefault(List<List<PropertySymbolInfo>> properties)
    {
        return properties == null
            ? new List<PropertySymbolInfo>()
            : (properties.LastOrDefault() ?? new List<PropertySymbolInfo>());
    }

    private string GetPropertyName(List<PropertySymbolInfo> property)
    {
        var sb = new StringBuilder();
        foreach (var p in property)
        {
            sb.Append(p.Name);
            sb.Append(".");
        }
        return sb.ToString();
    }

    private void AddProperty(List<PropertySymbolInfo> property, List<List<PropertySymbolInfo>> properties = null)
    {
        if (properties == null)
            properties = _properties.Dependences;
        if (property == null)
            return;
        var propertyName = GetPropertyName(property);
        if (!properties.Any(p => GetPropertyName(p) == propertyName))
        {
            property = property.Select(p =>
            {
                List<string> classes;
                TypeSymbol typeSymbol;
                if (_specificationsElements.ClassesPerInterfaces.TryGetValue(p.ContainingType.FullName, out classes) && _specificationsElements.TypeSymbols.TryGetValue(classes.Single(), out typeSymbol))
                {
                    var propertySymbol = (PropertySymbol)typeSymbol.GetMembers(p.Name).FirstOrDefault();
                    if (propertySymbol != null)
                        return new PropertySymbolInfo(propertySymbol);
                }
                return p;
            }).ToList();
            properties.Add(property);
        }
    }

    private void AddProperties(IEnumerable<List<PropertySymbolInfo>> addedProperties, List<List<PropertySymbolInfo>> properties = null)
    {
        foreach (var property in addedProperties)
        {
            AddProperty(property, properties);
            foreach (var p in property)
                p.FromOriginalMethod = _fromOriginalMethod;
        }
    }

    private void AddProperties(PropertyDependence addedProperties, PropertyDependence properties = null)
    {
        if (properties == null)
            properties = _properties;
        if (addedProperties.Error || properties.Error)
        {
            properties.Error = true;
            return;
        }
        AddProperties(addedProperties.Dependences, properties.Dependences);
        foreach (var addedPropertyDependences in addedProperties.PropertiesDependences)
        {
            PropertyDependence propertyDependences, last = null;
            if (!properties.PropertiesDependences.TryGetValue(addedPropertyDependences.Key, out propertyDependences))
                properties.PropertiesDependences.Add(addedPropertyDependences.Key, propertyDependences = new PropertyDependence());
            else
            {
                last = propertyDependences.Last;
                propertyDependences.ResetLast();
            }
            AddProperties(addedPropertyDependences.Value, propertyDependences);
            if (last != null)
            {
                AddProperties(propertyDependences.Last, last);
                propertyDependences.Last = last;
            }
        }
    }

    private void AddReturnProperties(PropertyDependence addedProperties)
    {
        if (addedProperties == null)
            return;
        if (_returnProperties == null)
            _returnProperties = new PropertyDependence();
        AddProperties(addedProperties.Last, _returnProperties);
    }
}

class PropertyDependence
{
    private PropertyDependence _last;
    public PropertyDependence Last
    {
        get
        {
            if (_last == null)
            {
                _last = new PropertyDependence { Dependences = new List<List<PropertySymbolInfo>>(), PropertiesDependences = new Dictionary<string, PropertyDependence>(PropertiesDependences) };
                if (Dependences.Count != 0)
                    _last.Dependences.Add(Dependences.Last());
            }
            return _last;
        }
        set { _last = value; }
    }

    public void ResetLast()
    {
        _last = null;
    }

    public ParameterSymbol ParameterSymbol { get; set; }

    private List<List<PropertySymbolInfo>> _dependences;
    public List<List<PropertySymbolInfo>> Dependences
    {
        get { return _dependences ?? (_dependences = new List<List<PropertySymbolInfo>>()); }
        set { _dependences = value; }
    }

    private Dictionary<string, PropertyDependence> _propertiesDependences;
    public Dictionary<string, PropertyDependence> PropertiesDependences
    {
        get { return _propertiesDependences ?? (_propertiesDependences = new Dictionary<string, PropertyDependence>()); }
        set { _propertiesDependences = value; }
    }

    public bool Error { get; set; }
}

public class DefinePropertyDependencesMethodVisitor : SyntaxVisitor
{
    private SpecificationsElements _specificationsElements;
    private ISemanticModel _semanticModel;
    private List<PropertySymbolInfo> _currentProperties;
    private bool _proceed;

    public DefinePropertyDependencesMethodVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel)
        : this(specificationsElements, semanticModel, new List<List<PropertySymbolInfo>>())
    {
    }
    public DefinePropertyDependencesMethodVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, List<List<PropertySymbolInfo>> properties)
    {
        _specificationsElements = specificationsElements;
        _semanticModel = semanticModel;
        Properties = properties;
    }

    public List<List<PropertySymbolInfo>> Properties { get; private set; }

    public override void Visit(SyntaxNode node)
    {
        base.Visit(node);
        if (! _proceed)
            foreach (var childNode in node.ChildNodes())
                Visit(childNode);
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        Visit(node.Expression);
        var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        MethodDeclarationSyntax method;
        if ((methodSymbol.IsStatic || _specificationsElements.GetSpecificationEquivalentMethod(ref methodSymbol)) && _specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method))
        {
            var propertySymbolInfo = new PropertySymbolInfo(TypeSymbolInfo.Get(methodSymbol.ReturnType), SpecificationMethods.GetPropertyNameFromMethod(method), TypeSymbolInfo.Get(methodSymbol.Parameters[0].Type), method);
            _currentProperties.Add(propertySymbolInfo);
            Properties.Add(_currentProperties.ToList());
            _proceed = true;
            return;
        }
        var lambda = node.ArgumentList.Arguments[0].Expression as SimpleLambdaExpressionSyntax;
        if (lambda == null)
            throw new NotImplementedException();
        var childDefinePropertyDependencesMethodVisitor = new DefinePropertyDependencesMethodVisitor(_specificationsElements, _semanticModel, Properties);
        childDefinePropertyDependencesMethodVisitor._currentProperties = _currentProperties == null ? new List<PropertySymbolInfo>() : _currentProperties.ToList();
        childDefinePropertyDependencesMethodVisitor.Visit(lambda.Body);
        _proceed = true;
    }

    public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        var propertySymbol = _semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol;
        if (propertySymbol == null)
        {
            base.VisitMemberAccessExpression(node);
            return;
        }
        Visit(node.Expression);
        var propertySymbolInfo = new PropertySymbolInfo(propertySymbol);
        _currentProperties.Add(propertySymbolInfo);
        Properties.Add(_currentProperties.ToList());
        _proceed = true;
    }
}

string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, SyntaxNode> transformNodes, string parameters, out bool isValid)
{
    bool hasLambda;
    return ToExpression(method, specificationsElements, transformNodes, parameters, out isValid, false, out hasLambda);
}
string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, SyntaxNode> transformNodes, string parameters, out bool isValid, bool validateMethod, out bool hasLambda)
{
    return ToExpression(method, specificationsElements, (n, _) => transformNodes(n), parameters, out isValid, validateMethod, out hasLambda);
}
string ToExpression(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> transformNodes, string parameters, out bool isValid, bool validateMethod, out bool hasLambda)
{
    var toExpression = new ToExpressionRewriter(specificationsElements.SemanticModelPerMethods[method], specificationsElements, parameters, transformNodes);
    SyntaxNode exp;
    var firstStatement = ((BlockSyntax)toExpression.Visit(method.Body)).Statements[0];
    var body = firstStatement as ReturnStatementSyntax;
    if (body == null)
    {
        hasLambda = false;
        IfStatementSyntax ifStatement;
        if (! validateMethod || (ifStatement = firstStatement as IfStatementSyntax) == null)
        {
            isValid = false;
            return null;
        }
        exp = ifStatement.Condition;
    }
    else
    {
        exp = body.Expression;
        hasLambda = true;
    }
    var value = exp.NormalizeWhitespace().ToString();
    isValid = toExpression.IsValid;
    return value;
}

public class ToExpressionRewriter : SpecificationsRewriter
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _parameterName;

    public ToExpressionRewriter(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string parameterName, Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> transformNodes)
        : base(transformNodes)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _parameterName = parameterName;
        IsValid = true;
    }

    public bool IsValid { get; private set; }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
        return SyntaxFactory.ParseStatement(string.Concat("return (", _parameterName, ") => ", Visit(node.Expression).NormalizeWhitespace().ToString(), ";"));
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var method = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        if (! (Regex.IsMatch(method.ContainingNamespace.ToString(), "^System(.|$)") || _specificationsElements.MethodPerMethodSymbols.Keys.Any(mp => mp.Equals(method))))
            IsValid = false;
        return base.VisitInvocationExpression(node);
    }
}

public class GetCalledMethodsVisitor : SyntaxVisitorOfIEnumerableOfMethodDeclarationSyntax
{
    private SpecificationsElements _specificationsElements;
    private ISemanticModel _semanticModel;
    private List<MethodDeclarationSyntax> _methods;

    public GetCalledMethodsVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel)
        : this(specificationsElements, semanticModel, new List<MethodDeclarationSyntax>())
    {
    }
    private GetCalledMethodsVisitor(SpecificationsElements specificationsElements, ISemanticModel semanticModel, List<MethodDeclarationSyntax> methods)
    {
        _specificationsElements = specificationsElements;
        _semanticModel = semanticModel;
        _methods = methods;
        UnfoundMethods = new List<MethodSymbol>();
    }

    public List<MethodSymbol> UnfoundMethods { get; private set; }

    public override IEnumerable<MethodDeclarationSyntax> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new MethodDeclarationSyntax[0]).Union(node.ChildNodes().SelectMany(c => Visit(c)));
    }

    public override IEnumerable<MethodDeclarationSyntax> VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var methodSymbol = _semanticModel.GetSymbolInfo(node).Symbol as MethodSymbol;
        MethodDeclarationSyntax method;
        if (methodSymbol != null && (methodSymbol.IsStatic || _specificationsElements.GetSpecificationEquivalentMethod(ref methodSymbol)) && _specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method) && ! _methods.Contains(method))
        {
            _methods.Add(method);
            yield return method;
            foreach (var m in new GetCalledMethodsVisitor(_specificationsElements, _specificationsElements.SemanticModelPerMethods[method], _methods).Visit(method))
                yield return m;
        }
        else
            UnfoundMethods.Add(methodSymbol);
        var ms = base.VisitInvocationExpression(node);
        if (ms != null)
            foreach (var m in ms)
                yield return m;
    }
}

public class PropertySymbolInfo
{
    private PropertySymbolInfo()
    {
    }

    public PropertySymbolInfo(TypeSymbolInfo type, string name, TypeSymbolInfo containingType, MethodDeclarationSyntax method = default(MethodDeclarationSyntax))
    {
        Type = type;
        Name = name;
        ContainingType = containingType;
        GetMethod = method;
    }

    public PropertySymbolInfo(PropertySymbol propertySymbol)
    {
        PropertySymbol = propertySymbol;
        Type = new TypeSymbolInfo(propertySymbol.Type);
        Name = propertySymbol.Name;
        ContainingType = new TypeSymbolInfo(propertySymbol.ContainingType);
    }

    public static PropertySymbolInfo Get(Dictionary<string, object> cache)
    {
        var propertySymbol = (PropertySymbol)cache["PropertySymbol"];
        PropertySymbolInfo value;
        if (propertySymbol != null)
            value = new PropertySymbolInfo(propertySymbol);
        else
            value = new PropertySymbolInfo(TypeSymbolInfo.Get((Dictionary<string, object>)cache["Type"]), (string)cache["Name"], TypeSymbolInfo.Get((Dictionary<string, object>)cache["ContainingType"]), (MethodDeclarationSyntax)cache["GetMethod"]);
        value.FromOriginalMethod = (bool)cache["FromOriginalMethod"];
        return value;
    }

    public Dictionary<string, object> ToCache()
    {
        var value = new Dictionary<string, object>();
        value.Add("PropertySymbol", PropertySymbol);
        if (PropertySymbol == null)
        {
            value.Add("Type", Type.ToCache());
            value.Add("Name", Name);
            value.Add("ContainingType", ContainingType.ToCache());
            value.Add("GetMethod", GetMethod);
        }
        value.Add("FromOriginalMethod", FromOriginalMethod);
        return value;
    }

    public PropertySymbol PropertySymbol { get; private set; }
    public TypeSymbolInfo Type { get; private set; }
    public string Name { get; private set; }
    public TypeSymbolInfo ContainingType { get; set; }
    public bool FromOriginalMethod { get; set; }
    public MethodDeclarationSyntax GetMethod { get; private set; }

    public override string ToString()
    {
        return Name;
    }

    public static PropertySymbolInfo Get(PropertySymbol propertySymbol)
    {
        return new PropertySymbolInfo(propertySymbol);
    }
}

public class TypeSymbolInfo
{
    private TypeSymbolInfo()
    {
    }

    public TypeSymbolInfo(TypeSymbol typeSymbol)
    {
        TypeSymbol = typeSymbol;
        Name = typeSymbol.Name;
        FullName = typeSymbol.ToString();
        ContainingNamespace = typeSymbol.ContainingNamespace == null ? null : typeSymbol.ContainingNamespace.ToString();
        AllInterfaces = GetAllInterfaces(typeSymbol);
        TypeArguments = GetTypeArguments(typeSymbol);
    }

    public static TypeSymbolInfo Get(Dictionary<string, object> cache)
    {
        return new TypeSymbolInfo((TypeSymbol)cache["TypeSymbol"]);
    }

    public Dictionary<string, object> ToCache()
    {
        return new Dictionary<string, object>() { {"TypeSymbol", TypeSymbol} };
    }

    public static IEnumerable<TypeSymbolInfo> GetAllInterfaces(TypeSymbol typeSymbol)
    {
        return typeSymbol.AllInterfaces.OfType<TypeSymbol>().Select(i => new TypeSymbolInfo(i));
    }
    public static TypeSymbolInfo[] GetTypeArguments(TypeSymbol typeSymbol)
    {
        var namedTypeSymbol = typeSymbol as NamedTypeSymbol;
        return namedTypeSymbol == null ? new TypeSymbolInfo[0] : namedTypeSymbol.TypeArguments.OfType<TypeSymbol>().Select(i => new TypeSymbolInfo(i)).ToArray();
    }

    public static string GetBasicTypeName(TypeSymbol type, Func<TypeSymbol, TypeSymbol> transformType = null)
    {
        return GetBasicTypeNameInternal(type, transformType);
    }
    private static string GetBasicTypeNameInternal(TypeSymbol type, Func<TypeSymbol, TypeSymbol> transformType)
    {
        if (transformType != null)
            type = transformType(type);
        var namedTypeSymbol = type as NamedTypeSymbol;
        if (namedTypeSymbol == null || ! namedTypeSymbol.TypeArguments.Any())
            return type.Name;
        return string.Concat(type.Name, "<", namedTypeSymbol.TypeArguments.OfType<TypeSymbol>().Select(ta => GetBasicTypeNameInternal(ta, transformType)).Aggregate((t1, t2) => string.Concat(t1, ",", t2)), ">");
    }

    public TypeSymbol TypeSymbol { get; private set; }
    public string Name { get; private set; }
    public string FullName { get; private set; }
    public string ContainingNamespace { get; private set; }
    public IEnumerable<TypeSymbolInfo> AllInterfaces { get; private set; }
    public TypeSymbolInfo[] TypeArguments { get; private set; }

    public override string ToString()
    {
        return FullName;
    }

    public static TypeSymbolInfo Get(TypeSymbol typeSymbol)
    {
        return new TypeSymbolInfo(typeSymbol);
    }
}

public class DTOAndInterfacesTypesRewriter : TypeRewriter
{
    private Dictionary<string, string> _namespacesReplacement;

    public DTOAndInterfacesTypesRewriter(ISemanticModel semanticModel, SpecificationsElements specificationsElements, IEnumerable<TypeSymbol> dtoTypes, Dictionary<string, string> namespacesReplacement = null)
        : base(semanticModel)
    {
        SpecificationsElements = specificationsElements;
        DTOTypes = dtoTypes;
        _namespacesReplacement = namespacesReplacement;
        GetNameSyntaxFunc = nameSyntax =>
            {
                TypeSyntax t = nameSyntax;
                if (SpecificationsElements != null && SpecificationsElements.ReplaceInterface(ref t, SemanticModel, withInterfaceSpecifications:true))
                    return (NameSyntax)t;
                var typeSymbol = semanticModel.GetSymbolInfo(nameSyntax).Symbol;
                if (typeSymbol is MethodSymbol) // ctor
                    typeSymbol = typeSymbol.ContainingType;
                if (typeSymbol != null)
                {
                    var dtoTypeName = typeSymbol.ToString();
                    if (DTOTypes.Any(dt => dt.ToString() == dtoTypeName))
                        return SyntaxFactory.ParseName(typeSymbol.Name);
                }
                string @namespace;
                if (_namespacesReplacement != null && _namespacesReplacement.TryGetValue(typeSymbol.ContainingNamespace.ToString(), out @namespace))
                    return (NameSyntax)SyntaxFactory.ParseTypeName(string.Concat(@namespace, ".", typeSymbol.Name));

                return (NameSyntax)t;
            };
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
        string @namespace;
        if (_namespacesReplacement != null && _namespacesReplacement.TryGetValue(node.Name.ToString(), out @namespace))
            return SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(@namespace));
        return node;
    }

    protected SpecificationsElements SpecificationsElements { get; private set; }
    protected IEnumerable<TypeSymbol> DTOTypes { get; private set; }
}

public abstract class SpecificationMethodBodyRewriter : DTOAndInterfacesTypesRewriter
{
    private List<List<PropertySymbolInfo>> _dependentProperties;
    private bool _return;
    private bool _returnNewError;
    private bool _hasErrorDetails;
    private bool _hasKey;
    private string _validateMethodName;

    public SpecificationMethodBodyRewriter(SpecificationsElements specificationsElements, List<List<PropertySymbolInfo>> dependentProperties, ISemanticModel semanticModel, IEnumerable<TypeSymbol> dtoTypes, string serverFxServiceInterfacesNamespace, Dictionary<string, string> namespacesReplacement = null)
        : base(semanticModel, specificationsElements, dtoTypes, namespacesReplacement)
    {
        _dependentProperties = dependentProperties;
        ServerFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
    }

    protected string ServerFxServiceInterfacesNamespace { get; private set; }


    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (node.Identifier.ValueText.StartsWith("Validate"))
            _validateMethodName = node.Identifier.ValueText;
        else
            _validateMethodName = null;
        return base.VisitMethodDeclaration(node);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
        _return = true;
        var value = (ReturnStatementSyntax)base.VisitReturnStatement(node);
        if (_validateMethodName != null && node.Expression is ObjectCreationExpressionSyntax)
            return SyntaxFactory.Block(
                SyntaxFactory.LocalDeclarationStatement(SyntaxFactory.VariableDeclaration(SyntaxFactory.IdentifierName("var"), SyntaxFactory.SeparatedList(new [] { SyntaxFactory.VariableDeclarator("@value").WithInitializer(SyntaxFactory.EqualsValueClause(value.Expression))}, new SyntaxToken[0]))),
                SyntaxFactory.ParseStatement(string.Concat(value.Expression is ObjectCreationExpressionSyntax ? "" : "if (@value != null) ", "@value.Key = \"", _validateMethodName, "\";")),
                SyntaxFactory.ReturnStatement(SyntaxFactory.IdentifierName("@value")));
        return value;
    }

    protected virtual string GetDataTransfertEntityKeyParameter()
    {
        return "";
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        if (_return)
            _returnNewError = SemanticModel.GetSymbolInfo(node).Symbol.ContainingType.ToString() == ServerFxServiceInterfacesNamespace + ".Error";
        var value = ((ObjectCreationExpressionSyntax)base.VisitObjectCreationExpression(node)).WithType((TypeSyntax)Visit(node.Type));
        if (_returnNewError)
        {
            var initializers = new List<BinaryExpressionSyntax>();
            if (!_hasErrorDetails && _dependentProperties != null && _dependentProperties.Count != 0)
            {
                var dependentProperties = _dependentProperties.Select(ps => ps.Select(p => p.Name).Aggregate((p1, p2) => string.Concat(p1, ".", p2)));
                var ifParent = node.Parent.Parent as IfStatementSyntax;
                if (ifParent != null)
                {
                    string ifConditionString = ifParent.Condition.ToString();
                    dependentProperties = dependentProperties.Where(p => ifConditionString.Contains(p));
                }
                initializers.Add(SyntaxFactory.BinaryExpression(SyntaxKindAssignExpression, SyntaxFactory.IdentifierName("ErrorDetails"), SyntaxFactory.ParseExpression(string.Concat("new ErrorDetail[] { ", dependentProperties.Select(p => string.Concat("new ErrorDetail { EntityKey = ", GetDataTransfertEntityKeyParameter(), "DataTransferEntityKey, PropertyName = \"", p, "\" }")).Aggregate((ps1, ps2) => string.Concat(ps1, ", ", ps2)), " }"))));
            }
            if (! _hasKey && _validateMethodName != null)
                initializers.Add(SyntaxFactory.BinaryExpression(SyntaxKindAssignExpression, SyntaxFactory.IdentifierName("Key"), SyntaxFactory.ParseExpression(string.Concat("\"", _validateMethodName, "\""))));
            if (initializers.Count != 0)
                return SyntaxFactory.ObjectCreationExpression(node.Type).WithInitializer(SyntaxFactory.InitializerExpression(SyntaxKind.ObjectInitializerExpression, SyntaxFactory.SeparatedList(value.Initializer.Expressions.Union(initializers), value.Initializer.Expressions.Union(initializers.Skip(1)).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken)))));
        }
        return value;
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
        IdentifierNameSyntax nodeIdentifier;
        if (_returnNewError && (nodeIdentifier = node.Left as IdentifierNameSyntax) != null)
            switch (nodeIdentifier.Identifier.ValueText)
            {
                case "ErrorDetails":
                    _hasErrorDetails = true;
                    break;
                case "Key":
                    _hasKey = true;
                    break;
            }
        return base.VisitBinaryExpression(node);
    }
}

public class SpecificationsRewriter : SyntaxRewriter
{
    private Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> _nodeRewriter;
    public SpecificationsRewriter(Func<SyntaxNode, Func<SyntaxNode, SyntaxNode>, SyntaxNode> nodeRewriter)
    {
        _nodeRewriter = nodeRewriter;
    }

    public override SyntaxNode Visit(SyntaxNode node)
    {
        var newNode = _nodeRewriter(node, n => Visit(n));
        if (newNode == node)
            return base.Visit(node);
        return newNode;
    }
}

public class UsingVisitor : SyntaxVisitor
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _entitiesNamespace;
    private SpecificationsElements.Type _type;
    private bool _done;
    private Func<MethodDeclarationSyntax, SpecificationsElements.MethodAnalizing> _analyzeMethod;
    private List<string> _usings = new List<string>();
    private bool _dal;
    private bool _service;
    private Func<ITypeSymbol, string> _getNamespaceFromTypeSymbol;
    private Func<IMethodSymbol, string> _getNamespaceFromMethodSymbol;
    private List<string> _keys;
    private Dictionary<string, List<string>> _usedUsings = new Dictionary<string, List<string>>();
    private string _currentNamespace;
    private string _className;
    private List<string> _specificationNamespaces; 

    public UsingVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string serverFxSpecificationsNamespace, string serverFxDALInterfacesNamespace, string serverFxServiceInterfacesNamespace, string entitiesNamespace, SpecificationsElements.Type type, List<string> specificationNamespaces, Func<MethodDeclarationSyntax, SpecificationsElements.MethodAnalizing> analyzeMethod = null, Dictionary<string, List<string>> usedUsings = null, bool dal = false, bool service = false, Func<ITypeSymbol, string> getNamespaceFromTypeSymbol = null, Func<IMethodSymbol, string> getNamespaceFromMethodSymbol = null)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _entitiesNamespace = entitiesNamespace;
        _type = type;
        _analyzeMethod = analyzeMethod ?? (m => SpecificationsElements.MethodAnalizing.Method);
        _usedUsings = usedUsings ?? new Dictionary<string, List<string>>();
        _dal = dal;
        _service = service;
        _getNamespaceFromTypeSymbol = getNamespaceFromTypeSymbol;
        _getNamespaceFromMethodSymbol = getNamespaceFromMethodSymbol;
        _specificationNamespaces = specificationNamespaces;
    }

    public Dictionary<string, List<string>> UsedUsings
    {
        get { return _usedUsings; }
    }

    public override void Visit(SyntaxNode node)
    {
        _done = false;
        base.Visit(node);
        if (!_done)
            foreach (var childNode in node.ChildNodes())
                Visit(childNode);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        _className = _semanticModel.GetDeclaredSymbol(node).ToString();
        base.VisitClassDeclaration(node);
    }

    public override void VisitAttributeList(AttributeListSyntax node)
    {
        _done = true;
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        var method = _specificationsElements.GetAndAddMethodSymbol(node, _semanticModel);
        if (_specificationsElements.IsDefineMethod(node, method, _semanticModel))
        {
            foreach (var statement in node.Body.Statements.OfType<ExpressionStatementSyntax>())
            {
                var invocationStatement = statement.Expression as InvocationExpressionSyntax;
                MemberAccessExpressionSyntax memberAccess;
                GenericNameSyntax genericName;
                if (invocationStatement != null && (memberAccess = invocationStatement.Expression as MemberAccessExpressionSyntax) != null && (genericName = memberAccess.Expression as GenericNameSyntax) != null && genericName.TypeArgumentList.Arguments.Count == 1)
                {
                    _keys = new List<string>();
                    var entity = (ITypeSymbol)_semanticModel.GetSymbolInfo(genericName.TypeArgumentList.Arguments[0]).Symbol;
                    List<string> classes;
                    if (_specificationsElements.ClassesPerInterfaces.TryGetValue(entity.ToString(), out classes))
                        foreach (var @class in classes)
                            _keys.Add(@class);
                    else
                        _keys.Add(entity.Name);
                    Visit(invocationStatement.ArgumentList.Arguments[1]);
                }
            }
            _done = true;
            return;
        }
        if (_dal)
        {
            _keys = new List<string>();
            SetKeyWithEntityClass(_specificationsElements, node, method);

            bool isValidateMethod = false;
            if (_type != SpecificationsElements.Type.UnitTest && ((isValidateMethod = _specificationsElements.ValidateMethods.SelectMany(kvp => kvp.Value).Contains(node)) || node.Body.Statements.Count != 1))
            {
                VisitMethodSignature(node);
                if (isValidateMethod)
                {
                    IfStatementSyntax ifStatement;
                    if ((ifStatement = node.Body.Statements[0] as IfStatementSyntax) != null && (node.Body.Statements.Count == 1 || node.Body.Statements.Count == 2 && node.Body.Statements[1] is ReturnStatementSyntax))
                        Visit(ifStatement.Condition);
                }
                _done = true;
            }
        }
        else
            switch (_analyzeMethod(node))
            {
                case SpecificationsElements.MethodAnalizing.Method:
                    SetKeyMethodDeclarationAndVisitService(_specificationsElements, node, method, true);
                    break;
                case SpecificationsElements.MethodAnalizing.Signature:
                    SetKeyMethodDeclarationAndVisitService(_specificationsElements, node, method, false);
                    if (! _done)
                        VisitMethodSignature(node);
                    _done = true;
                    return;
                default:
                    _done = true;
                    return;
            }
        base.VisitMethodDeclaration(node);
    }

    private void SetKeyMethodDeclarationAndVisitService(SpecificationsElements specificationsElements, MethodDeclarationSyntax node, MethodSymbol method, bool entity)
    {
        _keys = new List<string>();
        bool contextAsParameter = specificationsElements.HasContextOrServiceAsParameter(method);
        bool? serviceMethod = null;
        if (entity && ! _dal)
            if (contextAsParameter || (serviceMethod = _specificationsElements.ServiceMethods.Contains(node)).Value)
            {
                if (contextAsParameter)
                {
                    SetKeyWithEntityClass(_specificationsElements, node, method);
                    VisitMethodSignature(node);
                    entity = false;
                }
                else
                {
                    _keys.Add("@Service");
                    _keys.Add("@ServiceContract");
                }
            }
        if (entity)
            SetKeyWithEntityClass(_specificationsElements, node, method);
        if (_specificationsElements.ValidateMethods.SelectMany(kvp => kvp.Value).Contains(node))
            _keys.Add("@Service");
        if (! entity)
        {
            if (serviceMethod ?? _specificationsElements.ServiceMethods.Contains(node))
            {
                _keys.Add("@ServiceContract");
                VisitMethodSignature(node);
            }
            if (_type != SpecificationsElements.Type.Client || _specificationsElements.IsApplicableOnClient(node))
                _keys = new List<string>() { "@Service" };
            else
            {
                if (_type == SpecificationsElements.Type.Client)
                    _keys = new List<string>() { "@Service" };
                VisitMethodSignature(node);
                _done = true;
                return;
            }
        }
        _done = false;
    }

    private void SetKeyWithEntityClass(SpecificationsElements specificationsElements, MethodDeclarationSyntax method, MethodSymbol methodSymbol)
    {
        if (_type == SpecificationsElements.Type.UnitTest && ! _dal)
        {
            _keys = new List<string>() { _className };
            return;
        }
        bool dontGenerateMethodBody = (_type == SpecificationsElements.Type.Client) ? ! _specificationsElements.IsApplicableOnClient(method) : (specificationsElements.HasContextAsParameter(methodSymbol) && ! _dal);
        List<string> oldKeys = null;
        if (dontGenerateMethodBody)
        {
            oldKeys = _keys;
            _keys = new List<string>();
        }
        if (methodSymbol.IsExtensionMethod)
        {
            var entity = methodSymbol.Parameters[0].Type;
            List<string> classes;
            if (_specificationsElements.ClassesPerInterfaces.TryGetValue(entity.ToString(), out classes))
            {
                var keys = _keys;
                bool done = _done;
                _keys = new List<string>() { entity.ToString() };
                VisitMethodSignature(method);
                _done = done;
                _keys = keys;
                foreach (var @class in classes)
                    _keys.Add(@class);
            }
            else if (entity.TypeKind != TypeKind.Class)
                _keys.Add("@Other");
            else
                _keys.Add(entity.Name);
        }
        else
            _keys.Add("@Other");
        if (dontGenerateMethodBody)
        {
            VisitMethodSignature(method);
            _keys = oldKeys;
        }
    }

    public void VisitMethodSignature(MethodDeclarationSyntax node)
    {
        Visit(node.ReturnType);
        Visit(node.ParameterList);
        foreach (var cc in node.ConstraintClauses)
            Visit(cc);
    }

    public override void VisitUsingDirective(UsingDirectiveSyntax node)
    {
        _usings.Add(node.Name.GetText().ToString());
        _done = true;
    }

    private void AddUsing(string @using)
    {
        if (@using == "<global namespace>" || @using == _specificationsElements.ServerFxDALInterfacesNamespace || @using == _specificationsElements.ServerFxServiceInterfacesNamespace && _type == SpecificationsElements.Type.Client || @using == _entitiesNamespace || @using == _currentNamespace)
            return ;
        if (_keys != null)
            foreach (var key in _keys)
                AddUsing(key, @using);
        if (_className != null)
            AddUsing(_className, @using);
    }

    private void AddUsing(string key, string @using)
    {
        if (_specificationNamespaces.Contains(@using))
            return;
        List<string> usings;
        if (! UsedUsings.TryGetValue(key, out usings))
            UsedUsings.Add(key, usings = new List<string>());
        else if (usings.Contains(@using))
            return;
        usings.Add(@using);
    }

    private void VisitName(NameSyntax node)
    {
        var typeSymbol = _semanticModel.GetSymbolInfo(node).Symbol as TypeSymbol;
        if (typeSymbol != null)
        {
            string namespaceName;
            bool isIEntity = typeSymbol.GetAttributes().Any(a => a.ToString() == _specificationsElements.ServerFxSpecificationsNamespace + ".IEntityAttribute");
            if (_type == SpecificationsElements.Type.UnitTest || ! isIEntity)
            {
                if (_getNamespaceFromTypeSymbol == null || (namespaceName = _getNamespaceFromTypeSymbol(typeSymbol)) == null)
                {
                    if (typeSymbol.ContainingNamespace == null)
                    {
                        _done = true;
                        return;
                    }
                }
            }
            if (! isIEntity)
            {
                namespaceName = typeSymbol.ContainingNamespace.ToString();
                AddUsing(namespaceName);
            }
        }
        _done = true;
    }

    public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        if (_service)
            base.VisitPropertyDeclaration(node);
        else
            _done = true;
    }

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        VisitName(node);
    }

    public override void VisitQualifiedName(QualifiedNameSyntax node)
    {
        VisitName(node);
    }

    public override void VisitGenericName(GenericNameSyntax node)
    {
        VisitName(node);
        foreach (var t in node.TypeArgumentList.Arguments)
            Visit(t);
    }

    public override void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var memberAccessExpressionSyntax = node.Expression as MemberAccessExpressionSyntax;
        if (memberAccessExpressionSyntax != null)
        {
            MethodSymbol methodSymbol;
            if (memberAccessExpressionSyntax.Expression != null && (methodSymbol = _semanticModel.GetSymbolInfo(memberAccessExpressionSyntax).Symbol as MethodSymbol) != null && (methodSymbol = methodSymbol.ConstructedFrom.ReducedFrom ?? methodSymbol) != null)
            {
                if (methodSymbol.IsExtensionMethod)
                {
                    var methodSymbolString = methodSymbol.ToString();
                    if (! _specificationsElements.MethodPerMethodSymbols.Keys.Any(m => m.ToString() == methodSymbolString))
                    {
                        string namespaceName;
                        if (_getNamespaceFromMethodSymbol == null || (namespaceName = _getNamespaceFromMethodSymbol(methodSymbol)) == null)
                            namespaceName = methodSymbol.ContainingNamespace.ToString();
                        AddUsing(namespaceName);
                    }
                }
                if ((_dal || _type == SpecificationsElements.Type.UnitTest) && methodSymbol.IsStatic)
                    {
                        foreach (var p in methodSymbol.Parameters)
                            AddUsing(p.Type);
                        if (! methodSymbol.ReturnsVoid)
                            AddUsing(methodSymbol.ReturnType);
                    }
            }
        }
        base.VisitInvocationExpression(node);
    }

    private void AddUsing(TypeSymbol type)
    {
        if (type != null)
        {
            if (type.ContainingNamespace != null)
                AddUsing(type.ContainingNamespace.ToString());
            var namedTypeSymbol = type as NamedTypeSymbol;
            if (! (namedTypeSymbol == null || namedTypeSymbol.TypeArguments == null))
                foreach (var t in namedTypeSymbol.TypeArguments)
                    AddUsing(t);
        }
    }

    public override void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        var typeSymbol = _semanticModel.GetTypeInfo(node).Type;
        if (typeSymbol == null)
            typeSymbol = _semanticModel.GetTypeInfo(node.Type).Type;
        string namespaceName;
        if (_getNamespaceFromTypeSymbol == null || (namespaceName = _getNamespaceFromTypeSymbol(typeSymbol)) == null)
            namespaceName = typeSymbol.ContainingNamespace.ToString();
        AddUsing(namespaceName);
        base.VisitObjectCreationExpression(node);
    }

    public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        _currentNamespace = node.Name.ToString();
        base.VisitNamespaceDeclaration(node);
    }

    public override void VisitParameter(ParameterSyntax node)
    {
        var p = (ParameterSymbol)_semanticModel.GetDeclaredSymbol(node);
        if (_specificationsElements.IsContextOrService(p.Type))
        {
            _done = true;
            return;
        }
        base.VisitParameter(node);
    }

    public static IEnumerable<string> GetUsings(TypeSyntax typeSyntax, TypeSymbol typeSymbol)
    {
        var typeSyntaxName = typeSyntax.ToString().Replace(" ", "");
        var typeSymbolName = typeSymbol.ToString().Replace(" ", "");
        return GetUsings(typeSyntaxName, typeSymbolName);
    }

    private static IEnumerable<string> GetUsings(string typeSyntaxName, string typeSymbolName)
    {
        if (typeSyntaxName == typeSymbolName)
            yield break;
        var nsMatch = Regex.Match(typeSymbolName, string.Concat("^((.?)*).", typeSyntaxName, "$"));
        if (nsMatch.Success)
            yield return nsMatch.Groups[1].Value;
        foreach (var @using in GetGenericUsings(typeSyntaxName, typeSymbolName))
            yield return @using;
    }

    private static IEnumerable<string> GetGenericUsings(string typeSyntaxName, string typeSymbolName)
    {
        var typeSyntaxMatch = Regex.Match(typeSyntaxName, @"([^<>,]+)(?:\<(([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-4>\>)[^<>]*)+)*(?(4)(?!))))\>[^<>,]*)");
        var typeSymbolMatch = Regex.Match(typeSymbolName, @"([^<>,]+)(?:\<(([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-4>\>)[^<>]*)+)*(?(4)(?!))))\>[^<>,]*)");
        if (typeSyntaxMatch.Success)
        {
            foreach (var @using in GetUsings(typeSyntaxMatch.Groups[1].Value, typeSymbolMatch.Groups[1].Value))
                yield return @using;
            typeSyntaxMatch = Regex.Match(typeSyntaxMatch.Groups[2].Value, @"[^<>,]+(?:\<(?:([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-2>\>)[^<>]*)+)*(?(2)(?!))))\>[^<>,]*)?");
            typeSymbolMatch = Regex.Match(typeSymbolMatch.Groups[2].Value, @"[^<>,]+(?:\<(?:([^<>,]*(?:(?:(\<)[^<>]*)+(?:(?<-2>\>)[^<>]*)+)*(?(2)(?!))))\>[^<>,]*)?");
            while (typeSyntaxMatch.Success)
            {
                foreach (var @using in GetUsings(typeSyntaxMatch.Value, typeSymbolMatch.Value))
                    yield return @using;
                typeSyntaxMatch = typeSyntaxMatch.NextMatch();
                typeSymbolMatch = typeSymbolMatch.NextMatch();
            }
        }	
    }
}

public class ClassesVisitor : SyntaxVisitorOfIEnumerableOfClassDeclarationSyntax
{
    public override IEnumerable<ClassDeclarationSyntax> VisitCompilationUnit(CompilationUnitSyntax node)
    {
        return node.Members.OfType<NamespaceDeclarationSyntax>().SelectMany(c => Visit(c));
    }

    public override IEnumerable<ClassDeclarationSyntax> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return node.Members.OfType<ClassDeclarationSyntax>().SelectMany(c => Visit(c));
    }

    public override IEnumerable<ClassDeclarationSyntax> VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        yield return node;
    }
}

public class SpecificationPath
{
    public string Sln { get; set; }
    public string Csproj { get; set; }
    public string Folder { get; set; }
}

public class IsCriticityErrorVisitor : SyntaxVisitorOfBool
{
    private ISemanticModel _semanticModel;
    private SpecificationsElements _specificationsElements;
    private string _serverFxServiceInterfacesNamespace;
    private MethodDeclarationSyntax _method;
        
    public IsCriticityErrorVisitor(ISemanticModel semanticModel, SpecificationsElements specificationsElements, string serverFxServiceInterfacesNamespace)
    {
        _semanticModel = semanticModel;
        _specificationsElements = specificationsElements;
        _serverFxServiceInterfacesNamespace = serverFxServiceInterfacesNamespace;
    }

    public override bool Visit(SyntaxNode node)
    {
        return base.Visit(node) || node.ChildNodes().Any(n => Visit(n));
    }

    public override bool VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        _method = node;
        return base.VisitMethodDeclaration(node);
    }

    public override bool VisitInvocationExpression(InvocationExpressionSyntax node)
    {
        var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
        MethodDeclarationSyntax method;
        if (_specificationsElements.MethodPerMethodSymbols.TryGetValue(methodSymbol.ToString(), out method) && Visit(method))
            return true;
        return base.VisitInvocationExpression(node);
    }

    public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        var name = node.Name.ToString();
        IFieldSymbol fieldSymbol;
        ITypeSymbol typeSymbol;
        return (name == "Error" || name == "Mandatory") && (fieldSymbol = _semanticModel.GetSymbolInfo(node).Symbol as IFieldSymbol) != null &&  fieldSymbol != null && (typeSymbol = _semanticModel.GetSymbolInfo(node.Expression).Symbol as ITypeSymbol) != null && typeSymbol.ContainingNamespace.ToString() == _serverFxServiceInterfacesNamespace && typeSymbol.Name == "Criticity";
    }
}

public class TypeRewriter : SyntaxRewriter
{
    public TypeRewriter(ISemanticModel semanticModel, Func<NameSyntax, NameSyntax> getNameSyntax = null)
        :this(semanticModel, getNameSyntax, null)
    {
    }
    public TypeRewriter(ISemanticModel semanticModel, Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> getGenericNameSyntax)
        :this(semanticModel, null, getGenericNameSyntax)
    {
    }
    public TypeRewriter(ISemanticModel semanticModel, Func<NameSyntax, NameSyntax> getNameSyntax, Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> getGenericNameSyntax)
    {
        SemanticModel = semanticModel;
        GetNameSyntaxFunc = getNameSyntax;
        GetGenericNameSyntaxFunc = getGenericNameSyntax;
    }

    public ISemanticModel SemanticModel { get; protected set; }
    protected Func<NameSyntax, NameSyntax> GetNameSyntaxFunc { get; set; }
    protected Func<GenericNameSyntax, Func<GenericNameSyntax>, GenericNameSyntax> GetGenericNameSyntaxFunc { get; set; }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
        return GetNameSyntax(node) ?? base.VisitQualifiedName(node);
    }

    private NameSyntax GetNameSyntax(NameSyntax node)
    {
        try
        {
            ISymbol symbol;
            MethodSymbol methodSymbol;
            if (GetNameSyntaxFunc == null || ! ((symbol = SemanticModel.GetSymbolInfo(node).Symbol) is ITypeSymbol || (methodSymbol = symbol as MethodSymbol) != null && methodSymbol.MethodKind == MethodKind.Constructor))
                return node;
            return GetNameSyntaxFunc(node);
        }
        catch
        {
            return null;
        }
    }

    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
        return GetNameSyntax(node) ?? base.VisitIdentifierName(node);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
        if (GetGenericNameSyntaxFunc != null)
            return GetGenericNameSyntaxFunc(node, () => (GenericNameSyntax)base.VisitGenericName(node));
        return base.VisitGenericName(node);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
        var value = (ObjectCreationExpressionSyntax)base.VisitObjectCreationExpression(node);
        if (GetNameSyntaxFunc == null)
            return value;
        var type = GetNameSyntaxFunc((NameSyntax)node.Type);
        if (node.Type != type)
            value = value.WithType(type);
        return value;
    }
}

public class UseServicePropertyVisitor : SyntaxVisitorOfBool
{
    private ISemanticModel _semanticModel;
    private IEnumerable<PropertySymbol> _propertiesSymbol;

    public UseServicePropertyVisitor(ISemanticModel semanticModel, IEnumerable<PropertySymbol> propertiesSymbol)
    {
        _semanticModel = semanticModel;
        _propertiesSymbol = propertiesSymbol;
    }

    public static bool UseServiceProperty(MethodDeclarationSyntax method, SpecificationsElements specificationsElements)
    {
        return new UseServicePropertyVisitor(specificationsElements.SemanticModelPerMethods[method], specificationsElements.ServiceProperties).Visit(method);
    }

    public override bool Visit(SyntaxNode node)
    {
        return base.Visit(node) || node.ChildNodes().Any(cn => Visit(cn));
    }

    public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        return VisitProp(node) || base.VisitMemberAccessExpression(node);
    }

    public override bool VisitIdentifierName(IdentifierNameSyntax node)
    {
        return VisitProp(node) || base.VisitIdentifierName(node);
    }

    private bool VisitProp(SyntaxNode node)
    {
        return _propertiesSymbol.Any(ps => ps.Equals(_semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol));
    }
}

public static class MethodSymbolExtension
{
    public static bool IsExtensionMethod(MethodSymbol method)
    {
        return method.IsExtensionMethod || method.GetAttributes().Any(a => a.ToString() == "System.Runtime.CompilerServices.ExtensionAttribute");
    }
}

bool GetIncludesInfo(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, IEnumerable<EntityType> entityTypes, CodeGenerationTools code, string serverEntitiesNamespace, out List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor, out List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith)
{
    includesFor = new List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>>();
    includesWith = new List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>>();

    Func<MethodDeclarationSyntax, bool, List<List<PropertySymbolInfo>>> getDependentProperties = null;
    getDependentProperties = (m, last) =>
    {
        List<List<PropertySymbolInfo>> dependentProperties;
        if ((last ? specificationsElements.MethodsDependentPropertiesLast : specificationsElements.MethodsDependentProperties).TryGetValue(m, out dependentProperties) && dependentProperties != null)
        {
            dependentProperties = dependentProperties.Select(pds => pds.ToList()).ToList();
            Func<List<PropertySymbolInfo>, List<PropertySymbolInfo>, bool> listEquals = (l1, l2) =>
            {
                if (l1.Count != l2.Count)
                    return false;
                for (int i = 0 ; i < l1.Count ; i ++)
                    if (l1[i].Name != l2[i].Name)
                        return false;
                return true;
            };

            if (last)
            {
                for (int i = 0 ; i < dependentProperties.Count ; i ++)
                {
                    for (int j = 1 ; j < dependentProperties[i].Count - 1 ; j ++)
                    {
                        var newDependentProperties = dependentProperties[i].Take(j).ToList();
                        if (! dependentProperties.Any(dp => listEquals(dp, newDependentProperties)))
                            dependentProperties.Insert(i ++, newDependentProperties);
                    }
                }
            }

            for (int pdsIndex = 0 ; pdsIndex < dependentProperties.Count ; pdsIndex ++)
            {
                var pds = dependentProperties[pdsIndex];
                var pd = pds[pds.Count - 1];
                if (pd.GetMethod != null)
                {
                    bool changed = false;
                    var pdMethodsDependentPropertiesLast = getDependentProperties(pd.GetMethod, true);
                    for (int pdsIndex2 = pdsIndex + 1 ; pdsIndex2 < dependentProperties.Count ; pdsIndex2 ++)
                    {
                        var pds2 = dependentProperties[pdsIndex2];
                        for (int i = 0 ; i < pds2.Count - 1 ; i ++)
                        {
                            if (pd.GetMethod == pds2[i].GetMethod)
                            {
                                changed = true;
                                dependentProperties.RemoveAt(pdsIndex2);
                                pds2.RemoveAt(i);
                                foreach (var pdsLast in pdMethodsDependentPropertiesLast.AsEnumerable().Reverse())
                                {
                                    var newDependences = pds2.Take(i).ToList();
                                    var newPds2 = new List<PropertySymbolInfo>(pds2);
                                    int j = i;
                                    foreach (var pdLast in pdsLast)
                                    {
                                        newDependences.Add(pdLast);
                                        if (! dependentProperties.Any(dp => listEquals(dp, newDependences)))
                                        {
                                            dependentProperties.Insert(pdsIndex ++, newDependences);
                                            pdsIndex2 ++;
                                            newDependences = new List<PropertySymbolInfo>(newDependences);
                                        }
                                        newPds2.Insert(j++, pdLast);
                                    }
                                    dependentProperties.Insert(pdsIndex2, newPds2);
                                }
                                break;
                            }
                        }
                    }
                    if (changed)
                        pdsIndex --;
                }
            }
        }
        return dependentProperties;
    };
    var methodDependentProperties = getDependentProperties(method, false);
    if (methodDependentProperties != null)
    {
        for (int pdsIndex = 0 ; pdsIndex < methodDependentProperties.Count ; pdsIndex ++)
        {
            var pds = methodDependentProperties[pdsIndex];
            var pd = pds[pds.Count - 1];
            var entityType = entityTypes.FirstOrDefault(et => string.Concat(serverEntitiesNamespace, ".", code.Escape(et)) == pd.ContainingType.ToString());
            if (entityType == null)
                return false;
            var previousIncludeFor = pds.Count > 1 ? includesFor.Where(includeFor =>
                {
                    if (includeFor.Value.Count + 1 != pds.Count)
                        return false;
                    for (int includeForIndex = 0 ; includeForIndex < includeFor.Value.Count ; includeForIndex ++)
                        if (includeFor.Value[includeForIndex].ToString() != pds[includeForIndex].ToString())
                            return false;
                    return true;
                }).Select(kvp => kvp.Value).FirstOrDefault()
                : null;
            if (entityType != null && entityType.NavigationProperties.Any(np => code.Escape(np) == pd.Name))
                includesFor.Add(new KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>(previousIncludeFor, pds));
            else if (pd.GetMethod != null)
            {
                if (pds.Count > 1 && previousIncludeFor == null)
                    return false;
                includesWith.Add(new KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>(previousIncludeFor, pds));
            }
            else
            {
                for (int nextIndex = pdsIndex + 1 ; nextIndex < methodDependentProperties.Count ;)
                {
                    bool remove = true;
                    var pdsLoop = methodDependentProperties[nextIndex];
                    for (int prevIndex = 0 ; prevIndex < pds.Count ; prevIndex ++)
                    {
                        if (prevIndex >= pdsLoop.Count || pds[prevIndex].Name != pdsLoop[prevIndex].Name)
                            remove = false;
                    }
                    if (remove)
                        methodDependentProperties.Remove(pdsLoop);
                    else
                        nextIndex ++;
                }
            }
        }
    }
    return true;
}

StringBuilder IncludeFor(MethodDeclarationSyntax method, SpecificationsElements specificationsElements, IEnumerable<EntityType> entityTypes, CodeGenerationTools code, string serverEntitiesNamespace, string clientEntitiesNamespace, TypeSymbol type)
{
    List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor;
    List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith; 
    var sb = new StringBuilder();
    if (GetIncludesInfo(method, specificationsElements, entityTypes, code, serverEntitiesNamespace, out includesFor, out includesWith))
    {
        int variableIndex = 1;
        try
        {
            return IncludeFor(includesFor, includesWith, sb, null, ref variableIndex, clientEntitiesNamespace, type);
        }
        catch (InvalidOperationException)
        {
            return null;
        }
    }
    return null;
}

    private StringBuilder IncludeFor(List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesFor,
        List<KeyValuePair<List<PropertySymbolInfo>, List<PropertySymbolInfo>>> includesWith, StringBuilder sb,
        List<PropertySymbolInfo> parent, ref int index, string clientEntitiesNamespace, TypeSymbol eType, bool addE = false)
    {
        string eTypeString = eType.ToString();
        bool first = true;
        foreach (var includeFor in includesFor.Where(i => i.Key == parent).Select(i => i.Value))
        {
            var lastIncludeFor = includeFor.Last();
            bool containsProp = false;
            TypeSymbol eTypeLoop = eType;
            do
            {
                var lastIncludeForContainingTypeString = lastIncludeFor.ContainingType.ToString();
                if (eTypeLoop.ToString() == lastIncludeForContainingTypeString)
                {
                    containsProp = true;
                    break;
                }
            } while ((eTypeLoop = eTypeLoop.BaseType) != null);
            if (first)
            {
                first = false;
                bool casted = false;
                if (addE && eType != null && includeFor.Count > 1)
                {
                    if (! containsProp)
                    {
                        if (eType.AllInterfaces.Any(i => i.ToString() == "System.Collections.IEnumerable"))
                        {
                            sb.Append("e");
                            sb.Append(index);
                            sb.Append(".OfType<");
                            sb.Append(clientEntitiesNamespace);
                            sb.Append(".");
                            sb.Append(lastIncludeFor.ContainingType.Name);
                            sb.Append(">()");
                        }
                        else
                        {
                            sb.Append("(e");
                            sb.Append(index);
                            sb.Append(" as ");
                            sb.Append(clientEntitiesNamespace);
                            sb.Append(".");
                            sb.Append(lastIncludeFor.ContainingType.Name);
                            sb.Append(")");
                        }
                        casted = true;
                    }
                }
                if (addE && ! casted)
                {
                    sb.Append("e");
                    sb.Append(index);
                    addE = false;
                }
                index ++;
            }
            sb.Append(".");
            if (! containsProp)
            {
                bool found = false;
                for (var baseType = (lastIncludeFor.ContainingType.TypeSymbol).BaseType ; baseType != null ; baseType = baseType.BaseType)
                    if (baseType.ToString() == eTypeString)
                    {
                        found = true;
                        break;
                    }
                if (found)
                    sb.Append(lastIncludeFor.ContainingType.Name);
                else
                    throw new InvalidOperationException();
            }
            sb.Append("Include");
            sb.Append(lastIncludeFor.Name);
            if (includesFor.Union(includesWith).Any(i => i.Key == includeFor))
            {
                sb.Append("WithExpression(e");
                sb.Append(index);
                sb.Append(" => ");
                IncludeFor(includesFor, includesWith, sb, includeFor, ref index, clientEntitiesNamespace, lastIncludeFor.Type.TypeSymbol, true);
            }
            else
                sb.Append("(");
            sb.Append(")");
        }
        foreach (var includeWith in includesWith.Where(i => i.Key == parent).Select(i => i.Value))
        {
            if (addE)
            {
                if (sb.Length != 0 && sb[sb.Length-1] != ')') 
                {
                    sb.Append("e");
                    sb.Append(index ++);											   
                }
                addE = false;
            }
            sb.Append(".With");
            sb.Append(includeWith.Last().Name);
            sb.Append("()");
        }
        return sb;
    }

    private class T4CustomGenerator
    {
        private Action<string> _write;
        private Func<StringBuilder> _getGenerationEnvironment;

        public StringBuilder GenerationEnvironment
        {
            get { return _getGenerationEnvironment(); }
        }

        protected ITextTemplatingEngineHost Host { get; set; }
        protected Func<string, string> HostResolvePath { get; set; }

        public T4CustomGenerator(Action<string> write, ITextTemplatingEngineHost host,
            Func<StringBuilder> getGenerationEnvironment)
        {
            _write = write;
            Host = host;
            HostResolvePath = path => Host.ResolvePath(path);
            _getGenerationEnvironment = getGenerationEnvironment;
        }

        [ThreadStatic] private static StringBuilder _currentFileStringBuilder;

        protected static StringBuilder CurrentFileStringBuilder
        {
            get { return _currentFileStringBuilder; }
            set { _currentFileStringBuilder = value; }
        }

        [ThreadStatic] private static bool _endsWithNewLine;

        protected static bool EndsWithNewLine
        {
            get { return _endsWithNewLine; }
            set { _endsWithNewLine = value; }
        }

        public void Write(string text)
        {
            if (_currentFileStringBuilder == null)
                _write(text);
            else
            {
                if (_endsWithNewLine)
                    text = Environment.NewLine + text;
                if (_endsWithNewLine = text.EndsWith(Environment.NewLine))
                    text = text.Substring(0, text.Length - Environment.NewLine.Length);
                text = text.Replace(Environment.NewLine, Environment.NewLine + CurrentIndent);
                _currentFileStringBuilder.Append(text);
            }
        }

        [ThreadStatic] private static Stack<string> _indents;

        protected static Stack<string> Indents
        {
            get { return _indents ?? (_indents = new Stack<string>()); }
            set { _indents = value; }
        }

        protected void PushIndent(string indent)
        {
            Indents.Push(Indents.Count == 0 ? indent : Indents.Peek() + indent);
        }

        protected string PopIndent()
        {
            return Indents.Pop();
        }

        public string CurrentIndent
        {
            get { return Indents.Count == 0 ? "" : Indents.Peek(); }
        }

        protected void Process(EntityFrameworkTemplateFileManager fileManager, ConcurrentDictionary<string, StringBuilder> classesCode, EdmxElements edmxElements, Func<IDocument, string, SyntaxRewriter> rewriterFactory)
        {
            _currentFileStringBuilder = null;

            var dte = (EnvDTE.DTE)new DynamicHost(Host).AsIServiceProvider().GetService(typeof(EnvDTE.DTE));
            var projectPath = dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject.FullName;
            var templateFolder = Path.GetDirectoryName(Host.TemplateFile);

            var solution = LoadSolution(dte.Solution.FullName, Host);
            var project = solution.Projects.First(p => Path.GetFullPath(p.FilePath) == projectPath);

            var documentIdCodes = new Dictionary<string, DocumentId>();

            foreach (var classCode in classesCode)
            {
                var document = project.Documents.FirstOrDefault(d => d.FilePath == Path.Combine(templateFolder, classCode.Key));
                if (document != null)
                    project = project.RemoveDocument(document.Id);
                DocumentId documentId;
                project = AddDocument(project, classCode.Key, classCode.Value.ToString(), new [] { "WAQS." + edmxElements.EdmxName }, out documentId);
                documentIdCodes.Add(classCode.Key, documentId);
            }

            foreach (var documentIdCode in documentIdCodes)
            {
                fileManager.StartNewFile(documentIdCode.Key);
                var newDocument = project.Documents.First(d => d.Id == documentIdCode.Value);
                new WritingFunctions(Write).WriteCopyright();
            #>
            <#=rewriterFactory(newDocument, documentIdCode.Key).Visit(GetSyntaxRoot(newDocument)).NormalizeWhitespace().ToString().Trim()#>
            <#+
            }

            fileManager.Process();
        }
    }

    public class TestNull : SyntaxRewriter
    {
        private ISemanticModel _semanticModel;
        private TypeSyntax _returnType;
        private HashSet<string> _alreadyTestedNullableExpressions;
        private HashSet<string> _removedAlreadyTestedNullableExpressions = new HashSet<string>();
        private Dictionary<string, SyntaxKind> _alreadyTestedNullableExpressionsTmp = new Dictionary<string, SyntaxKind>();
        private StatementSyntax _currentStatement;
        private Dictionary<StatementSyntax, List<StatementSyntax>> _statementsToAdd = new Dictionary<StatementSyntax, List<StatementSyntax>>();
        private HashSet<string> _expressionsToTest = new HashSet<string>();
        private Dictionary<string, string> _replaceNode = new Dictionary<string, string>();
        private string _waqsLogical;
        private bool _yield;
        private bool _pushInBlock;
        private bool _fromLinq;
        private bool _not;

        public TestNull(ISemanticModel semanticModel)
        {
            _semanticModel = semanticModel;
            _alreadyTestedNullableExpressions = new HashSet<string>();
        }

        private TestNull(TestNull @base)
        {
            _semanticModel = @base._semanticModel;
            _returnType = @base._returnType;
            _alreadyTestedNullableExpressions = new HashSet<string>(@base._alreadyTestedNullableExpressions.Union(@base._expressionsToTest));
            _replaceNode = new Dictionary<string, string>(_replaceNode);
            _currentStatement = @base._currentStatement;
            _yield = @base._yield;
            _fromLinq = @base._fromLinq;
            _not = @base._not;
        }

        protected virtual void Init()
        {
            _alreadyTestedNullableExpressions.Clear();
            _expressionsToTest.Clear();
        }

        public void AddAlreadyTestedNullableExpressions(string s)
        {
            _alreadyTestedNullableExpressions.Add(s);
        }

        private string GetExpressionString(ExpressionSyntax node)
        {
            string nodeString = node.NormalizeWhitespace().ToString();
            foreach (var replaceNode in _replaceNode)
                nodeString = nodeString.Replace(replaceNode.Key, replaceNode.Value);
            return nodeString;
        }

        private void AddExpressionToTest(ExpressionSyntax node)
        {
            bool _;
            AddExpressionToTest(node, out _);
        }

        private void AddExpressionToTest(ExpressionSyntax node, out bool changed)
        {
            var value = (ExpressionSyntax)new GetSimpleExpression().Visit(node);
            changed = node != value;
            string nodeString = GetExpressionString(value);
            if (!(_alreadyTestedNullableExpressions.Contains(nodeString)))
                _expressionsToTest.Add(nodeString);
        }

        private void ApplyChanges(TestNull testNull, BlockSyntax block)
        {
            if (testNull._expressionsToTest.Count != 0)
                testNull.AddStatement(testNull.BuildIfFromExpressionsToTest());
            List<StatementSyntax> addedStatements;
            if (testNull._statementsToAdd.TryGetValue(block, out addedStatements))
                foreach (var addedStatement in addedStatements)
                    AddStatement(addedStatement);
            foreach (var alreadyTested in testNull._alreadyTestedNullableExpressions.Union(testNull._expressionsToTest))
                _alreadyTestedNullableExpressions.Add(alreadyTested);
            foreach (var alreadyTestedTmp in testNull._alreadyTestedNullableExpressionsTmp)
                if (!_alreadyTestedNullableExpressionsTmp.ContainsKey(alreadyTestedTmp.Key))
                    _alreadyTestedNullableExpressionsTmp.Add(alreadyTestedTmp.Key, alreadyTestedTmp.Value);
            foreach (var replaceNode in testNull._replaceNode)
                if (!_replaceNode.ContainsKey(replaceNode.Key))
                    _replaceNode.Add(replaceNode.Key, replaceNode.Value);
            ApplyRemoveStatements(testNull);
        }

        private void ApplyRemoveStatements(TestNull testNull, bool addVariables = true)
        {
            foreach (var removeExp in testNull._removedAlreadyTestedNullableExpressions)
            {
                if (_expressionsToTest.Contains(removeExp))
                    AddStatement(BuildIfFromExpressionsToTest());
                if (addVariables)
                    foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.ToList())
                        if (Regex.IsMatch(alreadyTestedNullableExpression, string.Concat("^", removeExp, @"($|\.)")) && !testNull._alreadyTestedNullableExpressions.Contains(alreadyTestedNullableExpression))
                        {
                            _alreadyTestedNullableExpressions.Remove(alreadyTestedNullableExpression);
                            _removedAlreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                        }
            }
        }

        public void Visit(IEnumerable<SyntaxNode> nodes)
        {
            foreach (var node in nodes)
                Visit(node);
        }

        public override SyntaxNode Visit(SyntaxNode node)
        {
            var statement = node as StatementSyntax;
            SyntaxKind kind;
            if (statement != null)
            {
                _currentStatement = statement;
                _alreadyTestedNullableExpressionsTmp.Clear();
                _pushInBlock = false;
            }
            else if (!(_waqsLogical == null || (kind = GetKind(node)) == SyntaxKind.LogicalOrExpression || kind == SyntaxKind.LogicalAndExpression))
                _waqsLogical = null;
            var value = base.Visit(node);
            if (!(_expressionsToTest.Count == 0 || statement == null))
            {
                List<StatementSyntax> statementsToAdd;
                if (!_statementsToAdd.TryGetValue(statement, out statementsToAdd))
                    _statementsToAdd.Add(statement, statementsToAdd = new List<StatementSyntax>());
                statementsToAdd.Add(BuildIfFromExpressionsToTest());
            }
            if (statement != null && _pushInBlock)
            {
                if (_expressionsToTest.Count != 0)
                    AddStatement(BuildIfFromExpressionsToTest());
                List<StatementSyntax> statements;
                if (!_statementsToAdd.TryGetValue(statement, out statements))
                    statements = new List<StatementSyntax>();
                else
                    _statementsToAdd.Remove(statement);
                statements.Add((StatementSyntax)value);
                return SyntaxFactory.Block(statements.Where(s => s != null));
            }
            return value;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            _yield = new IsYieldVisitor().Visit(node.Body);
            Init();
            if (((MethodSymbol)_semanticModel.GetDeclaredSymbol(node)).ReturnsVoid)
                _returnType = null;
            else
                _returnType = node.ReturnType;
            var value = base.VisitMethodDeclaration(node);
            return value;
        }

        public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            _returnType = node.Type;
            var value = base.VisitPropertyDeclaration(node);
            return value;
        }

        public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
        {
            Init();
            return base.VisitEventDeclaration(node);
        }

        public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
        {
            _yield = new IsYieldVisitor().Visit(node.Body);
            Init();
            return base.VisitAccessorDeclaration(node);
        }

        private IfStatementSyntax BuildIfFromExpressionsToTest()
        {
            if (_expressionsToTest.Count == 0)
                return null;
            var value = SyntaxFactory.IfStatement(
                BuildExpressionsToTest(),
                    _yield ?
                        SyntaxFactory.ParseStatement("yield break;") :
                        SyntaxFactory.ReturnStatement(
                            _returnType == null ? null : (_returnType.ToString().Length == 0 ? (ExpressionSyntax)SyntaxFactory.IdentifierName("null") : SyntaxFactory.DefaultExpression(_returnType))));
            foreach (var expressionToTest in _expressionsToTest)
            {
                _alreadyTestedNullableExpressions.Add(expressionToTest);
                var originalValue = _replaceNode.Where(kvp => kvp.Value == expressionToTest).Select(kvp => kvp.Key).FirstOrDefault();
                if (originalValue != null)
                    _alreadyTestedNullableExpressions.Add(originalValue);
            }
            _expressionsToTest.Clear();
            return value;
        }

        private ExpressionSyntax BuildConditionFromExpressionsToTest(ExpressionSyntax expression)
        {
            if (_expressionsToTest.Count == 0)
                return expression;
            var value =
                SyntaxFactory.ParenthesizedExpression(
                    SyntaxFactory.ConditionalExpression(
                        SyntaxFactory.ParenthesizedExpression(
                            BuildExpressionsToTest()),
                        SyntaxFactory.DefaultExpression(_returnType),
                        expression));
            _expressionsToTest.Clear();
            return value;
        }

        private ExpressionSyntax BuildExpressionsToTest()
        {
            return _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")).Aggregate((e1, e2) => SyntaxFactory.BinaryExpression(SyntaxKind.LogicalOrExpression, e1, e2));
        }

        private void AddStatement(StatementSyntax statement, int? index = null)
        {
            if (statement == null)
                return;
            List<StatementSyntax> statements;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statements))
                _statementsToAdd.Add(_currentStatement, statements = new List<StatementSyntax>());
            if (index.HasValue)
                statements.Insert(index.Value, statement);
            else
                statements.Add(statement);
        }

        public override SyntaxNode VisitBlock(BlockSyntax node)
        {
            List<StatementSyntax> statements;
            if (VisitStatements(node.Statements, out statements))
                return SyntaxFactory.Block(statements.Where(s => s != null));
            return node;
        }

        private bool VisitStatements(IEnumerable<StatementSyntax> nodeStatements, out List<StatementSyntax> statements)
        {
            bool changed = false;
            statements = new List<StatementSyntax>();
            var testNull = new TestNull(this);
            foreach (var statement in nodeStatements)
            {
                var newStatement = (StatementSyntax)testNull.Visit(statement);
                List<StatementSyntax> statementsToAdd;
                if (testNull._statementsToAdd.TryGetValue(statement, out statementsToAdd))
                {
                    changed = true;
                    statements.AddRange(statementsToAdd);
                    foreach (var alreadyTestedNullableExpression in testNull._alreadyTestedNullableExpressions)
                        _alreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                }
                if (newStatement != statement)
                    changed = true;
                statements.Add(newStatement);
            }
            ApplyRemoveStatements(testNull);
            return changed;
        }

        public static bool IsNullable(ITypeSymbol type)
        {
            if (type == null)
                return false;
            return !type.IsValueType || IsNullableType(type);
        }

        public static bool IsNullableType(ITypeSymbol type)
        {
            string namedTypeSymbolName;
            NamedTypeSymbol namedTypeSymbol;
            return (namedTypeSymbol = type as NamedTypeSymbol) != null && namedTypeSymbol.IsGenericType && ((namedTypeSymbolName = type.ToString()).StartsWith("System.Nullable<") || namedTypeSymbolName.EndsWith("?"));
        }

        public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            var value = (MemberAccessExpressionSyntax)base.VisitMemberAccessExpression(node);
            PropertySymbol propertySymbol;
            if ((propertySymbol = _semanticModel.GetSymbolInfo(node).Symbol as PropertySymbol) != null && IsNullable(propertySymbol.Type) && node.Parent is MemberAccessExpressionSyntax && !(node.Expression is ThisExpressionSyntax))
            {
                var parentPropertySymbol = _semanticModel.GetSymbolInfo(node.Parent).Symbol as PropertySymbol;
                if (parentPropertySymbol == null || parentPropertySymbol.Name != "HasValue" || parentPropertySymbol.ContainingType == null || !IsNullableType(parentPropertySymbol.ContainingType))
                    AddExpressionToTest(value);
            }
            else if (!(node.Expression is ThisExpressionSyntax) && IsNullable(_semanticModel.GetTypeInfo(node.Expression).Type))
            {
                var ancestor = node.Parent;
                ClassDeclarationSyntax classDeclaration = null;
                while ((ancestor = ancestor.Parent) != null && (classDeclaration = ancestor as ClassDeclarationSyntax) == null)
                    ;
                ISymbol symbol;
                if (propertySymbol != null && !(node.Expression is ThisExpressionSyntax) && !(node.Parent is MemberAccessExpressionSyntax) && !(node.Parent is InvocationExpressionSyntax && node.Parent.Parent is MemberAccessExpressionSyntax) && classDeclaration != null && (symbol = _semanticModel.GetSymbolInfo(node.Expression).Symbol) != null && symbol.ContainingType != null && _semanticModel.GetDeclaredSymbol(classDeclaration).ToString() == symbol.ContainingType.ToString())
                    AddExpressionToTest(value.Expression);
                else if (node.Expression is InvocationExpressionSyntax && !IsLINQ(node.Expression))
                    AddExpressionToTest(value.Expression);
            }
            return value;
        }

        public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
        {
            var value = base.VisitElementAccessExpression(node);
            var nodeString = node.ToString();
            if (node.Parent is MemberAccessExpressionSyntax && !(_expressionsToTest.Contains(nodeString) || _alreadyTestedNullableExpressions.Contains(nodeString)))
                AddExpressionToTest(node);
            return value;
        }

        public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
        {
            if (node.Parent is MemberAccessExpressionSyntax)
            {
                var symbol = _semanticModel.GetSymbolInfo(node).Symbol;
                var parameterSymbol = symbol as ParameterSymbol;
                ILocalSymbol localSymbol;
                IRangeVariableSymbol rangeVariableSymbol;
                if (parameterSymbol != null)
                {
                    if (IsNullable(parameterSymbol.Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
                else if ((localSymbol = symbol as ILocalSymbol) != null)
                {
                    if (GetKind(node.Parent) != SyntaxKindAssignExpression && IsNullable(localSymbol.Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
                else if ((rangeVariableSymbol = symbol as IRangeVariableSymbol) != null)
                {
                    if (GetKind(node.Parent) != SyntaxKindAssignExpression && IsNullable(_semanticModel.GetTypeInfo(node).Type) && !(_expressionsToTest.Contains(node.Identifier.ValueText) || _alreadyTestedNullableExpressions.Contains(node.Identifier.ValueText)))
                        _expressionsToTest.Add(node.Identifier.ValueText);
                }
            }
            return base.VisitIdentifierName(node);
        }

        private bool IsLINQ(SyntaxNode node)
        {
            ParenthesizedExpressionSyntax parenthesisExpression;
            while ((parenthesisExpression = node as ParenthesizedExpressionSyntax) != null)
                node = parenthesisExpression.Expression;
            if (node is QueryExpressionSyntax)
                return true;
            var invocationExpression = node as InvocationExpressionSyntax;
            if (invocationExpression != null)
            {
                var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(invocationExpression).Symbol;
                if (methodSymbol != null && methodSymbol.ContainingType.ToString() == "System.Linq.Enumerable" && methodSymbol.ReturnType.ToString() != "System.String" && methodSymbol.ReturnType.AllInterfaces.Any(i => i.ToString() == "System.Collections.IEnumerable"))
                    return true;
            }
            var binaryExp = node as BinaryExpressionSyntax;
            if (binaryExp != null && GetKind(binaryExp) == SyntaxKindAssignExpression)
                return IsLINQ(binaryExp.Right);
            return false;
        }

        public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            if (IsIQueryable(_semanticModel.GetTypeInfo(node).Type))
            {
                var expression = (ExpressionSyntax)Visit(node.Expression);
                return node.WithExpression(expression);
            }
            if (IsLINQ(node))
            {
                var expression = (ExpressionSyntax)Visit(node.Expression);
                return node.WithExpression(expression).WithArgumentList(SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(node.ArgumentList.Arguments.Select(a => (ArgumentSyntax)new TestNull(this).Visit(a)), node.ArgumentList.Arguments.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken)))));
            }
            var value = (InvocationExpressionSyntax)base.VisitInvocationExpression(node);
            foreach (var argument in value.ArgumentList.Arguments)
                if (GetKind(argument.RefOrOutKeyword) != SyntaxKind.None)
                    RemoveAlreadyTestedVariable(argument.Expression.ToString());
            var methodSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(node).Symbol;
            if (node.Parent is MemberAccessExpressionSyntax || node.Parent is FromClauseSyntax || node.Parent is ForEachStatementSyntax)
            {
                if (methodSymbol == null)
                    return node;
                var valueString = GetExpressionString(value);
                string variable;
                bool variableFound = _replaceNode.TryGetValue(valueString, out variable);
                if (!variableFound)
                {
                    variable = string.Concat("waqsValue", methodSymbol.Name, Guid.NewGuid().ToString("N"));
                    _replaceNode.Add(valueString, variable);
                }
                if (_expressionsToTest.Count != 0)
                    AddStatement(BuildIfFromExpressionsToTest());
                if (!variableFound)
                    AddStatement(SyntaxFactory.ParseStatement(string.Concat("var ", variable, " = ", valueString, ";")));
                return SyntaxFactory.IdentifierName(variable);
            }
            var nodeExpressionMemberAccessExpression = node.Expression as MemberAccessExpressionSyntax;
            ExpressionSyntax nodeExpressionExpression;
            ISymbol nodeExpressionExpressionSymbol;
            if (nodeExpressionMemberAccessExpression != null && (nodeExpressionExpression = nodeExpressionMemberAccessExpression.Expression) != null && ! IsLINQ(nodeExpressionExpression) && (nodeExpressionExpressionSymbol = _semanticModel.GetSymbolInfo(nodeExpressionExpression).Symbol) != null && !(nodeExpressionExpressionSymbol is ITypeSymbol))
                AddExpressionToTest(nodeExpressionExpression);
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());
            return value;
        }

        public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
        {
            if (GetKind(node) == SyntaxKind.LogicalNotExpression)
                _not = !_not;
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Operand).Type))
                        AddExpressionToTest(node.Operand);
                    break;
            }
            return base.VisitPrefixUnaryExpression(node);
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.QuestionQuestionToken:
                    return VisitCoalesce(node);
                case SyntaxKind.BarBarToken:
                    return VisitLogical(node, SyntaxKind.LogicalOrExpression);
                case SyntaxKind.AmpersandAmpersandToken:
                    return VisitLogical(node, SyntaxKind.LogicalAndExpression);
                case SyntaxKind.EqualsToken:
                    var value = (BinaryExpressionSyntax)VisitAssign(node);
                    ITypeSymbol rightType;
                    if (!IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type) && IsNullableType(rightType = (ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                    {
                        string valueName = "waqsValue" + Guid.NewGuid().ToString("N");
                        AddStatement(BuildIfFromExpressionsToTest());
                        AddStatement(
                            SyntaxFactory.LocalDeclarationStatement(
                                SyntaxFactory.VariableDeclaration(
                                    SyntaxFactory.ParseTypeName(rightType.ToString()),
                                    SyntaxFactory.SeparatedList(
                                        new []
                                        {
                                            SyntaxFactory.VariableDeclarator(valueName)
                                                    .WithInitializer(
                                                        SyntaxFactory.EqualsValueClause(
                                                            value.Right))
                                        }, 
                                        new SyntaxToken[0]))));
                        _expressionsToTest.Add(valueName);
                        AddStatement(BuildIfFromExpressionsToTest());

                        return SyntaxFactory.BinaryExpression(
                            SyntaxKindAssignExpression,
                            value.Left,
                            SyntaxFactory.IdentifierName(valueName));
                    }
                    return value;
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type))
                        AddExpressionToTest(node.Left);
                    if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                        AddExpressionToTest(node.Right);
                    AddStatement(BuildIfFromExpressionsToTest());
                    break;
            }

            return base.VisitBinaryExpression(node);
        }

        private SyntaxNode VisitLogical(BinaryExpressionSyntax node, SyntaxKind kind)
        {
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());

            string waqsLogicalName = _waqsLogical ?? "waqsLogical" + Guid.NewGuid().ToString("N");

            var leftBlock = SyntaxFactory.Block();
            var leftTestNull = new TestNull(this) { _currentStatement = leftBlock, _waqsLogical = waqsLogicalName };
            var leftExpression = (ExpressionSyntax)leftTestNull.Visit(node.Left);
            if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Left).Type))
                leftTestNull.AddExpressionToTest(leftExpression);

            var rightBlock = SyntaxFactory.Block();
            var rightTestNull = new TestNull(this)
            {
                _currentStatement = rightBlock,
                _alreadyTestedNullableExpressions =
                    new HashSet<string>(leftTestNull._alreadyTestedNullableExpressions.Union(leftTestNull._expressionsToTest).Union(leftTestNull._alreadyTestedNullableExpressionsTmp.Select(e => e.Key))),
                _waqsLogical = GetKind(node) == SyntaxKind.LogicalOrExpression && GetKind(node.Right) == SyntaxKind.LogicalAndExpression || _fromLinq ? null : waqsLogicalName
            };
            var rightExpression = (ExpressionSyntax)rightTestNull.Visit(node.Right);
            if (IsNullableType((ITypeSymbol)_semanticModel.GetTypeInfo(node.Right).Type))
                rightTestNull.AddExpressionToTest(rightExpression);

            List<StatementSyntax> ifNotLeftStatements;
            if (!rightTestNull._statementsToAdd.TryGetValue(rightBlock, out ifNotLeftStatements))
            {
                if (!(node.Parent is ForEachStatementSyntax || node.Parent is ForStatementSyntax || node.Parent is WhileStatementSyntax || node.Parent is DoStatementSyntax) && rightTestNull._expressionsToTest.Count == 0 && !rightTestNull._statementsToAdd.ContainsKey(rightBlock) && leftExpression.NormalizeWhitespace().ToString() == node.Left.NormalizeWhitespace().ToString() && rightExpression.NormalizeWhitespace().ToString() == node.Right.NormalizeWhitespace().ToString())
                {
                    ApplyChanges(leftTestNull, leftBlock);
                    return node;
                }
                ifNotLeftStatements = new List<StatementSyntax>();
            }
            if (_fromLinq)
            {
                rightExpression = rightTestNull.MakeCondition(rightExpression);
                var value = leftTestNull.MakeCondition(
                    SyntaxFactory.BinaryExpression(
                        kind,
                        leftExpression,
                        rightExpression));
                foreach (var leftAlreadyTested in _expressionsToTest)
                    _alreadyTestedNullableExpressions.Add(leftAlreadyTested);
                if (kind == SyntaxKind.LogicalAndExpression)
                    foreach (var rightAlreadyTested in rightTestNull._alreadyTestedNullableExpressions)
                        _alreadyTestedNullableExpressions.Add(rightAlreadyTested);
                return value;
            }

            ApplyChanges(leftTestNull, leftBlock);

            var statementsToAdd = new List<StatementSyntax>();

            ApplyRemoveStatements(rightTestNull);

            ifNotLeftStatements.Add(rightTestNull.BuildIfFromExpressionsToTest());
            ifNotLeftStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(waqsLogicalName),
                        rightExpression)));
            var leftExpressionIdentifierName = leftExpression as IdentifierNameSyntax;
            if (leftExpressionIdentifierName == null || leftExpressionIdentifierName.Identifier.ValueText != waqsLogicalName)
            {
                statementsToAdd.Add(
                    SyntaxFactory.LocalDeclarationStatement(
                        SyntaxFactory.VariableDeclaration(
                            SyntaxFactory.ParseTypeName("bool"),
                            SyntaxFactory.SeparatedList(
                                new [] 
                                {
                                    SyntaxFactory.VariableDeclarator(waqsLogicalName)
                                            .WithInitializer(
                                                SyntaxFactory.EqualsValueClause(
                                                    leftExpression))
                                },
                                new SyntaxToken[0]))));

                statementsToAdd.Add(
                    SyntaxFactory.IfStatement(
                        SyntaxFactory.ParseExpression((kind == SyntaxKind.LogicalOrExpression ? "!" : "") + waqsLogicalName),
                            SyntaxFactory.Block(
                                ifNotLeftStatements.Where(s => s != null))));
            }
            else
            {
                var statementsToAddTmp = _statementsToAdd[_currentStatement];
                int statementIndex = statementsToAddTmp.Count - 1;
                IfStatementSyntax ifStatement;
                while ((ifStatement = (IfStatementSyntax)statementsToAddTmp[statementIndex]) == null)
                    statementsToAddTmp.RemoveAt(statementIndex--);
                statementsToAddTmp[statementIndex] =
                    ifStatement
                        .WithStatement(
                            SyntaxFactory.Block(((BlockSyntax)ifStatement.Statement).Statements.Union(
                                new[] 
                                    { 
                                        SyntaxFactory.IfStatement(
                                            SyntaxFactory.ParseExpression((kind == SyntaxKind.LogicalOrExpression ? "!" : "") + waqsLogicalName),
                                            SyntaxFactory.Block(
                                                ifNotLeftStatements.Where(s => s != null)))
                                    }).Where(s => s != null)));
            }

            var nodeParent = node.Parent;
            if (GetKind(nodeParent) == SyntaxKind.LogicalNotExpression)
                nodeParent = nodeParent.Parent;
            var binaryParentNode = nodeParent as BinaryExpressionSyntax;
            SyntaxKind binaryParentKind;
            if (binaryParentNode != null && ((binaryParentKind = GetKind(binaryParentNode)) == SyntaxKind.LogicalOrExpression || binaryParentKind == SyntaxKind.LogicalAndExpression))
                foreach (var alreadyTestedNullableExp in rightTestNull._alreadyTestedNullableExpressions.Where(e => !_alreadyTestedNullableExpressions.Contains(e) && !_alreadyTestedNullableExpressionsTmp.ContainsKey(e)))
                    _alreadyTestedNullableExpressionsTmp.Add(alreadyTestedNullableExp, GetKind(node));

            foreach (var statementToAdd in statementsToAdd)
                AddStatement(statementToAdd);

            return SyntaxFactory.IdentifierName(waqsLogicalName);
        }

        private ExpressionSyntax MakeCondition(ExpressionSyntax exp)
        {
            List<ExpressionSyntax> expressionsToTest;
            List<StatementSyntax> addedStatements;
            if (_statementsToAdd.TryGetValue(_currentStatement, out addedStatements))
            {
                expressionsToTest = new List<ExpressionSyntax>();
                foreach (var e in addedStatements.OfType<IfStatementSyntax>())
                    expressionsToTest.Add(e.Condition);
                foreach (var e in _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")))
                    expressionsToTest.Add(e);
            }
            else
                expressionsToTest = _expressionsToTest.Select(e => SyntaxFactory.ParseExpression(e + " == null")).ToList();
            if (expressionsToTest.Count == 0)
                return exp;
            ExpressionSyntax expressionToTest =
                SyntaxFactory.ParenthesizedExpression(
                    expressionsToTest.Aggregate((e1, e2) =>
                        SyntaxFactory.BinaryExpression(
                            SyntaxKind.LogicalOrExpression,
                            e1,
                            e2)));
            if (_not)
                return
                    SyntaxFactory.ParenthesizedExpression(
                        SyntaxFactory.BinaryExpression(
                            SyntaxKind.LogicalOrExpression,
                            expressionToTest,
                            exp));
            return
                SyntaxFactory.BinaryExpression(
                    SyntaxKind.LogicalAndExpression,
                    SyntaxFactory.PrefixUnaryExpression(
                        SyntaxKind.LogicalNotExpression,
                            expressionToTest),
                    exp);
        }

        private SyntaxNode VisitAssign(BinaryExpressionSyntax node)
        {
            var right = (ExpressionSyntax)Visit(node.Right);
            if (!(node.Right is ObjectCreationExpressionSyntax))
            {
                var variableName = GetExpressionString(node.Left);
                if (_expressionsToTest.Contains(variableName))
                    AddStatement(BuildIfFromExpressionsToTest());
                var rightString = GetExpressionString(right);
                if (_alreadyTestedNullableExpressions.Contains(rightString))
                    _alreadyTestedNullableExpressions.Add(variableName);
                else if (!IsLINQ(node.Right))
                    RemoveAlreadyTestedVariable(variableName);
            }
            return SyntaxFactory.BinaryExpression(
                SyntaxKindAssignExpression,
                node.Left,
                right);
        }

        private void RemoveAlreadyTestedVariable(string variableName)
        {
            foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.ToList())
                if (Regex.IsMatch(alreadyTestedNullableExpression, string.Concat("^", variableName, "($|.)")))
                {
                    _alreadyTestedNullableExpressions.Remove(alreadyTestedNullableExpression);
                    _removedAlreadyTestedNullableExpressions.Add(alreadyTestedNullableExpression);
                }
        }

        private SyntaxNode VisitCoalesce(BinaryExpressionSyntax node)
        {
            List<StatementSyntax> statementsToAdd;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd))
                _statementsToAdd.Add(_currentStatement, statementsToAdd = new List<StatementSyntax>());

            var value = (ExpressionSyntax)Visit(node.Left);

            var rightBlock = SyntaxFactory.Block();
            var rightTestNull = new TestNull(this)
            {
                _currentStatement = rightBlock,
                _statementsToAdd = _statementsToAdd
            };
            var rightExpression = (ExpressionSyntax)rightTestNull.Visit(node.Right);
            ApplyRemoveStatements(rightTestNull);

            if (_expressionsToTest.Count == 0 && rightTestNull._expressionsToTest.Count == 0 && value == node.Left && rightExpression == node.Right)
                return node;

            statementsToAdd.Add(BuildIfFromExpressionsToTest());

            string valueName = "waqsValue" + Guid.NewGuid().ToString("N");
            var nodeTypeString = _semanticModel.GetTypeInfo(node).Type.ToString();
            var nodeLeftTypeString = _semanticModel.GetTypeInfo(node.Left).Type.ToString();
            statementsToAdd.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.ParseTypeName(nodeLeftTypeString),
                        SyntaxFactory.SeparatedList(
                            new []
                            {
                                SyntaxFactory.VariableDeclarator(valueName)
                                        .WithInitializer(
                                            SyntaxFactory.EqualsValueClause(
                                                value))
                            },
                            new SyntaxToken[0]))));

            var rightStatements = new List<StatementSyntax>() { rightTestNull.BuildIfFromExpressionsToTest() };
            List<StatementSyntax> rightAdditionalStatements;
            if (rightTestNull._statementsToAdd.TryGetValue(rightBlock, out rightAdditionalStatements))
                rightStatements.AddRange(rightAdditionalStatements);
            rightStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        rightExpression)));

            statementsToAdd.Add(
                SyntaxFactory.IfStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
                    SyntaxFactory.Block(
                        rightStatements.Where(s => s != null))));


            if (nodeTypeString != nodeLeftTypeString)
                return SyntaxFactory.ParseExpression(valueName + ".Value");
            return SyntaxFactory.IdentifierName(valueName);
        }

        public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);
            var ifTrueBlock = SyntaxFactory.Block();
            var ifTrueTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = ifTrueBlock,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest).Union(_alreadyTestedNullableExpressionsTmp.Where(e => e.Value == SyntaxKind.LogicalAndExpression).Select(e => e.Key))),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var whenTrueExpression = (ExpressionSyntax)ifTrueTestNull.Visit(node.WhenTrue);
            var ifFalseBlock = SyntaxFactory.Block();
            var ifFalseTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = ifFalseBlock,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest)),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var whenFalseExpression = (ExpressionSyntax)ifFalseTestNull.Visit(node.WhenFalse);
            ApplyRemoveStatements(ifTrueTestNull);
            ApplyRemoveStatements(ifFalseTestNull);
            if (_expressionsToTest.Count == 0 && ifTrueTestNull._expressionsToTest.Count == 0 && ifFalseTestNull._expressionsToTest.Count == 0 && condition == node.Condition && whenTrueExpression == node.WhenTrue && whenFalseExpression == node.WhenFalse)
                return node;

            List<StatementSyntax> statementsToAdd;
            if (!_statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd))
                _statementsToAdd.Add(_currentStatement, statementsToAdd = new List<StatementSyntax>());

            statementsToAdd.Add(BuildIfFromExpressionsToTest());

            if (_fromLinq)
            {
                if (ifTrueTestNull._statementsToAdd.Count != 0 || ifFalseTestNull._statementsToAdd.Count != 0)
                {
                    IfStatementSyntax ifTrueTest, ifFalseTest;
                    statementsToAdd.Add(
                        SyntaxFactory.IfStatement(
                            SyntaxFactory.ConditionalExpression(
                                condition,
                                ifTrueTestNull._statementsToAdd.Count != 0 && (ifTrueTest = ifTrueTestNull.BuildIfFromExpressionsToTest()) != null ? ifTrueTest.Condition : SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression),
                                ifFalseTestNull._statementsToAdd.Count != 0 && (ifFalseTest = ifFalseTestNull.BuildIfFromExpressionsToTest()) != null ? ifFalseTest.Condition : SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression)),
                            SyntaxFactory.Block()));
                }
                return SyntaxFactory.ConditionalExpression(
                    condition,
                    whenTrueExpression,
                    whenFalseExpression);
            }
            string valueName = "waqsValue" + Guid.NewGuid().ToString("N");

            statementsToAdd.Add(
                SyntaxFactory.LocalDeclarationStatement(
                    SyntaxFactory.VariableDeclaration(
                        SyntaxFactory.ParseTypeName(_semanticModel.GetTypeInfo(node).Type.ToString()),
                        SyntaxFactory.SeparatedList(
                            new [] { SyntaxFactory.VariableDeclarator(valueName) },
                            new SyntaxToken[0]))));

            List<StatementSyntax> ifTrueStatements;
            if (!ifTrueTestNull._statementsToAdd.TryGetValue(ifTrueBlock, out ifTrueStatements))
                ifTrueStatements = new List<StatementSyntax>();
            if (ifTrueTestNull._expressionsToTest.Count != 0)
                ifTrueStatements.Add(ifTrueTestNull.BuildIfFromExpressionsToTest());
            ifTrueStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        whenTrueExpression)));
            List<StatementSyntax> ifFalseStatements;
            if (!ifFalseTestNull._statementsToAdd.TryGetValue(ifFalseBlock, out ifFalseStatements))
                ifFalseStatements = new List<StatementSyntax>();
            if (ifFalseTestNull._expressionsToTest.Count != 0)
                ifFalseStatements.Add(ifFalseTestNull.BuildIfFromExpressionsToTest());
            ifFalseStatements.Add(
                SyntaxFactory.ExpressionStatement(
                    SyntaxFactory.BinaryExpression(
                        SyntaxKindAssignExpression,
                        SyntaxFactory.IdentifierName(valueName),
                        whenFalseExpression)));
            statementsToAdd.Add(
                SyntaxFactory.IfStatement(
                    condition,
                    SyntaxFactory.Block(
                        ifTrueStatements.Where(s => s != null)),
                    SyntaxFactory.ElseClause(
                        SyntaxFactory.Block(
                            ifFalseStatements.Where(s => s != null)))));

            return SyntaxFactory.IdentifierName(valueName);
        }

        public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
        {
            var statement = (StatementSyntax)Visit(node.Statement);
            _currentStatement = node;
            var conditionBlock = SyntaxFactory.Block();
            var conditionTestNull = new TestNull(this) { _currentStatement = conditionBlock };
            var condition = (ExpressionSyntax)conditionTestNull.Visit(node.Condition);
            if (conditionTestNull._expressionsToTest.Count != 0)
                conditionTestNull.AddStatement(conditionTestNull.BuildIfFromExpressionsToTest());
            List<StatementSyntax> conditionStatementsToAdd;
            if (conditionTestNull._statementsToAdd.TryGetValue(conditionBlock, out conditionStatementsToAdd) && conditionStatementsToAdd.Count != 0)
            {
                var statementBlock = statement as BlockSyntax;
                List<StatementSyntax> statements;
                if (statementBlock == null)
                    statements = new List<StatementSyntax>() { statement };
                else
                    statements = statementBlock.Statements.ToList();
                statements.AddRange(conditionStatementsToAdd);
                if (conditionStatementsToAdd.OfType<LocalDeclarationStatementSyntax>().Any())
                {
                    string variableName = "waqsTest" + Guid.NewGuid().ToString("N");
                    AddStatement(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.ParseTypeName("bool"),
                                SyntaxFactory.SeparatedList(
                                    new [] { SyntaxFactory.VariableDeclarator(variableName) },
                                    new SyntaxToken[0]))));
                    statements.Add(
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.BinaryExpression(
                                SyntaxKindAssignExpression,
                                SyntaxFactory.IdentifierName(variableName),
                                condition)));
                    condition = SyntaxFactory.IdentifierName(variableName);
                }
                statement = SyntaxFactory.Block(statements.Where(s => s != null));
            }
            return SyntaxFactory.DoStatement(statement, condition);
        }

        public override SyntaxNode VisitForStatement(ForStatementSyntax node)
        {
            bool initializersChange = false;
            var initializers = new List<ExpressionSyntax>();
            if (node.Initializers != null)
                foreach (var initializer in node.Initializers)
                {
                    var initializerValue = (ExpressionSyntax)Visit(initializer);
                    initializers.Add(initializerValue);
                    if (initializerValue != initializer)
                        initializersChange = true;
                }

            var declarationValue = (VariableDeclarationSyntax)Visit(node.Declaration);
            List<VariableDeclaratorSyntax> declarations = null;
            if (declarationValue != null)
                declarations = declarationValue.Variables.ToList();
            bool declarationsChange = declarationValue != node.Declaration;

            List<StatementSyntax> statementsToAdd;
            int statementIndex = _statementsToAdd.TryGetValue(_currentStatement, out statementsToAdd) ? statementsToAdd.Count : 0;
            if (_expressionsToTest.Count != 0)
                statementIndex++;

            var condition = (ExpressionSyntax)Visit(node.Condition);

            var incrementors = new List<ExpressionSyntax>();
            bool incrementorsChange = false;
            foreach (var incrementor in node.Incrementors)
            {
                var incrementorValue = (ExpressionSyntax)Visit(incrementor);
                if (incrementorValue != incrementor)
                    incrementorsChange = true;
                incrementors.Add(incrementorValue);
            }

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            ApplyRemoveStatements(statementTestNull);

            statement = MakeLoopCondition(node.Condition, node.Statement, node.Incrementors, statement, statementTestNull, ref condition, declarationValue, statementIndex, initializers, ref declarations, ref declarationsChange, ref initializersChange, ref incrementors, ref incrementorsChange);

            return SyntaxFactory.ForStatement(
                declarationsChange ?
                    (declarations == null ?
                        null :
                        SyntaxFactory.VariableDeclaration(
                            node.Declaration.Type,
                            SyntaxFactory.SeparatedList(
                                declarations,
                                declarations.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))))) :
                    node.Declaration,
                initializersChange ?
                    SyntaxFactory.SeparatedList(
                        initializers,
                        initializers.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))) :
                    node.Initializers,
                condition,
                incrementorsChange ?
                    SyntaxFactory.SeparatedList(
                        incrementors,
                        incrementors.Skip(1).Select(_ => SyntaxFactory.Token(SyntaxKind.CommaToken))) : node.Incrementors, statement);
        }

        private StatementSyntax MakeLoopCondition(ExpressionSyntax nodeCondition, StatementSyntax nodeStatement, SeparatedSyntaxList<ExpressionSyntax> nodeIncrementors, StatementSyntax statement, TestNull statementTestNull, ref ExpressionSyntax condition, VariableDeclarationSyntax declarationValue, int statementIndex, List<ExpressionSyntax> initializers, ref List<VariableDeclaratorSyntax> declarations, ref bool declarationsChange, ref bool initializersChange, ref List<ExpressionSyntax> incrementors, ref bool incrementorsChange)
        {
            bool changeCondition = false;
            List<StatementSyntax> statementAdditionalStatements;
            if (!(nodeStatement == statement && statementTestNull._expressionsToTest.Count == 0) |
                statementTestNull._statementsToAdd.TryGetValue(nodeStatement, out statementAdditionalStatements) ||
                condition != nodeCondition)
            {
                if (statementAdditionalStatements == null)
                    statementAdditionalStatements = new List<StatementSyntax>();
                if (statementTestNull._expressionsToTest.Count != 0)
                    statementAdditionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
                statementAdditionalStatements.Add(statement);
                if (condition != nodeCondition)
                {
                    _pushInBlock = true;
                    changeCondition = true;
                    if (declarationValue != null)
                    {
                        AddStatement(
                            SyntaxFactory.LocalDeclarationStatement(
                                declarationValue), statementIndex++);
                        declarations = null;
                        declarationsChange = true;
                    }
                    if (initializers != null)
                    {
                        foreach (var initializer in initializers)
                            AddStatement(
                                SyntaxFactory.ExpressionStatement(
                                    initializer), statementIndex++);
                        initializers.Clear();
                        initializersChange = true;
                    }
                    if (incrementors != null)
                    {
                        statementAdditionalStatements.AddRange(
                            incrementors.Select(i => SyntaxFactory.ExpressionStatement(i)));
                        incrementors = new List<ExpressionSyntax>();
                        incrementorsChange = true;
                    }
                    var conditionBlock = SyntaxFactory.Block();
                    var conditionTestNull = new TestNull(this) { _currentStatement = conditionBlock };
                    var newCondition = (ExpressionSyntax)conditionTestNull.Visit(nodeCondition);
                    var conditionIdentifier = condition as IdentifierNameSyntax;
                    string testVariableName;
                    if (conditionIdentifier == null)
                    {
                        if (_expressionsToTest.Count != 0)
                            AddStatement(BuildIfFromExpressionsToTest());
                        testVariableName = "waqsTest" + Guid.NewGuid().ToString("N");
                        AddStatement(SyntaxFactory.ParseStatement(string.Concat("bool ", testVariableName, " = ", condition, ";")));
                        condition = SyntaxFactory.IdentifierName(testVariableName);
                        changeCondition = true;
                    }
                    else
                        testVariableName = conditionIdentifier.Identifier.ValueText;
                    if (conditionTestNull._expressionsToTest.Count != 0)
                        conditionTestNull.AddStatement(conditionTestNull.BuildIfFromExpressionsToTest());
                    List<StatementSyntax> conditionAdditionalStatements;
                    if (conditionTestNull._statementsToAdd.TryGetValue(conditionBlock, out conditionAdditionalStatements))
                        statementAdditionalStatements.AddRange(conditionAdditionalStatements);
                    statementAdditionalStatements.Add(
                        SyntaxFactory.ExpressionStatement(
                            SyntaxFactory.BinaryExpression(
                                SyntaxKindAssignExpression,
                                SyntaxFactory.IdentifierName(testVariableName),
                                newCondition
                                )));
                }
                if (statementAdditionalStatements.Count > 1)
                    statement = SyntaxFactory.Block(statementAdditionalStatements.Where(s => s != null));
            }
            if (!changeCondition)
            {
                var conditionBlock2 = SyntaxFactory.Block();
                var conditionTestNull2 = new TestNull(this) { _currentStatement = conditionBlock2 };
                conditionTestNull2.Visit(nodeCondition);
                conditionTestNull2.Visit(nodeIncrementors);
                if (!(conditionTestNull2._expressionsToTest.Count == 0 && conditionTestNull2._statementsToAdd.Count == 0))
                {
                    conditionTestNull2.AddStatement(conditionTestNull2.BuildIfFromExpressionsToTest());
                    List<StatementSyntax> statements;
                    var statementAsBlock = statement as BlockSyntax;
                    if (statementAsBlock != null)
                        statements = statementAsBlock.Statements.ToList();
                    else
                        statements = new List<StatementSyntax>() { statement };
                    statements.AddRange(conditionTestNull2._statementsToAdd[conditionBlock2]);
                    statement = SyntaxFactory.Block(statements.Where(s => s != null));
                }
            }
            return statement;
        }

        public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
        {
            var expressionBlock = SyntaxFactory.Block();
            var expressionTestNull = new TestNull(this) { _currentStatement = expressionBlock };
            var expression = (ExpressionSyntax)expressionTestNull.Visit(node.Expression);
            ApplyRemoveStatements(expressionTestNull);

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            var value = node;

            List<StatementSyntax> statementAdditionalStatements;
            if (!(node.Statement == statement && statementTestNull._expressionsToTest.Count == 0) | statementTestNull._statementsToAdd.TryGetValue(node.Statement, out statementAdditionalStatements))
            {
                if (statementAdditionalStatements == null)
                    statementAdditionalStatements = new List<StatementSyntax>();
                if (statementTestNull._expressionsToTest.Count != 0)
                    statementAdditionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
                statementAdditionalStatements.Add(statement);
                if (statementAdditionalStatements.Count > 1)
                    statement = SyntaxFactory.Block(statementAdditionalStatements.Where(s => s != null));
                value = value.WithStatement(statement);
            }

            ApplyRemoveStatements(statementTestNull);

            List<StatementSyntax> expressionAdditionalStatements;
            if (!expressionTestNull._statementsToAdd.TryGetValue(expressionBlock, out expressionAdditionalStatements))
                expressionAdditionalStatements = new List<StatementSyntax>();

            if (!(node.Expression is QueryExpressionSyntax || IsIQueryable(_semanticModel.GetTypeInfo(node.Expression).Type) || IsLINQ(node.Expression)))
                expressionTestNull.AddExpressionToTest(expression);

            if (expressionTestNull._expressionsToTest.Count != 0)
                expressionAdditionalStatements.Add(expressionTestNull.BuildIfFromExpressionsToTest());

            if (!(node.Expression is QueryExpressionSyntax) && IsIQueryable(_semanticModel.GetTypeInfo(node.Expression).Type))
            {
                expressionAdditionalStatements.Add(expressionTestNull.BuildIfFromExpressionsToTest());
                string variableName = "waqsCollection" + Guid.NewGuid().ToString("N");
                expressionAdditionalStatements.Add(SyntaxFactory.ParseStatement(string.Concat("var ", variableName, " = ", expression.NormalizeWhitespace().ToString(), ";")));
                _expressionsToTest.Add(variableName);
                expressionAdditionalStatements.Add(BuildIfFromExpressionsToTest());
                expression = SyntaxFactory.IdentifierName(variableName);
            }

            _statementsToAdd.Add(node, expressionAdditionalStatements);

            if (node.Expression != expression)
                value = value.WithExpression(expression);

            return value;
        }

        public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);

            int index = _statementsToAdd.Count;
            if (_expressionsToTest.Count != 0)
                index++;

            var statementTestNull = new TestNull(this);
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);

            ApplyRemoveStatements(statementTestNull);

            List<VariableDeclaratorSyntax> declarations = null;
            bool declarationsChange = false;
            bool initializersChange = false;
            List<ExpressionSyntax> incrementors = null;
            bool incrementorsChange = false;
            statement = MakeLoopCondition(node.Condition, node.Statement, SyntaxFactory.SeparatedList<ExpressionSyntax>(), statement, statementTestNull, ref condition, null, index, null, ref declarations, ref declarationsChange, ref initializersChange, ref incrementors, ref incrementorsChange);

            _pushInBlock = false;

            return SyntaxFactory.WhileStatement(condition, statement);
        }

        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            var condition = (ExpressionSyntax)Visit(node.Condition);
            var statementTestNull = new TestNull(_semanticModel)
            {
                _currentStatement = _currentStatement,
                _alreadyTestedNullableExpressions = new HashSet<string>(_alreadyTestedNullableExpressions.Union(_expressionsToTest).Union(_alreadyTestedNullableExpressionsTmp.Where(e => e.Value == SyntaxKind.LogicalAndExpression).Select(e => e.Key))),
                _returnType = _returnType,
                _yield = _yield,
                _statementsToAdd = _statementsToAdd
            };
            var statement = (StatementSyntax)statementTestNull.Visit(node.Statement);
            List<StatementSyntax> additionalStatements;
            if (!statementTestNull._statementsToAdd.TryGetValue(node.Statement, out additionalStatements))
                additionalStatements = new List<StatementSyntax>();
            if (!(statementTestNull._expressionsToTest == null || statementTestNull._expressionsToTest.Count == 0))
                additionalStatements.Add(statementTestNull.BuildIfFromExpressionsToTest());
            if (additionalStatements.Count != 0)
            {
                additionalStatements.Add(statement);
                statement = SyntaxFactory.Block(additionalStatements.Where(s => s != null));
            }
            var result = SyntaxFactory.IfStatement(condition, statement);
            if (node.Else != null)
            {
                var elseClauseTestNull = new TestNull(this) { _statementsToAdd = _statementsToAdd };
                var elseClauseStatement = (StatementSyntax)elseClauseTestNull.Visit(node.Else.Statement);
                List<StatementSyntax> elseAdditionalStatements;
                if (!elseClauseTestNull._statementsToAdd.TryGetValue(node.Else.Statement, out elseAdditionalStatements))
                    elseAdditionalStatements = new List<StatementSyntax>();
                if (!(elseClauseTestNull._expressionsToTest == null || elseClauseTestNull._expressionsToTest.Count == 0))
                    elseAdditionalStatements.Add(elseClauseTestNull.BuildIfFromExpressionsToTest());
                ElseClauseSyntax elseClause;
                if (elseAdditionalStatements.Count == 0)
                    elseClause = SyntaxFactory.ElseClause(elseClauseStatement);
                else
                {
                    var elseStatementBlock = elseClauseStatement as BlockSyntax;
                    if (elseStatementBlock == null)
                        elseAdditionalStatements.Add(elseClauseStatement);
                    else
                        elseAdditionalStatements.AddRange(elseStatementBlock.Statements);
                    var elseBlock = SyntaxFactory.Block();
                    elseBlock = elseBlock.AddStatements(elseAdditionalStatements.Where(s => s != null).ToArray());
                    elseClause = SyntaxFactory.ElseClause(elseBlock);
                }
                result = result.WithElse(elseClause);
                ApplyRemoveStatements(elseClauseTestNull);
                foreach (var additionalAlreadyTest in elseClauseTestNull._alreadyTestedNullableExpressions.Intersect(statementTestNull._alreadyTestedNullableExpressions).Except(_alreadyTestedNullableExpressions).ToList())
                    _alreadyTestedNullableExpressions.Add(additionalAlreadyTest);
            }
            ApplyRemoveStatements(statementTestNull);
            return result;
        }

        public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
        {
            EqualsValueClauseSyntax equalsValueClause;
            if (GetKind(node.Parent) == SyntaxKindAssignExpression)
            {
                var binaryParentLeft = ((BinaryExpressionSyntax)node.Parent).Left;
                var identifierName = binaryParentLeft as IdentifierNameSyntax;
                if (identifierName != null)
                    _alreadyTestedNullableExpressions.Add(identifierName.Identifier.ValueText);
                else
                    throw new NotImplementedException();
            }
            else if ((equalsValueClause = node.Parent as EqualsValueClauseSyntax) != null)
            {
                var variableDeclarator = equalsValueClause.Parent as VariableDeclaratorSyntax;
                if (variableDeclarator != null)
                    _alreadyTestedNullableExpressions.Add(variableDeclarator.Identifier.ValueText);
                else
                    throw new NotImplementedException();
            }
            return base.VisitObjectCreationExpression(node);
        }

        private bool IsIQueryable(ITypeSymbol type)
        {
            return type.ToString() == "System.Linq.IQueryable" || type.Interfaces.Any(i => i.ToString() == "System.Linq.IQueryable");
        }

        public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
        {
            if (IsIQueryable(_semanticModel.GetTypeInfo(node).Type))
            {
                var @from = (FromClauseSyntax)Visit(node.FromClause);
                return node.WithFromClause(@from);
            }
            bool fromLinq = _fromLinq;
            _fromLinq = true;

            var fromBlock = SyntaxFactory.Block();
            var visitor = new TestNull(this) { _currentStatement = fromBlock };
            var newFrom = (FromClauseSyntax)visitor.Visit(node.FromClause);
            if (visitor._expressionsToTest.Count != 0)
                visitor.AddStatement(visitor.BuildIfFromExpressionsToTest());
            List<StatementSyntax> fromAdditionalStatements;
            if (visitor._statementsToAdd.TryGetValue(fromBlock, out fromAdditionalStatements))
                foreach (var s in fromAdditionalStatements)
                    AddStatement(s);

            var value = SyntaxFactory.QueryExpression(newFrom, (QueryBodySyntax)visitor.Visit(node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        public override SyntaxNode VisitFromClause(FromClauseSyntax node)
        {
            var expression = (ExpressionSyntax)Visit(node.Expression);
            MemberAccessExpressionSyntax memberAccessExpression;
            InvocationExpressionSyntax invocationExpression;
            if (!((memberAccessExpression = node.Expression as MemberAccessExpressionSyntax) != null && memberAccessExpression.Expression != null && IsIQueryable(_semanticModel.GetTypeInfo(memberAccessExpression.Expression).Type) || (invocationExpression = node.Expression as InvocationExpressionSyntax) != null && (memberAccessExpression = invocationExpression.Expression as MemberAccessExpressionSyntax) != null && memberAccessExpression.Expression != null && IsIQueryable(_semanticModel.GetTypeInfo(memberAccessExpression.Expression).Type) || IsLINQ(node.Expression)))
                AddExpressionToTest(expression);
            AddStatement(BuildIfFromExpressionsToTest());
            return SyntaxFactory.FromClause(node.Identifier, expression);
        }

        public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
        {
            var clauses = new List<QueryClauseSyntax>();
            foreach (var clause in node.Clauses)
            {
                var clauseBlock = SyntaxFactory.Block();
                var clauseTestNull = new TestNull(this) { _currentStatement = clauseBlock };
                var newClause = (QueryClauseSyntax)clauseTestNull.Visit(clause);
                if (clauseTestNull._expressionsToTest.Count != 0)
                    clauseTestNull.AddStatement(clauseTestNull.BuildIfFromExpressionsToTest());
                List<StatementSyntax> clauseAdditionalStatements;
                if (clauseTestNull._statementsToAdd.TryGetValue(clauseBlock, out clauseAdditionalStatements))
                    clauses.AddRange(ConvertToQueryClauses(clauseAdditionalStatements));
                clauses.Add(newClause);
                foreach (var alreadyTested in clauseTestNull._alreadyTestedNullableExpressions)
                    _alreadyTestedNullableExpressions.Add(alreadyTested);
                ApplyRemoveStatements(clauseTestNull);

            }

            var queryContinuationBlock = SyntaxFactory.Block();
            var queryContinuationTestNull = new TestNull(this) { _currentStatement = queryContinuationBlock };
            var queryContinuation = (QueryContinuationSyntax)queryContinuationTestNull.Visit(node.Continuation);
            ApplyRemoveStatements(queryContinuationTestNull);

            var selectOrGroupBlock = SyntaxFactory.Block();
            var selectOrGroupTestNull = new TestNull(this) { _currentStatement = selectOrGroupBlock };
            var selectOrGroup = (SelectOrGroupClauseSyntax)selectOrGroupTestNull.Visit(node.SelectOrGroup);
            if (selectOrGroupTestNull._expressionsToTest.Count != 0)
                selectOrGroupTestNull.AddStatement(selectOrGroupTestNull.BuildIfFromExpressionsToTest());

            ApplyRemoveStatements(selectOrGroupTestNull);
            List<StatementSyntax> selectOrGroupTestNullAdditionalStatements;
            if (selectOrGroupTestNull._statementsToAdd.TryGetValue(selectOrGroupBlock, out selectOrGroupTestNullAdditionalStatements))
                clauses.AddRange(ConvertToQueryClauses(selectOrGroupTestNullAdditionalStatements));

            return SyntaxFactory.QueryBody(SyntaxFactory.List<QueryClauseSyntax>(clauses), selectOrGroup, queryContinuation);
        }

        private IEnumerable<QueryClauseSyntax> ConvertToQueryClauses(IEnumerable<StatementSyntax> statements)
        {
            var statementsEnumerator = statements.GetEnumerator();
            while (statementsEnumerator.MoveNext())
            {
                var statement = statementsEnumerator.Current;
                if (statement == null)
                    continue;
                var localDeclaration = statement as LocalDeclarationStatementSyntax;
                IfStatementSyntax ifStatement;
                if (localDeclaration != null)
                {
                    var variable = localDeclaration.Declaration.Variables.Single();
                    yield return SyntaxFactory.LetClause(variable.Identifier, variable.Initializer.Value);
                }
                else if ((ifStatement = statement as IfStatementSyntax) != null)
                {
                    if (ifStatement.Else != null)
                        continue;
                    yield return SyntaxFactory.WhereClause(
                        ifStatement.Condition is IdentifierNameSyntax ?
                        ifStatement.Condition :
                        SyntaxFactory.PrefixUnaryExpression(
                            SyntaxKind.LogicalNotExpression,
                            SyntaxFactory.ParenthesizedExpression(
                                ifStatement.Condition)));
                }
                else
                    throw new NotImplementedException();
            }
        }

        public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
        {
            var fromLinq = _fromLinq;
            _fromLinq = false;
            var value = node.WithBody(VisitLambdaBody(node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
        {
            var fromLinq = _fromLinq;
            _fromLinq = false;
            var value = node.WithBody(VisitLambdaBody((CSharpSyntaxNode)node.Body));
            _fromLinq = fromLinq;
            return value;
        }

        private CSharpSyntaxNode VisitLambdaBody(SyntaxNode body)
        {
            var block = SyntaxFactory.Block();
            var lambdaSymbol = (MethodSymbol)_semanticModel.GetSymbolInfo(body.Parent).Symbol;
            var testNull = new TestNull(this) { _currentStatement = block, _yield = new IsYieldVisitor().Visit(body), _returnType = lambdaSymbol.ReturnsVoid ? null : SyntaxFactory.ParseTypeName(lambdaSymbol.ReturnType.ToString()) };
            var bodyValue = testNull.Visit(body);
            if (testNull._expressionsToTest.Count != 0)
                testNull.AddStatement(testNull.BuildIfFromExpressionsToTest());
            ApplyRemoveStatements(testNull, false);
            List<StatementSyntax> additionalStatements;
            if (testNull._statementsToAdd.TryGetValue(block, out additionalStatements))
            {
                additionalStatements.Add(lambdaSymbol.ReturnsVoid ? (StatementSyntax)SyntaxFactory.ExpressionStatement((ExpressionSyntax)bodyValue) : SyntaxFactory.ReturnStatement((ExpressionSyntax)bodyValue));
                return SyntaxFactory.Block(additionalStatements.Where(s => s != null));
            }
            return (CSharpSyntaxNode)bodyValue;
        }

        public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            var value = (ParenthesizedExpressionSyntax)base.VisitParenthesizedExpression(node);
            if (IsNullable(_semanticModel.GetTypeInfo(node.Expression).Type) && !IsLINQ(node.Expression) && (node.Parent is MemberAccessExpressionSyntax || node.Parent is InvocationExpressionSyntax))
            {
                string waqsValueName;
                if (GetKind(node.Expression) == SyntaxKindAssignExpression)
                {
                    var binaryExp = (BinaryExpressionSyntax)value.Expression;
                    waqsValueName = binaryExp.Left.ToString();
                    if (!IsLINQ(node))
                    {
                        bool changed;
                        AddExpressionToTest(value, out changed);
                        if (changed)
                            return value;
                    }
                }
                else
                {
                    AddStatement(BuildIfFromExpressionsToTest());
                    waqsValueName = "waqsValue" + Guid.NewGuid().ToString("N");
                    AddStatement(
                        SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                SyntaxFactory.ParseTypeName("var"),
                                SyntaxFactory.SeparatedList(
                                    new [] 
                                    {
                                        SyntaxFactory.VariableDeclarator(waqsValueName)
                                                .WithInitializer(
                                                SyntaxFactory.EqualsValueClause(
                                                    value.Expression))
                                    },
                                    new SyntaxToken[0]))));
                    _expressionsToTest.Add(waqsValueName);
                }
                return SyntaxFactory.IdentifierName(waqsValueName);
            }
            return value;
        }

        public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
        {
            var expression = (ExpressionSyntax)Visit(node.Expression);
            if (_expressionsToTest.Count != 0)
                AddStatement(BuildIfFromExpressionsToTest());
            var switchSections = new List<SwitchSectionSyntax>();
            var sectionTestNulls = new List<TestNull>();
            foreach (var section in node.Sections)
            {
                var sectionBlock = SyntaxFactory.Block();
                var sectionTestNull = new TestNull(this) { _currentStatement = sectionBlock };
                sectionTestNulls.Add(sectionTestNull);
                var newSection = (SwitchSectionSyntax)sectionTestNull.Visit(section);
                switchSections.Add(newSection);
            }
            foreach (var sectionTestNull in sectionTestNulls)
                ApplyRemoveStatements(sectionTestNull);
            if (switchSections.Any(s => s.Labels.Any(l => GetKind(l.CaseOrDefaultKeyword) == SyntaxKind.DefaultKeyword)))
                foreach (var alreadyTested in sectionTestNulls.Select(s => (IEnumerable<string>)s._alreadyTestedNullableExpressions).Aggregate((atne1, atne2) => atne1.Intersect(atne2)))
                    _alreadyTestedNullableExpressions.Add(alreadyTested);
            return SyntaxFactory.SwitchStatement(expression, SyntaxFactory.List<SwitchSectionSyntax>(switchSections));
        }

        public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
        {
            List<StatementSyntax> statements;
            if (VisitStatements(node.Statements, out statements))
                return node.WithStatements(SyntaxFactory.List<StatementSyntax>(statements.Where(s => s != null)));
            return node;
        }

        public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
        {
            var value = (VariableDeclaratorSyntax)base.VisitVariableDeclarator(node);
            IdentifierNameSyntax initializerIdentifier;
            string initializerVariableName;
            if (value.Initializer != null && (initializerIdentifier = value.Initializer.Value as IdentifierNameSyntax) != null && _alreadyTestedNullableExpressions.Contains(initializerVariableName = initializerIdentifier.Identifier.ValueText))
            {
                var pattern = string.Concat("^(", initializerVariableName, @")((.*)?)$");
                foreach (var alreadyTestedNullableExpression in _alreadyTestedNullableExpressions.Where(atn => Regex.IsMatch(atn, pattern)).ToList())
                    _alreadyTestedNullableExpressions.Add(Regex.Replace(alreadyTestedNullableExpression, pattern, m => value.Identifier.ValueText + m.Groups[2].Value));
            }
            return value;
        }
    }

    public class GetSimpleExpression : SyntaxRewriter
    {
        private bool _changed;

        public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            _changed = false;
            var exp = (ExpressionSyntax)Visit(node.Expression);
            if (exp is IdentifierNameSyntax || _changed)
            {
                _changed = true;
                return exp;
            }
            return base.VisitParenthesizedExpression(node);
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            switch (GetKind(node.OperatorToken))
            {
                case SyntaxKind.EqualsToken:
                    _changed = true;
                    return Visit(node.Right);
            }
            return base.VisitBinaryExpression(node);
        }
    }

    public class IsYieldVisitor : SyntaxVisitorOfBool
    {
        public override bool Visit(SyntaxNode node)
        {
            return node != null && (base.Visit(node) || node.ChildNodes().Any(cn => Visit(cn)));
        }

        public override bool VisitYieldStatement(YieldStatementSyntax node)
        {
            return true;
        }
    }

    class SpecificationsTestNull : TestNull
    {
        public SpecificationsTestNull(ISemanticModel semanticModel, string classPath,
            SpecificationsElements specificationsElements)
            : base(semanticModel)
        {
            ClassName = Path.GetFileNameWithoutExtension(Path.GetFileNameWithoutExtension(classPath));
            SpecificationsElements = specificationsElements;
        }

        protected string ClassName { get; private set; }
        protected SpecificationsElements SpecificationsElements { get; private set; }


        public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            return node;
        }

        public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
        {
            return node;
        }

        public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            if (node.Parent is NamespaceDeclarationSyntax)
                return base.VisitClassDeclaration(node);
            return node;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            if (SpecificationsElements.ExtensionMethods.Any(m => m.Identifier.ValueText == node.Identifier.ValueText &&  SpecificationsElements.MethodSymbolPerMethods[m].Parameters[0].Type.Name == ClassName) || ClassName == "EntitiesOtherSpecifications" && SpecificationsElements.SubMethods.Any(m => m.Identifier.ValueText == node.Identifier.ValueText))
                return base.VisitMethodDeclaration(node);
            return node;
        }
    }

    public class UseServiceVisitor : SyntaxVisitorOfBool
    {
        private ISemanticModel _semanticModel;
        private List<string> _serviceProperties;

        public UseServiceVisitor(ISemanticModel semanticModel, List<string> serviceProperties)
        {
            _semanticModel = semanticModel;
            _serviceProperties = serviceProperties;
        }

        public override bool Visit(SyntaxNode node)
        {
            return base.Visit(node) || node.ChildNodes().Any(c => Visit(c));
        }

        public override bool VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            if (_serviceProperties.Contains(_semanticModel.GetSymbolInfo(node).Symbol.ToString()))
                return true;
            return base.VisitMemberAccessExpression(node);
        }

        public override bool VisitIdentifierName(IdentifierNameSyntax node)
        {
            if (_serviceProperties.Contains(_semanticModel.GetSymbolInfo(node).Symbol.ToString()))
                return true;
            return base.VisitIdentifierName(node);
        }
    }


IEnumerable<TypeSymbol> GetSubTypes(IEnumerable<TypeSymbol> types, TypeSymbol type)
{
    foreach (var t in types.Where(t2 => t2 != type))
    {
        foreach (var st in GetSubTypes(types, t))
            yield return st;
        if (t.BaseType == type)
            yield return t;
    }
}

public class GetTypeSymbols : SyntaxVisitorOfIEnumerableOfTypeSymbol
{
    private ISemanticModel _semanticModel;

    public GetTypeSymbols(ISemanticModel semanticModel)
    {
        _semanticModel = semanticModel;        
    }

    public override IEnumerable<TypeSymbol> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new TypeSymbol[0]).Union(node.ChildNodes().SelectMany(cn => Visit(cn)));
    }

    public override IEnumerable<TypeSymbol> VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        return new TypeSymbol[] { _semanticModel.GetDeclaredSymbol(node) as TypeSymbol };
    }
}

public class GetNamespaceSymbols : SyntaxVisitorOfIEnumerableOfNamespaceSymbol
{
    private ISemanticModel _semanticModel;

    public GetNamespaceSymbols(ISemanticModel semanticModel)
    {
        _semanticModel = semanticModel;
    }

    public override IEnumerable<NamespaceSymbol> Visit(SyntaxNode node)
    {
        return (base.Visit(node) ?? new NamespaceSymbol[0]).Union(node.ChildNodes().SelectMany(cn => Visit(cn)));
    }

    public override IEnumerable<NamespaceSymbol> VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
        return new NamespaceSymbol[] { _semanticModel.GetDeclaredSymbol(node) as NamespaceSymbol };
    }
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

List<SpecificationPath> GetSpecificationsPathes(XElement specifications)
{
	var specificationPathes = new List<SpecificationPath>();
	if (specifications != null)
		foreach (var specification in specifications.Elements("Specification"))
		{
			var specificationPath = GetSpecificationPath(specification);
			if (specificationPath != null)
				specificationPathes.Add(specificationPath);
		}
	return specificationPathes;
}

SpecificationPath GetSpecificationPath(XElement element)
{
	var slnPathAttribute = element.Attribute("SlnFilePath");
	var csprojPathAttribute = element.Attribute("CsprojPath");
	var folderPathAttribute = element.Attribute("FolderPath");
	if (! (slnPathAttribute == null || csprojPathAttribute == null || folderPathAttribute == null))
		return new SpecificationPath { Sln = slnPathAttribute.Value, Csproj = csprojPathAttribute.Value, Folder = folderPathAttribute.Value };
	return null;
}

void FillSpecifications(List<SpecificationPath> specificationPathes, StringBuilder sb)
{
	sb.Append("new SpecificationPath[] { ");
	foreach (var specificationPath in specificationPathes)
	{
		FillSpecification(specificationPath, sb);
		sb.Append(", ");
	}
	sb.Append(" }");
}

void FillSpecification(SpecificationPath specificationPath, StringBuilder sb)
{
	sb.Append("new SpecificationPath { Sln = @\"");
	sb.Append(specificationPath.Sln);
	sb.Append("\", Csproj = @\"");
	sb.Append(specificationPath.Csproj);
	sb.Append("\", Folder = @\"");
	sb.Append(specificationPath.Folder);
	sb.Append("\"}");
}
#>
<#+ // Copyright (c) Matthieu MEZIL.  All rights reserved.

void WriteServer(string waqsFilePath, string namespaceName = null, string relativePath = "")
{
	var merge = string.IsNullOrEmpty(relativePath) ? "" : ".merge";
	
	CodeGenerationTools code = new CodeGenerationTools(this);
	
	if (namespaceName == null)
		namespaceName = code.VsNamespaceSuggestion();
	EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

	var root = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), waqsFilePath));
	XAttribute edmxPathAttribute = root.Attribute("EdmxPath");
	string edmxPath = null;
	string edmxName = null;
	if (edmxPathAttribute != null)
	{
		edmxPath = edmxPathAttribute.Value;
		edmxName = Path.GetFileNameWithoutExtension(edmxPath);
	}

	var fx = root.Element("Framework");
	if (fx == null)
		throw new InvalidOperationException(@"Framework can't be null");

	string fxCommonNamespaceName = null;
	var fxCommon = fx.Element("Common");
	if (fxCommon != null)
	{
		var fxCommonNamespaceNameAttribute = fxCommon.Attribute("NamespaceName");
		if (fxCommonNamespaceNameAttribute == null)
			fxCommonNamespaceName = "WCFAsyncQueryableServices.Common";
		else
			fxCommonNamespaceName = fxCommonNamespaceNameAttribute.Value;
		var fxCommonGenerateAttribute = fxCommon.Attribute("Generate");
		if (fxCommonGenerateAttribute == null || fxCommonGenerateAttribute.Value != "false")
		{
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.Common.tt");
#>
<#=string.Format("{0}#@ include file=\"{5}WCFAsyncQueryableServices.{4}.{3}.Server.Fx.Common{6}.ttinclude\"#{1}{0}#WriteServerFxCommon(\"{2}\");#{1}", "<", ">", fxCommonNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxSpecificationsNamespaceName = null;
	var fxSpecifications = fx.Element("Specifications");
	if (fxSpecifications != null)
	{
		var fxSpecificationsNamespaceNameAttribute = fxSpecifications.Attribute("NamespaceName");
		if (fxSpecificationsNamespaceNameAttribute == null)
			fxSpecificationsNamespaceName = "WCFAsyncQueryableServices.Specifications";
		else
			fxSpecificationsNamespaceName = fxSpecificationsNamespaceNameAttribute.Value;
		var fxSpecificationsGenerateAttribute = fxSpecifications.Attribute("Generate");
		if (fxSpecificationsGenerateAttribute == null || fxSpecificationsGenerateAttribute.Value != "false")
		{
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.Specifications.tt");
#>
<#=string.Format("{0}#@ include file=\"{5}WCFAsyncQueryableServices.{4}.{3}.Server.Fx.Specifications{6}.ttinclude\"#{1}{0}#WriteServerFxSpecifications(\"{2}\");#{1}", "<", ">", fxSpecificationsNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxEntitiesNamespaceName = null;
	var fxEntities = fx.Element("Entities");
	if (fxEntities != null)
	{
		var fxEntitiesNamespaceNameAttribute = fxEntities.Attribute("NamespaceName");
		if (fxEntitiesNamespaceNameAttribute == null)
			fxEntitiesNamespaceName = "WCFAsyncQueryableServices.Entities";
		else
			fxEntitiesNamespaceName = fxEntitiesNamespaceNameAttribute.Value;
		var fxEntitiesGenerateAttribute = fxEntities.Attribute("Generate");
		if (fxEntitiesGenerateAttribute == null || fxEntitiesGenerateAttribute.Value != "false")
		{
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.Entities.tt");
#>
<#=string.Format("{0}#@ include file=\"{5}WCFAsyncQueryableServices.{4}.{3}.Server.Fx.Entities{6}.ttinclude\"#{1}{0}#WriteServerFxEntities(\"{2}\");#{1}", "<", ">", fxEntitiesNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxDALInterfacesNamespaceName = null;
	var fxDALInterfaces = fx.Element("DALInterfaces");
	if (fxDALInterfaces != null)
	{
		var fxDALInterfacesNamespaceNameAttribute = fxDALInterfaces.Attribute("NamespaceName");
		if (fxDALInterfacesNamespaceNameAttribute == null)
			fxDALInterfacesNamespaceName = "WCFAsyncQueryableServices.DAL.Interfaces";
		else
			fxDALInterfacesNamespaceName = fxDALInterfacesNamespaceNameAttribute.Value;
		var fxDALInterfacesGenerateAttribute = fxDALInterfaces.Attribute("Generate");
		if (fxDALInterfacesGenerateAttribute == null || fxDALInterfacesGenerateAttribute.Value != "false")
		{
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.DAL.Interfaces.tt");
#>
<#=string.Format("{0}#@ include file=\"{7}WCFAsyncQueryableServices.{6}.{5}.Server.Fx.DAL.Interfaces{8}.ttinclude\"#{1}{0}#WriteServerFxDALInterfaces(\"{2}\", \"{3}\", \"{4}\");#{1}", "<", ">", fxCommonNamespaceName, fxEntitiesNamespaceName, fxDALInterfacesNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxDALNamespaceName = null;
	var fxDAL = fx.Element("DAL");
	if (fxDAL != null)
	{
		var fxDALNamespaceNameAttribute = fxDAL.Attribute("NamespaceName");
		if (fxDALNamespaceNameAttribute == null)
			fxDALNamespaceName = "WCFAsyncQueryableServices.DAL";
		else
			fxDALNamespaceName = fxDALNamespaceNameAttribute.Value;
		var fxDALGenerateAttribute = fxDAL.Attribute("Generate");
		if (fxDALGenerateAttribute == null || fxDALGenerateAttribute.Value != "false")
		{
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			if (fxDALInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DALInterfaces can't be null");
			if (fxCommonNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Common can't be null");
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.DAL.tt");
#>
<#=string.Format("{0}#@ include file=\"{8}WCFAsyncQueryableServices.{7}.{6}.Server.Fx.DAL{9}.ttinclude\"#{1}{0}#WriteServerFxDAL(\"{2}\", \"{3}\", \"{4}\", \"{5}\");#{1}", "<", ">", fxEntitiesNamespaceName, fxDALInterfacesNamespaceName, fxCommonNamespaceName, fxDALNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxExpressionsNamespaceName = null;
	var fxExpressions = fx.Element("Expressions");
	if (fxExpressions != null)
	{
		var fxExpressionsAttributeNamespaceNameAttribute = fxExpressions.Attribute("NamespaceName");
		if (fxExpressionsAttributeNamespaceNameAttribute == null)
			fxExpressionsNamespaceName = "WCFAsyncQueryableServices.SerializableExpressions";
		else
			fxExpressionsNamespaceName = fxExpressionsAttributeNamespaceNameAttribute.Value;
		var fxExpressionsGenerateAttribute = fxExpressions.Attribute("Generate");
		if (fxExpressionsGenerateAttribute == null || fxExpressionsGenerateAttribute.Value != "false")
		{
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.SerializableExpressions.tt");
#>
<#=string.Format("{0}#@ include file=\"{7}WCFAsyncQueryableServices.{6}.{5}.Server.Fx.SerializableExpressions{8}.ttinclude\"#{1}{0}#WriteSerializableExpressions(\"{2}\", \"{3}\", \"{4}\");#{1}", "<", ">", fxEntitiesNamespaceName, fxDALInterfacesNamespaceName, fxExpressionsNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxServiceInterfacesNamespaceName = null;
	var fxServiceInterfaces = fx.Element("ServiceInterfaces");
	if (fxServiceInterfaces != null)
	{
		var fxServiceInterfacesNamespaceNameAttribute = fxServiceInterfaces.Attribute("NamespaceName");
		if (fxServiceInterfacesNamespaceNameAttribute == null)
			fxServiceInterfacesNamespaceName = "WCFAsyncQueryableServices.Service.Interfaces";
		else
			fxServiceInterfacesNamespaceName = fxServiceInterfacesNamespaceNameAttribute.Value;
		var fxServiceInterfacesGenerateAttribute = fxServiceInterfaces.Attribute("Generate");
		if (fxServiceInterfacesGenerateAttribute == null || fxServiceInterfacesGenerateAttribute.Value != "false")
		{
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.Service.Interfaces.tt");
#>
<#=string.Format("{0}#@ include file=\"{6}WCFAsyncQueryableServices.{5}.{4}.Server.Fx.Service.Interfaces{7}.ttinclude\"#{1}{0}#WriteServerFxServiceInterfaces(\"{2}\", \"{3}\");#{1}", "<", ">", fxExpressionsNamespaceName, fxServiceInterfacesNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxServiceNamespaceName = null;
	var fxService = fx.Element("Service");
	if (fxService != null)
	{
		var fxServiceNamespaceNameAttribute = fxService.Attribute("NamespaceName");
		if (fxServiceNamespaceNameAttribute == null)
			fxServiceNamespaceName = "WCFAsyncQueryableServices.Service";
		else
			fxServiceNamespaceName = fxServiceNamespaceNameAttribute.Value;
		var fxServiceGenerateAttribute = fxService.Attribute("Generate");
		if (fxServiceGenerateAttribute == null || fxServiceGenerateAttribute.Value != "false")
		{
			fxServiceNamespaceName = "WCFAsyncQueryableServices.Service";
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			if (fxCommonNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Common can't be null");
			if (fxDALInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DALInterfaces can't be null");
			if (fxServiceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceInterfaces can't be null");
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.Service.tt");
#>
<#=string.Format("{0}#@ include file=\"{11}WCFAsyncQueryableServices.{10}.{9}.Server.Fx.Service{12}.ttinclude\"#{1}{0}#WriteServerFxService(\"{2}\", \"{3}\", \"{4}\", \"{5}\", \"{6}\", \"{7}\", \"{8}\");#{1}", "<", ">", fxExpressionsNamespaceName, fxCommonNamespaceName, fxEntitiesNamespaceName, fxDALInterfacesNamespaceName, fxServiceInterfacesNamespaceName, fxSpecificationsNamespaceName, fxServiceNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxWCFServiceContractNamespaceName = null;
	var fxWCFServiceContract = fx.Element("WCFServiceContract");
	if (fxWCFServiceContract != null)
	{
		var fxWCFServiceContractNamespaceNameAttribute = fxWCFServiceContract.Attribute("NamespaceName");
		if (fxWCFServiceContractNamespaceNameAttribute == null)
			fxWCFServiceContractNamespaceName = "WCFAsyncQueryableServices.WCFService.Contract";
		else
			fxWCFServiceContractNamespaceName = fxWCFServiceContractNamespaceNameAttribute.Value;
		var fxWCFServiceContractGenerateAttribute = fxWCFServiceContract.Attribute("Generate");
		if (fxWCFServiceContractGenerateAttribute == null || fxWCFServiceContractGenerateAttribute.Value != "false")
		{
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.WCFService.Contract.tt");
#>
<#=string.Format("{0}#@ include file=\"{6}WCFAsyncQueryableServices.{5}.{4}.Server.Fx.WCFService.Contract{7}.ttinclude\"#{1}{0}#WriteServerFxWCFServiceContract(\"{2}\", \"{3}\");#{1}", "<", ">", fxServiceInterfacesNamespaceName, fxWCFServiceContractNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}

	string fxWCFServiceNamespaceName = null;
	var fxWCFService = fx.Element("WCFService");
	if (fxWCFService != null)
	{
		var fxWCFServiceNamespaceNameAttribute = fxWCFService.Attribute("NamespaceName");
		if (fxWCFServiceNamespaceNameAttribute == null)
			fxWCFServiceNamespaceName = "WCFAsyncQueryableServices.WCFService";
		else
			fxWCFServiceNamespaceName = fxWCFServiceNamespaceNameAttribute.Value;
		var fxWCFServiceGenerateAttribute = fxWCFService.Attribute("Generate");
		if (fxWCFServiceGenerateAttribute == null || fxWCFServiceGenerateAttribute.Value != "false")
		{
			if (fxWCFServiceContractNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceContract can't be null");
			if (fxCommonNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Common can't be null");
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.WCFService.tt");
#>
<#=string.Format("{0}#@ include file=\"{9}WCFAsyncQueryableServices.{8}.{7}.Server.Fx.WCFService{10}.ttinclude\"#{1}{0}#WriteServerFxWCFService(\"{2}\", \"{3}\", \"{4}\", \"{5}\", \"{6}\");#{1}", "<", ">", fxServiceInterfacesNamespaceName, fxServiceNamespaceName, fxWCFServiceContractNamespaceName, fxCommonNamespaceName, fxWCFServiceNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.WCFService.ExceptionHandler.tt");
#>
<#=string.Format("{0}#@ include file=\"{8}WCFAsyncQueryableServices.{7}.{6}.Server.Fx.WCFService.ExceptionHandler{9}.ttinclude\"#{1}{0}#WriteServerFxWCFServiceExceptionHandler(\"{2}\", \"{3}\", \"{4}\", \"{5}\");#{1}", "<", ">", fxWCFServiceNamespaceName, fxWCFServiceContractNamespaceName, fxCommonNamespaceName, fxWCFServiceNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
			fileManager.StartNewFile("WCFAsyncQueryableServices.Server.Fx.WCFService.UnityService.tt");
#>
<#=string.Format("{0}#@ include file=\"{5}WCFAsyncQueryableServices.{4}.{3}.Server.Fx.WCFService.Unity{6}.ttinclude\"#{1}{0}#WriteServerFxWCFServiceUnity(\"{2}\");#{1}", "<", ">", fxWCFServiceNamespaceName, netVersion, vsVersion, relativePath, merge)#>
<#+
		}
	}



	var specificationPathes = GetSpecificationsPathes(root.Element("Specifications"));

	string entitiesNamespaceName = null;
	var entities = root.Element("Entities");
	SpecificationPath entitiesPath = null;
	bool generateEntities = false;
	string propertyAttributes = null;
	if (entities != null)
	{
		var entitiesNamespaceNameAttribute = entities.Attribute("NamespaceName");
		if (entitiesNamespaceNameAttribute == null)
			entitiesNamespaceName = namespaceName;
		else
			entitiesNamespaceName = entitiesNamespaceNameAttribute.Value;
				
		entitiesPath = GetSpecificationPath(entities);
		var entitiesGenerateAttribute = entities.Attribute("Generate");
		if (entitiesGenerateAttribute == null || entitiesGenerateAttribute.Value != "false")
		{
			generateEntities = true;
			var entityTypesBaseTypeAttribute = entities.Attribute("EntityTypesBaseType");
			var complexTypesBaseTypeAttribute = entities.Attribute("ComplexTypesBaseType");
			var propertyAttributesAttribute = entities.Attribute("PropertyAttributes");
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.Entities.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.Entities");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerEntities(@\"");
			sb.Append(edmxPath);
			sb.Append("\", \"");
			sb.Append(fxEntitiesNamespaceName);
			sb.Append("\", \"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", ");
			sb.Append(entityTypesBaseTypeAttribute == null ? "null" : "\"" + entityTypesBaseTypeAttribute.Value + "\"");
			sb.Append(", ");
			sb.Append(complexTypesBaseTypeAttribute == null ? "null" : "\"" + complexTypesBaseTypeAttribute.Value + "\"");
			sb.Append(", ");
			sb.Append(propertyAttributes = (propertyAttributesAttribute == null ? "null" : "\"" + propertyAttributesAttribute.Value.Replace("\"", "\\\"") + "\""));
			sb.Append(");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+		
		}
	}

	if (specificationPathes.Count != 0 && entitiesPath == null)
		throw new InvalidOperationException(@"Entities SlnFilePath, CsprojPath and FolderPath could not be null with some specifications");

	var dtos = root.Element("DTOs");
	string dtoNamespaceName = null;
	string dtoWCFNamespace = null;
	var dtoSB = new StringBuilder();
	if (dtos == null)
		dtoSB.Append("null");
	else
	{
		var dtoNamespaceNameAttribute = dtos.Attribute("NamespaceName");
		if (dtoNamespaceNameAttribute == null)
			dtoNamespaceName = namespaceName;
		else
			dtoNamespaceName = dtoNamespaceNameAttribute.Value;
		var dtoWCFNamespaceAttribute = dtos.Attribute("WCFNamespace");
		if (dtoWCFNamespaceAttribute == null)
			dtoWCFNamespace = string.Concat("http://", edmxName, "/DTO");
		else
			dtoWCFNamespace = dtoWCFNamespaceAttribute.Value;
		fileManager.StartNewFile(string.Format("{0}.Server.DTO.tt", edmxName));
		var sb = new StringBuilder();
		sb.Append("<");
		sb.Append("#@ include file=\"");
		sb.Append(relativePath);
		sb.Append("WCFAsyncQueryableServices.");
		sb.Append(vsVersion);
		sb.Append(".");
		sb.Append(netVersion);
		sb.Append(".Server.DTO");
		sb.Append(merge);
		sb.Append(".ttinclude\"#");
		sb.Append("><");
		sb.Append("#WriteServerDTOs(");
		dtoSB.Append("new SpecificationPath[] { ");
		var dtosEnumerator = dtos.Elements("DTO").GetEnumerator();
		if (dtosEnumerator.MoveNext())
			for(;;)
			{
				var dto = dtosEnumerator.Current;
				dtoSB.Append("new SpecificationPath { Sln = @\"");
				dtoSB.Append(dto.Attribute("SlnFilePath").Value);
				dtoSB.Append("\", Csproj = @\"");
				dtoSB.Append(dto.Attribute("CsprojPath").Value);
				dtoSB.Append("\", Folder = @\"");
				dtoSB.Append(dto.Attribute("FolderPath").Value);
				dtoSB.Append("\"}");
				if (! dtosEnumerator.MoveNext())
					break;
				dtoSB.Append(", ");
			}
		dtoSB.Append(" }");
		sb.Append(dtoSB.ToString());
		sb.Append(", \"");
		sb.Append(dtoWCFNamespace);
		sb.Append("\", \"");
		sb.Append(dtoNamespaceName);
		sb.Append("\");#");
		sb.Append(">");
#>
<#=sb.ToString()#>
<#+		
		var withSpecifications = dtos.Attribute("WithSpecifications");
		if (specificationPathes.Count != 0 && (withSpecifications == null || withSpecifications.Value == "true"))
		{
			fileManager.StartNewFile(string.Format("{0}.Server.DTO.Specifications.tt", edmxName));
			sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.DTO.Specifications");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerDTOSpecifications(");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			sb.Append(dtoSB.ToString());
			sb.Append(", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(dtoNamespaceName);
			sb.Append("\");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	if (generateEntities && specificationPathes.Count != 0)
	{
		fileManager.StartNewFile(string.Format("{0}.Server.Entities.Specifications.tt", edmxName));
		var sb = new StringBuilder();
		sb.Append("<");
		sb.Append("#@ include file=\"");
		sb.Append(relativePath);
		sb.Append("WCFAsyncQueryableServices.");
		sb.Append(vsVersion);
		sb.Append(".");
		sb.Append(netVersion);
		sb.Append(".Server.Entities.Specifications");
		sb.Append(merge);
		sb.Append(".ttinclude\"#");
		sb.Append("><");
		sb.Append("#WriteServerEntitiesSpecifications(@\"");
		sb.Append(edmxPath);
		sb.Append("\", ");
		FillSpecifications(specificationPathes, sb);
		sb.Append(", ");
		sb.Append(dtoSB);
		sb.Append(", @\"");
		sb.Append(dtoNamespaceName);
		sb.Append("\", ");
		FillSpecification(entitiesPath, sb);
		sb.Append(", @\"");
		sb.Append(fxSpecificationsNamespaceName);
		sb.Append("\", @\"");
		sb.Append(fxDALInterfacesNamespaceName);
		sb.Append("\", @\"");
		sb.Append(fxServiceInterfacesNamespaceName);
		sb.Append("\", @\"");
		sb.Append(fxEntitiesNamespaceName);
		sb.Append("\", @\"");
		sb.Append(entitiesNamespaceName);
		sb.Append("\", ");
		sb.Append(propertyAttributes);
		sb.Append(");#");
		sb.Append(">");
#>
<#=sb.ToString()#>
<#+
	}

	string dalInterfacesNamespaceName = null;
	var dalInterfaces = root.Element("DALInterfaces");
	if (dalInterfaces != null)
	{
		var dalInterfacesNamespaceNameAttribute = dalInterfaces.Attribute("NamespaceName");
		if (dalInterfacesNamespaceNameAttribute == null)
			dalInterfacesNamespaceName = namespaceName + ".DAL.Interfaces";
		else
			dalInterfacesNamespaceName = dalInterfacesNamespaceNameAttribute.Value;
		var dalInterfacesGenerateAttribute = dalInterfaces.Attribute("Generate");
		if (dalInterfacesGenerateAttribute == null || dalInterfacesGenerateAttribute.Value != "false")
		{
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			if (fxDALInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DALInterfaces can't be null");
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.DAL.Interfaces.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.DAL.Interfaces");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerDALInterfaces(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxEntitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(dalInterfacesNamespaceName);
			sb.Append("\");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	string dalNamespaceName = null;
	var dal = root.Element("DAL");
	if (dal != null)
	{
		var dalNamespaceNameAttribute = dal.Attribute("NamespaceName");
		if (dalNamespaceNameAttribute == null)
			dalNamespaceName = namespaceName + ".DAL";
		else
			dalNamespaceName = dalNamespaceNameAttribute.Value;
		var dalGenerateAttribute = dal.Attribute("Generate");
		if (dalGenerateAttribute == null || dalGenerateAttribute.Value != "false")
		{
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			if (fxDALNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DAL can't be null");
			if (fxDALInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DALInterfaces can't be null");
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			if (dalInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"DALInterfaces can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.DAL.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.DAL");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerDAL(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxCommonNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxEntitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(dalInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(dalNamespaceName);
			sb.Append("\");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
			fileManager.StartNewFile(string.Format("{0}.DAL.edmx.tt", edmxName));
#>
<#=string.Format("{0}#@ include file=\"{6}WCFAsyncQueryableServices.{5}.{4}.Server.DAL.emdx{7}.ttinclude\"#{1}{0}#WriteServerDALEdmx(@\"{2}\", \"{3}\", {8});#{1}", "<", ">", edmxPath, dalNamespaceName, netVersion, vsVersion, relativePath, merge, string.IsNullOrEmpty(relativePath) ? "null" : string.Concat("@\"", relativePath, "\""))#>
<#+
		}
	}

	string serviceInterfacesNamespaceName = null;
	var serviceInterfaces = root.Element("ServiceInterfaces");
	if (serviceInterfaces != null)
	{
		var serviceInterfacesNamespaceNameAttribute = serviceInterfaces.Attribute("NamespaceName");
		if (serviceInterfacesNamespaceNameAttribute == null)
			serviceInterfacesNamespaceName = namespaceName + ".Service.Interfaces";
		else
			serviceInterfacesNamespaceName = serviceInterfacesNamespaceNameAttribute.Value;
		var serviceInterfacesGenerateAttribute = serviceInterfaces.Attribute("Generate");
		if (serviceInterfacesGenerateAttribute == null || serviceInterfacesGenerateAttribute.Value != "false")
		{
			if (fxServiceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceInterfaces can't be null");
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.Service.Interfaces.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.Service.Interfaces");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerServiceInterfaces(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			sb.Append(dtoSB);
			sb.Append(", @\"");
			sb.Append(dtoNamespaceName);
			sb.Append("\", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxExpressionsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(serviceInterfacesNamespaceName);
			if (string.IsNullOrEmpty(relativePath))
				sb.Append("\", null");
			else
			{
				sb.Append("\", @\"");
				sb.Append(relativePath);
				sb.Append("\"");
			}
			sb.Append(");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	string serviceNamespaceName = null;
	var service = root.Element("Service");
	if (service != null)
	{
		var serviceNamespaceNameAttribute = service.Attribute("NamespaceName");
		if (serviceNamespaceNameAttribute == null)
			serviceNamespaceName = namespaceName + ".Service";
		else
			serviceNamespaceName = serviceNamespaceNameAttribute.Value;
		var serviceGenerateAttribute = service.Attribute("Generate");
		if (serviceGenerateAttribute == null || serviceGenerateAttribute.Value != "false")
		{
			var parallelAttribute = service.Attribute("Parallel");
			var parallel = parallelAttribute == null ? "true" : parallelAttribute.Value;
			if (fxEntitiesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Entities can't be null");
			if (fxDALInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\DALInterfaces can't be null");
			if (fxServiceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceInterfaces can't be null");
			if (fxServiceNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Service can't be null");
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			if (serviceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"ServiceInterfaces can't be null");
			if (dalInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"DALInterfaces can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.Service.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.Service");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerService(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			sb.Append(dtoSB);
			sb.Append(", @\"");
			sb.Append(dtoNamespaceName);
			sb.Append("\", \"");
			sb.Append(dtoWCFNamespace);
			sb.Append("\", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxCommonNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxEntitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxExpressionsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(serviceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(dalInterfacesNamespaceName);
			sb.Append("\", ");
			sb.Append(parallel);
			sb.Append(", @\"");
			sb.Append(serviceNamespaceName);
			if (string.IsNullOrEmpty(relativePath))
				sb.Append("\", null");
			else
			{
				sb.Append("\", @\"");
				sb.Append(relativePath);
				sb.Append("\"");
			}
			sb.Append(");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	string wcfServiceContractNamespaceName = null;
	var wcfServiceContract = root.Element("WCFServiceContract");
	if (wcfServiceContract != null)
	{
		var wcfServiceContractNamespaceNameAttribute = wcfServiceContract.Attribute("NamespaceName");
		if (wcfServiceContractNamespaceNameAttribute == null)
			wcfServiceContractNamespaceName = namespaceName + ".WCFService.Contract";
		else
			wcfServiceContractNamespaceName = wcfServiceContractNamespaceNameAttribute.Value;
		var wcfServiceContractGenerateAttribute = wcfServiceContract.Attribute("Generate");
		if (wcfServiceContractGenerateAttribute == null || wcfServiceContractGenerateAttribute.Value != "false")
		{
			if (fxWCFServiceContractNamespaceName == null)
				throw new InvalidOperationException(@"Framework\WCFServiceInterfaces can't be null");
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			if (fxServiceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceInterfaces can't be null");
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			if (serviceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"ServiceInterfaces can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.WCFService.Contract.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.WCFService.Contract");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerWCFServiceContract(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			sb.Append(dtoSB);
			sb.Append(", @\"");
			sb.Append(dtoNamespaceName);
			sb.Append("\", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxWCFServiceContractNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxExpressionsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(serviceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(wcfServiceContractNamespaceName);
			sb.Append("\");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	string wcfServiceNamespaceName = null;
	var wcfservice = root.Element("WCFService");
	if (wcfservice != null)
	{
		var wcfServiceNamespaceNameAttribute = wcfservice.Attribute("NamespaceName");
		if (wcfServiceNamespaceNameAttribute == null)
			wcfServiceNamespaceName = namespaceName + "WCFService";
		else
			wcfServiceNamespaceName = wcfServiceNamespaceNameAttribute.Value;
		var wcfserviceGenerateAttribute = wcfservice.Attribute("Generate");
		if (wcfserviceGenerateAttribute == null || wcfserviceGenerateAttribute.Value != "false")
		{
			wcfServiceNamespaceName = namespaceName + ".WCFService";
			if (fxCommonNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Common can't be null");
			if (fxWCFServiceContractNamespaceName == null)
				throw new InvalidOperationException(@"Framework\WCFServiceContract can't be null");
			if (fxServiceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"Framework\ServiceInterfaces can't be null");
			if (fxWCFServiceNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Service can't be null");
			if (fxExpressionsNamespaceName == null)
				throw new InvalidOperationException(@"Framework\Expressions can't be null");
			if (entitiesNamespaceName == null)
				throw new InvalidOperationException(@"Entities can't be null");
			if (serviceInterfacesNamespaceName == null)
				throw new InvalidOperationException(@"ServiceInterfaces can't be null");
			if (wcfServiceContractNamespaceName == null)
				throw new InvalidOperationException(@"ServiceContract can't be null");
			fileManager.StartNewFile(string.Format("{0}.Server.WCFService.tt", edmxName));
			var sb = new StringBuilder();
			sb.Append("<");
			sb.Append("#@ include file=\"");
			sb.Append(relativePath);
			sb.Append("WCFAsyncQueryableServices.");
			sb.Append(vsVersion);
			sb.Append(".");
			sb.Append(netVersion);
			sb.Append(".Server.WCFService");
			sb.Append(merge);
			sb.Append(".ttinclude\"#");
			sb.Append("><");
			sb.Append("#WriteServerWCFService(@\"");
			sb.Append(edmxPath);
			sb.Append("\", ");
			FillSpecifications(specificationPathes, sb);
			sb.Append(", ");
			sb.Append(dtoSB);
			sb.Append(", @\"");
			sb.Append(dtoNamespaceName);
			sb.Append("\", ");
			FillSpecification(entitiesPath, sb);
			sb.Append(", @\"");
			sb.Append(fxCommonNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxSpecificationsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxDALInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxWCFServiceContractNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxServiceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxWCFServiceNamespaceName);
			sb.Append("\", @\"");
			sb.Append(fxExpressionsNamespaceName);
			sb.Append("\", @\"");
			sb.Append(entitiesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(serviceInterfacesNamespaceName);
			sb.Append("\", @\"");
			sb.Append(wcfServiceContractNamespaceName);
			sb.Append("\", @\"");
			sb.Append(wcfServiceNamespaceName);
			sb.Append("\");#");
			sb.Append(">");
#>
<#=sb.ToString()#>
<#+
		}
	}

	XElement webElement = root.Element("Web");
	if (webElement != null)
	{
		var globalClassNameAttribute = webElement.Attribute("GlobalClassName");
		var globalClassName = globalClassNameAttribute == null ? "Global" : globalClassNameAttribute.Value;
		MetadataLoader loader = new MetadataLoader(this);
		EdmItemCollection itemCollection = loader.CreateEdmItemCollection(edmxPath);
		EntityContainer container = itemCollection.GetItems<EntityContainer>().FirstOrDefault();

		var edmxElements = EdmxElements.Get(Host, edmxPath, namespaceName);
		var specificationsElements = SpecificationsElements.Get(Host, specificationPathes.ToArray(), entitiesPath, fxSpecificationsNamespaceName, fxDALInterfacesNamespaceName, fxServiceInterfacesNamespaceName, entitiesNamespaceName, edmxElements, SpecificationsElements.Type.Server);

		fileManager.StartNewFile(string.Format("{0}.Global.asax.cs", edmxName));

		WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "Microsoft.Practices.ServiceLocation", "Microsoft.Practices.Unity", "Edm_EntityMappingGeneratedViews", fxCommonNamespaceName, fxDALNamespaceName, fxDALInterfacesNamespaceName, fxServiceNamespaceName, fxServiceInterfacesNamespaceName, fxServiceNamespaceName + ".L2E", dalNamespaceName, dalInterfacesNamespaceName, serviceNamespaceName, serviceInterfacesNamespaceName, wcfServiceNamespaceName);
	    var contextName = code.Escape(container);

		var servicesPropertiesSB = new StringBuilder();
		foreach (var serviceProperty in specificationsElements.ServiceProperties)
		{
			string serviceName = serviceProperty.Type.ToString();
			servicesPropertiesSB.Append(", ");
			servicesPropertiesSB.Append("(Func<");
			servicesPropertiesSB.Append(serviceName);
			servicesPropertiesSB.Append(">)(() => unityContainer.Resolve<");
			servicesPropertiesSB.Append(serviceName);
			servicesPropertiesSB.Append(">())");
		}
#>
partial class <#=globalClassName#>
{
	public static void <#=edmxName#>ApplicationStart(IUnityContainer unityContainer)
	{
		using (IDataContext context = new <#=contextName#>())
		{
			context.LoadMetadata();
		}
		<#=edmxName#><#=contextName#>ViewsForBaseEntitySets.ComputeMappingHashValue();
		IUnityContainer childUnityContainer = unityContainer.CreateChildContainer();
		childUnityContainer.RegisterType<I<#=contextName#>, <#=contextName#>>(new InjectionFactory(c => new <#=contextName#>()));
		var serviceParameters = new List<object>() { (Func<I<#=contextName#>>)(() => childUnityContainer.Resolve<I<#=contextName#>>()), (Func<I<#=contextName#>, ISerializableExpressionProvider>)(context => new SerializableExpressionProvider((serializableExpression, withSpecificationsProperties) => SerializableExpressionToL2EExpressionConverter.ToL2EExpression(serializableExpression, withSpecificationsProperties, context, new <#=serviceNamespaceName#>.L2E.<#=edmxName#>SerializableExpressionConverter(context, new <#=edmxName#>EntitiesFilters(context))), obj => SerializableExpressionToL2EExpressionConverter.Convert(obj), t => SerializableExpressionToL2EExpressionConverter.GetOriginalType(t))), (Func<<#=edmxName#>ServiceL2E>)(() => (<#=edmxName#>ServiceL2E)childUnityContainer.Resolve<I<#=edmxName#>Service>())<#=servicesPropertiesSB#> };
		Define<#=edmxName#>ServiceParameters(childUnityContainer, serviceParameters);
		unityContainer.RegisterType<I<#=edmxName#>Service, <#=edmxName#>ServiceL2E>(new InjectionConstructor(serviceParameters.ToArray()));
		unityContainer.RegisterInstance(typeof(<#=edmxName#>WCFService).FullName, childUnityContainer);
	}

	static partial void Define<#=edmxName#>ServiceParameters(IUnityContainer unityContainer, List<object> parameters);
}
<#+
		WriteFooter(namespaceName);
	}

	XElement globalContextElement = root.Element("GlobalContext");
	if (globalContextElement != null)
	{
		fileManager.StartNewFile(string.Format("{0}.GlobalSerializedContexts.cs", edmxName));

		WriteHeader(namespaceName, code, "System.Runtime.Serialization", serviceInterfacesNamespaceName, wcfServiceContractNamespaceName);
#>
partial class GlobalSerializedContexts
{
	[DataMember]
	public <#=edmxName#>SerializableContext[] <#=edmxName#>SerializableContexts { get; set; }
}
<#+
		WriteFooter(namespaceName);

		fileManager.StartNewFile(string.Format("{0}.GlobalWCFService.cs", edmxName));

		WriteHeader(namespaceName, code, "Microsoft.Practices.ServiceLocation", "Microsoft.Practices.Unity", wcfServiceNamespaceName, wcfServiceContractNamespaceName);
#>
public partial class GlobalWCFService
{
	private void <#=edmxName#>SaveChanges(GlobalSerializedContexts clientContexts)
	{
		for (int i = 0 ; i < clientContexts.<#=edmxName#>SerializableContexts.Length ; i ++)
			clientContexts.<#=edmxName#>SerializableContexts[i] = ServiceLocator.Current.GetInstance<IUnityContainer>(typeof(<#=edmxName#>WCFService).FullName).Resolve<<#=edmxName#>WCFService>().SaveChanges(clientContexts.<#=edmxName#>SerializableContexts[i]);
	}
}
<#+
		WriteFooter(namespaceName);

		fileManager.StartNewFile(string.Format("{0}.IGlobalWCFService.cs", edmxName));

		WriteHeader(namespaceName, code, wcfServiceContractNamespaceName);
#>
[<#=edmxName#>Faults]
public partial interface IGlobalWCFService
{
}
<#+
		WriteFooter(namespaceName);
	}

	fileManager.Process();
}
#>
<#+ // Copyright (c) Matthieu MEZIL.  All rights reserved.

string vsVersion = "VS12";
#>
<#+ // Copyright (c) Matthieu MEZIL.  All rights reserved.

string netVersion = "NET45";
#>

