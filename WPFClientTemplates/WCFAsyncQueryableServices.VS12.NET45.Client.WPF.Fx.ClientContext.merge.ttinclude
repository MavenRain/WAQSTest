
<#@import namespace="System.Text.RegularExpressions"#><#@ assembly name="System.Core" #><#@ assembly name="System.Data" #><#@ assembly name="System.Data.Entity" #><#@ assembly name="System.Data.Entity.Design" #><#@ assembly name="System.Xml" #><#@ assembly name="System.Xml.Linq"#><#@ assembly name="EnvDTE"#><#@ import namespace="System" #><#@ import namespace="System.Linq" #><#@ import namespace="System.IO" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="System.Data.Objects" #><#@ import namespace="System.Data.Objects.DataClasses" #><#@ import namespace="System.Xml" #><#@ import namespace="System.Xml.Linq" #><#@ import namespace="System.Globalization" #><#@ import namespace="System.Reflection" #><#@ import namespace="System.Data.Metadata.Edm" #><#@ import namespace="System.Data.Mapping" #><#@ import namespace="System.Data.Entity.Design" #><#@ import namespace="System.CodeDom" #><#@ import namespace="System.CodeDom.Compiler" #><#@ import namespace="Microsoft.CSharp"#><#@ import namespace="System.Text"#><#@ import namespace="Microsoft.VisualStudio.TextTemplating"#><#@ template language="C#" debug="false" hostspecific="true"#><#@ output extension=".txt"#>
<#+// Copyright (c) Microsoft Corporation.  All rights reserved.
// Copyright (c) Matthieu MEZIL.  All rights reserved.

public class EdmxElements
{
    private EdmxElements(ITextTemplatingEngineHost host, string edmxPath, string namespaceName)
    {
        EdmxPath = edmxPath;
        Code = new CodeGenerationTools(this);
        NamespaceName = namespaceName ?? Code.VsNamespaceSuggestion();
        MetadataTools = new MetadataTools(this);
        Loader = new MetadataLoader(this);
        ItemCollection = Loader.CreateEdmItemCollection(EdmxPath);
        EdmxName = Path.GetFileNameWithoutExtension(EdmxPath);
        Container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
        EntityTypes = ItemCollection.GetItems<EntityType>().ToList();
        ComplexTypes = ItemCollection.GetItems<ComplexType>().ToList();
        EdmTypes = EntityTypes.Cast<StructuralType>().Union(ComplexTypes).ToList();
        EntitySets = Container.BaseEntitySets.OfType<EntitySet>().ToList();
        FunctionImports = Container.FunctionImports.ToList();
    }

    private EdmxElements()
    {
    }

    public static EdmxElements Get(ITextTemplatingEngineHost host, string edmxPath, string namespaceName = null)
    {
        return Get(host, ref edmxPath, namespaceName);
    }

    public static EdmxElements Get(ITextTemplatingEngineHost host, ref string edmxPath, string namespaceName = null)
    {
        edmxPath = Path.GetFullPath(host.ResolvePath(edmxPath));
        return new EdmxElements(host, edmxPath, namespaceName);
    }

    public string EdmxPath { get; private set; }
    public string NamespaceName { get; private set; }
    public string EdmxName { get; private set; }
    public MetadataTools MetadataTools { get; private set; }
    public CodeGenerationTools Code { get; private set; }
    public MetadataLoader Loader { get; private set; }
    public EdmItemCollection ItemCollection { get; private set; }
    public List<EntityType> EntityTypes { get; private set; }
    public List<ComplexType> ComplexTypes { get; private set; }
    public List<StructuralType> EdmTypes { get; private set; }
    public List<EntitySet> EntitySets { get; private set; }
    public List<EdmFunction> FunctionImports { get; private set; }
    public EntityContainer Container { get; private set; }

    private StoreItemCollection _storeItemCollection;
    public StoreItemCollection StoreItemCollection
    {
        get 
        {
            if (_storeItemCollection == null)
                Loader.TryCreateStoreItemCollection(EdmxPath, out _storeItemCollection);
            return _storeItemCollection; 
        }
    }

    private EntityContainer _storeContainer;
    public EntityContainer StoreContainer
    {
        get { return _storeContainer ?? (_storeContainer = StoreItemCollection.GetItems<EntityContainer>().First()); }
    }

    private string _storeContainerName;
    public string StoreContainerName 
    {
        get { return _storeContainerName ?? (_storeContainerName = StoreContainer.Name); }
    }

    private StorageMappingItemCollection _mappingCollection;
    public StorageMappingItemCollection MappingCollection
    {
        get 
        { 
            if (_mappingCollection == null)
                Loader.TryCreateStorageMappingItemCollection(EdmxPath, ItemCollection, StoreItemCollection, out _mappingCollection);
            return _mappingCollection;
        }
    }
}


partial class WritingFunctions
{
    private Action<string> _write;

    public WritingFunctions(Action<string> write)
    {
        _write = write;
    }

    public void Write(string text)
    {
        _write(text);
    }
}

public static class EdmFunctionExtensions
{
    public static string GetParameters(EdmFunction edmFunction, EdmxElements edmxElements)
    {
        FunctionImportParameter[] parameters;
        return GetParameters(edmFunction, edmxElements, out parameters);
    }
    public static string GetParameters(EdmFunction edmFunction, EdmxElements edmxElements, out FunctionImportParameter[] parameters)
    {
        parameters = FunctionImportParameter.Create(edmFunction.Parameters, edmxElements.Code, edmxElements.MetadataTools).ToArray();
        return String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName));
    }

    public static string GetReturnTypeName(EdmFunction edmFunction, EdmxElements edmxElements)
    {
        TypeUsage returnType;
        return GetReturnTypeName(edmFunction, edmxElements, out returnType);
    }
    public static string GetReturnTypeName(EdmFunction edmFunction, EdmxElements edmxElements, out TypeUsage returnType)
    {
        returnType = edmxElements.MetadataTools.GetElementType(edmFunction.ReturnParameter.TypeUsage);
        if (returnType == null)
            return null;
        return edmxElements.Code.Escape(returnType);
    }
}

public static string GetPlurial(string entityTypeName)
{
    return entityTypeName.EndsWith("y") ? entityTypeName.Substring(0, entityTypeName.Length - 1) + "ies" : entityTypeName.EndsWith("s") ? entityTypeName + "es" : entityTypeName + "s";
}

public static string GetPlurial(CodeGenerationTools code, EntityContainer container, EdmType edmType)
{
    var entityType = edmType as EntityType;

    EntitySet entitySet;
    if (entityType != null && (entitySet = GetEntitySet(container, entityType)) != null && entitySet.ElementType == entityType)
        return code.Escape(entitySet);
    return GetPlurial(code.Escape(edmType));
}

public static string GetContainerNameWithoutEntitiesName(EntityContainer container)
{
    string containerName = container.Name;
    string containerWithoutEntitiesName = containerName;
    if (containerWithoutEntitiesName.EndsWith("Entities") && containerWithoutEntitiesName.Length > 8)
        containerWithoutEntitiesName = containerWithoutEntitiesName.Substring(0, containerWithoutEntitiesName.Length - 8);
    return containerWithoutEntitiesName;
}

public static string PropertyAccessibilityAndVirtual(EdmMember member)
{
    string accessibility = Accessibility.ForProperty(member);
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static bool IsConcurrencyFixed(EdmMember edmMember)
{
    return edmMember.TypeUsage.Facets.Any(f => f.Name == "ConcurrencyMode" && f.Value.ToString() == "Fixed");
}

public static int? MaxLength(EdmMember edmMember)
{
    var maxLengthFacet = edmMember.TypeUsage.Facets.FirstOrDefault(f => f.Name == "MaxLength");
    if (maxLengthFacet != null && maxLengthFacet.Value != null && maxLengthFacet.Value.ToString() != "Max")
        return (int)maxLengthFacet.Value;
    return null;
}

public static bool FixedLength(EdmMember edmMember)
{
    return edmMember.TypeUsage.Facets.Any(f => f.Name == "FixedLength" && f.Value!=null && (bool)f.Value);
}

public static string ReadOnlyPropertyAccessibilityAndVirtual(EdmMember member)
{
    string accessibility = Accessibility.ForReadOnlyProperty(member);
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static string AccessibilityAndVirtual(string accessibility)
{
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}

public static EntitySet GetEntitySet(EntityContainer container, EntityType entityType)
{
    EntitySet value = container.BaseEntitySets.OfType<EntitySet>().FirstOrDefault(es => es.ElementType == entityType);
    if (value != null)
        return value;
    if (entityType.BaseType != null)
        return GetEntitySet(container, (EntityType)entityType.BaseType);
    return null;
}

public static EntitySet GetEntitySet(EntityContainer container, EdmItemCollection itemCollection, string entityTypeName)
{
    return GetEntitySet(container, itemCollection.GetItems<EntityType>().First(et => et.Name == entityTypeName));
}

public static NavigationProperty GetNavigationPropertyFromFK(EdmProperty property)
{
    var entityType = (EntityType)property.DeclaringType;
    foreach (NavigationProperty navigationProperty in entityType.NavigationProperties.Where(n => Accessibility.ForReadOnlyProperty(n) == "public"))
    {
        var association = (AssociationType)navigationProperty.RelationshipType;
        var associationEndMembers = association.AssociationEndMembers.Where(aem => aem.GetEntityType() == entityType);
        var referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
        if (referentialConstraint == null)
            return null;
        if (referentialConstraint != null && associationEndMembers.Contains(referentialConstraint.ToRole) && referentialConstraint.ToProperties.Contains(property) && navigationProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
        {
            return navigationProperty;
        }
    }
    return null;
}

public static NavigationProperty GetOtherNavigationProperty(NavigationProperty navigationProperty)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    return navigationProperty.ToEndMember.GetEntityType().NavigationProperties.FirstOrDefault(np => np.RelationshipType == association && np != navigationProperty);
}

public static IEnumerable<EdmProperty> GetFKsFromNavigationProperty(NavigationProperty navigationProperty)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    var referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
    if (referentialConstraint != null)
    {
        if (navigationProperty.FromEndMember == referentialConstraint.FromRole)
            return referentialConstraint.ToProperties; 
        else
            return referentialConstraint.FromProperties; 
    }
    return new EdmProperty[0];
}

public static IEnumerable<EntityType> GetSubEntityTypes(EdmItemCollection itemCollection, EntityType entityType, string accessibility = "public")
{
    return GetSubEntityTypes(itemCollection, entityType.Name, accessibility);
}

public static IEnumerable<EntityType> GetSubEntityTypes(EdmItemCollection itemCollection, string entityTypeName, string accessibility = "public")
{
    IEnumerable<EntityType> subEntityTypes = itemCollection.GetItems<EntityType>().OrderBy(e => e.Name).Where(e => e.BaseType != null && e.BaseType.Name == entityTypeName);
    if (accessibility != null)
        subEntityTypes = subEntityTypes.Where(e => Accessibility.ForType(e) == accessibility);
    foreach (EntityType et in subEntityTypes)
    {
        foreach (EntityType subEntityType in GetSubEntityTypes(itemCollection, et, accessibility))
            yield return subEntityType;
        yield return et;
    }
}

public EntityType GetEntityType(EdmItemCollection itemCollection, string entityTypeName)
{
    return itemCollection.GetItems<EntityType>().FirstOrDefault(et => et.Name == entityTypeName);
}

public static IEnumerable<EntityType> GetEntityTypes(EdmItemCollection itemCollection, EntitySet entitySet)
{
    var entityType = (EntityType)entitySet.ElementType;
    foreach (var subEntityType in GetSubEntityTypes(itemCollection, entityType))
        yield return subEntityType;
    yield return entityType;
}

public static IEnumerable<EntityType> GetDescendantsThenAscendantsEntityTypes(EdmItemCollection itemCollection, EntityType entityType)
{
    foreach (var subEntityType in GetSubEntityTypes(itemCollection, entityType))
        yield return subEntityType;
    yield return entityType;
    while ((entityType = (EntityType)entityType.BaseType) != null)
        yield return entityType;
}

public static void DefineMetadata()
{
    TemplateMetadata[MetadataConstants.TT_TEMPLATE_NAME] = "CSharpSelfTracking.Types";
    TemplateMetadata[MetadataConstants.TT_TEMPLATE_VERSION] = "5.0";
    TemplateMetadata[MetadataConstants.TT_MINIMUM_ENTITY_FRAMEWORK_VERSION] = "4.0";
}

void WriteHeader(string namespaceName, CodeGenerationTools code, params string[] usings)
{
    new WritingFunctions(Write).WriteHeader(PushIndent, namespaceName, code, usings);
}
partial class WritingFunctions
{
public void WriteHeader(Action<string> pushIndent, string namespaceName, CodeGenerationTools code, params string[] usings)
{
    WriteHeaderWithExternAliases(pushIndent, namespaceName, code, new string[0], usings);
}
}

void WriteCopyright()
{
    new WritingFunctions(Write).WriteCopyright();
}
partial class WritingFunctions
{
public void WriteCopyright()
{
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Matthieu MEZIL.  All rights reserved.
// matthieu.mezil@live.fr

<#+
}
}

void WriteHeaderWithExternAliases(string namespaceName, CodeGenerationTools code, string[] aliases, string[] usings)
{
    new WritingFunctions(Write).WriteHeaderWithExternAliases(PushIndent, namespaceName, code, aliases, usings);
}
partial class WritingFunctions
{
public void WriteHeaderWithExternAliases(Action<string> pushIndent, string namespaceName, CodeGenerationTools code, string[] aliases, string[] usings)
{
    CodeRegion region = new CodeRegion(this);
    WriteCopyright();
    foreach (var a in aliases.Where(al => al != null).Distinct())
    {
#>
extern alias <#=a#>;
<#+
    }	
#>
 
<#+
    foreach (var u in usings.Where(us => ! string.IsNullOrEmpty(us)).Distinct())
    {
#>
using <#=u#>;
<#+
    }	
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>

namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        pushIndent(CodeRegion.GetIndent(1));
    }
}
}

void WriteFooter(string namespaceName)
{
    new WritingFunctions(Write).WriteFooter(PopIndent, namespaceName);
}
partial class WritingFunctions
{
public void WriteFooter(Func<string> popIndent, string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        popIndent();
#>
}
<#+
    }
}
}

public partial class OriginalValueMembers
{
    private readonly HashSet<EdmProperty> _concurrencyMembers;

    public OriginalValueMembers(bool recordRequiredOriginalValuesOnly, MetadataWorkspace metadataWorkspace, MetadataTools metadataTools)
    {
        if (recordRequiredOriginalValuesOnly)
            try
            {
                _concurrencyMembers = new HashSet<EdmProperty>();
                foreach (EntityContainer container in metadataWorkspace.GetItems<EntityContainer>(DataSpace.CSpace))
                {
                    ILookup<EntityType, EntityType> directSubTypeLookup = metadataWorkspace.GetItems<EntityType>(DataSpace.CSpace).ToLookup(e => (EntityType)e.BaseType);
                    foreach (EntitySetBase eSet in container.BaseEntitySets.Where(es => es.BuiltInTypeKind == BuiltInTypeKind.EntitySet))
                    {
                        List<EntityType> subTypes = new List<EntityType>();
                        GetSubtypes(directSubTypeLookup, (EntityType)eSet.ElementType, subTypes);
                        foreach (EntityType eType in subTypes)
                            foreach (EdmProperty member in GetRelevantMembersForUpdate(metadataWorkspace, eSet, eType, true))
                                _concurrencyMembers.Add(member);
                    }
                }

                foreach (AssociationType assoc in metadataWorkspace.GetItems<AssociationType>(DataSpace.CSpace).Where(a => a.IsForeignKey))
                    foreach (EdmProperty toProperty in assoc.ReferentialConstraints[0].ToProperties)
                        _concurrencyMembers.Add(toProperty);
            }
            catch (Exception)
            {
                _concurrencyMembers = null;
            }
    }

    public bool IsOriginalValueMember(EdmProperty edmProperty)
    {
        return _concurrencyMembers == null || _concurrencyMembers.Contains(edmProperty);
    }

    private static void GetSubtypes(ILookup<EntityType, EntityType> lookup, EntityType eType, List<EntityType> subTypes)
    {
        subTypes.Add(eType);
        foreach (EntityType subType in lookup[eType])
            GetSubtypes(lookup, subType, subTypes);
    }
}

bool VerifyTypesAreCaseInsensitiveUnique(EdmItemCollection itemCollection)
{
    Dictionary<string, bool> alreadySeen = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
    foreach(StructuralType type in itemCollection.GetItems<StructuralType>())
    {
        if (!(type is EntityType || type is ComplexType))
            continue;

        if (alreadySeen.ContainsKey(type.FullName))
        {
            Error(String.Format(CultureInfo.CurrentCulture, "This template does not support types that differ only by case, the types {0} are not supported", type.FullName));
            return false;
        }
        else
            alreadySeen.Add(type.FullName, true);
    }

    return true;
}

// True if the association for the specified navigation property is an identifying relationship or a foreign key relationship.
public static bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, NavigationProperty navProperty)
{
    if (tools == null)
        throw new ArgumentNullException("tools");

    if (navProperty == null)
        throw new ArgumentNullException("navProperty");

    return IsForeignKeyOrIdentifyingRelationship(tools, (AssociationType)navProperty.RelationshipType);
}

// True if the specified association is an identifying relationship or a foreign key relationship.
public static bool IsForeignKeyOrIdentifyingRelationship(MetadataTools tools, AssociationType association)
{
    if (tools == null)
        throw new ArgumentNullException("tools");

    if (association == null)
        throw new ArgumentNullException("association");

    return association.IsForeignKey || tools.IsIdentifyingRelationship(association);
}

public static bool IsPublic(EdmMember member)
{
    string setter = Accessibility.ForWriteOnlyProperty(member);
    string getter = Accessibility.ForReadOnlyProperty(member);

    return getter == "public" && setter == "public" && (member.TypeUsage.EdmType is ComplexType ? Accessibility.ForType(member.TypeUsage.EdmType) == "public" : true);
}
public static bool IsPublicOrInternal(EdmMember member)
{
    string setter = Accessibility.ForWriteOnlyProperty(member);
    string getter = Accessibility.ForReadOnlyProperty(member);
    string typeAccessibility;
    return (getter == "public" || getter == "internal") && (setter == "public" || setter == "internal") && (member.TypeUsage.EdmType is ComplexType ? ((typeAccessibility = Accessibility.ForType(member.TypeUsage.EdmType)) == "public" || typeAccessibility == "internal") : true);
}

public static bool IsPublic(EdmFunction method)
{
    return Accessibility.ForMethod(method) == "public";
}
public static bool IsPublicOrInternal(EdmFunction method)
{
    string methodAccessibility = Accessibility.ForMethod(method);
    return methodAccessibility == "public" || methodAccessibility == "internal";
}

public static bool IsPublic(NavigationProperty np)
{
    if (np == null || np.ToEndMember == null)
        return false;
    return IsPublic((EdmMember)np) && Accessibility.ForType(np.ToEndMember.GetEntityType()) == "public";
}
public static bool IsPublicOrInternal(NavigationProperty np)
{
    if (np == null || np.ToEndMember == null)
        return false;
    string typeAccessibility;
    return IsPublicOrInternal((EdmMember)np) && ((typeAccessibility = Accessibility.ForType(np.ToEndMember.GetEntityType())) == "public" || typeAccessibility == "internal");
}

public static bool IsPublic(EdmType type)
{
    return Accessibility.ForType(type) == "public";
}

public static IEnumerable<EdmProperty> GetCSDLIdentityProperties(EntityType entityType)
{
    return entityType.Properties.Where(p => p.MetadataProperties.Select(mp => mp.Value).OfType<string>().Any(sgp => sgp == "Identity"));
}

public static IEnumerable<EdmProperty> GetCSDLComputedProperties(EntityType entityType)
{
    return entityType.Properties.Where(p => p.MetadataProperties.Select(mp => mp.Value).OfType<string>().Any(sgp => sgp == "Computed"));
}

public IEnumerable<string> GetIdentityProperties(string inputFile, EntityType entityType)
{
    return GetIdentityProperties(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetIdentityProperties(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Identity", hostResolvePath).Distinct();
}

public bool HasTemporaryKeys(string inputFile, EntityType entityType)
{
    return HasTemporaryKeys(inputFile, entityType, HostResolvePath);
}
public static bool HasTemporaryKeys(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Identity", hostResolvePath).Any() || entityType.NavigationProperties.Any(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne && HasTemporaryKeys(inputFile, np.ToEndMember.GetEntityType(), hostResolvePath));
}

public string HostResolvePath(string path)
{
    return Host.ResolvePath(path);
}

public bool CouldHaveCSDLTemporaryKeys(EntityType entityType)
{
    return CouldHaveCSDLTemporaryKeys(entityType, HostResolvePath);
}
public static bool CouldHaveCSDLTemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return HasCSDLTemporaryKeys(entityType, hostResolvePath) || CouldHaveCSDLTemporaryKeysNps(entityType, hostResolvePath, navigationProperties).Any();
}

public IEnumerable<NavigationProperty> CouldHaveCSDLTemporaryKeysNps(EntityType entityType)
{
    return CouldHaveCSDLTemporaryKeysNps(entityType, HostResolvePath);
}
public static IEnumerable<NavigationProperty> CouldHaveCSDLTemporaryKeysNps(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return entityType.NavigationProperties.Where(np => 
        {
            if (navigationProperties.Contains(np) || !np.GetDependentProperties().Any())
                return false;
            navigationProperties.Add(np);
            IEnumerable<EdmProperty> fromProperties, toProperties;
            GetNavigationPropertyReferentialConstraintsEnumerables(np, out fromProperties, out toProperties);
            return np.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many && fromProperties.Any(f => entityType.KeyMembers.Contains(f)) && CouldHaveCSDLTemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath, navigationProperties);
        });
}

public IEnumerable<EdmMember> TemporaryKeys(EntityType entityType)
{
    return TemporaryKeys(entityType, HostResolvePath);
}
public static IEnumerable<EdmMember> TemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath, List<NavigationProperty> navigationProperties = null)
{
    if (navigationProperties == null)
        navigationProperties = new List<NavigationProperty>();
    return GetCSDLIdentityProperties(entityType).Cast<EdmMember>().Intersect(entityType.KeyMembers).Union(CouldHaveCSDLTemporaryKeysNps(entityType, hostResolvePath).SelectMany<NavigationProperty, EdmMember>(np => 
        {
            if (navigationProperties.Contains(np))
                return new EdmMember[0];
            navigationProperties.Add(np);
            IEnumerable<EdmProperty> fromProperties, toProperties;
            GetNavigationPropertyReferentialConstraintsEnumerables(np, out fromProperties, out toProperties);
            var toTemporaryKeys = TemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath, navigationProperties).Intersect(toProperties);
            IEnumerator<EdmProperty> fromPropertiesEnumerator = fromProperties.GetEnumerator(), toPropertiesEnumerator = toProperties.GetEnumerator();
            var result = new List<EdmMember>();
            while (fromPropertiesEnumerator.MoveNext() && toPropertiesEnumerator.MoveNext())
                if (toTemporaryKeys.Contains(toPropertiesEnumerator.Current))
                    result.Add(fromPropertiesEnumerator.Current);
            return result;
        })).Distinct();
}

public bool HasCSDLTemporaryKeys(EntityType entityType)
{
    return HasCSDLTemporaryKeys(entityType, HostResolvePath);
}
public static bool HasCSDLTemporaryKeys(EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetCSDLIdentityProperties(entityType).Any() || entityType.NavigationProperties.Any(np => np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.One && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.ZeroOrOne && HasCSDLTemporaryKeys(np.ToEndMember.GetEntityType(), hostResolvePath));
}

public IEnumerable<string> GetComputedProperties(string inputFile, EntityType entityType)
{
    return GetComputedProperties(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetComputedProperties(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, "Computed", hostResolvePath).Distinct();
}

public IEnumerable<string> GetStoreGeneratedPropertiesPrivate(string inputFile, EntityType entityType, string storeGeneratedPattern)
{
    return GetStoreGeneratedPropertiesPrivate(inputFile, entityType, storeGeneratedPattern, HostResolvePath);
}
public static IEnumerable<string> GetStoreGeneratedPropertiesPrivate(string inputFile, EntityType entityType, string storeGeneratedPattern, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityTypeLoop.NamespaceName, ".", entityTypeLoop.Name, @"(?:\))?$")));
        if (entityTypeMapping != null) 
            foreach (var mappingFragment in entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)))
            {
                foreach (var storeGeneratedProp in GetStoreGeneratedPropertiesPrivate(runtime, mappingFragment, mappingFragment.Attribute("StoreEntitySet").Value, storeGeneratedPattern, edm_ns, msl_ns, ssdl_ns))
                    yield return storeGeneratedProp;
            }
    }
}

public static IEnumerable<string> GetStoreGeneratedPropertiesPrivate(XElement runtime, XElement mappingParent, string table, string storeGeneratedPattern, string edm_ns, string msl_ns, string ssdl_ns, string prefix = "")
{
    foreach (var scalarProperty in mappingParent.Elements(XName.Get("ScalarProperty", msl_ns)))
    {
        var column = scalarProperty.Attribute("ColumnName").Value;
        XAttribute storeGeneratedPatternAttribute;
        if ((storeGeneratedPatternAttribute = runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("EntityType", ssdl_ns)).First(et => et.Attribute("Name").Value == table).Elements(XName.Get("Property", ssdl_ns)).First(p => p.Attribute("Name").Value == column).Attribute("StoreGeneratedPattern")) != null && storeGeneratedPatternAttribute.Value == storeGeneratedPattern)
            yield return prefix + scalarProperty.Attribute("Name").Value;
    }
    foreach (var complexProperty in mappingParent.Elements(XName.Get("ComplexProperty", msl_ns)))
        foreach (var storeGeneratedProp in GetStoreGeneratedPropertiesPrivate(runtime, complexProperty, table, storeGeneratedPattern, edm_ns, msl_ns, ssdl_ns, prefix = complexProperty.Attribute("Name").Value + "."))
            yield return storeGeneratedProp;
}

public static string InitializedTrackingField(EdmProperty property, CodeGenerationTools code)
{
    string namePart = property.Name + "Initialized";
    if (code.CamelCaseFields)
        namePart = code.CamelCase(namePart);
    return "_" + namePart;
}

public static bool IsSaveReference(MetadataTools tools, NavigationProperty navProperty)
{
    return !IsForeignKeyOrIdentifyingRelationship(tools, navProperty) && navProperty.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many && navProperty.FromEndMember.RelationshipMultiplicity != RelationshipMultiplicity.One;
}

public static string CreateFixupMethodName(RelationshipEndMember endMember)
{
    return String.Format(CultureInfo.InvariantCulture, "Fixup{0}_{1}_{2}Keys", endMember.DeclaringType.NamespaceName.Replace(".", "_"), endMember.DeclaringType.Name, endMember.Name);
}

public static string CreateKeyNameVariable(string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}KeyName", keyName);
}

public static string CreateReferenceValueLookupKey(AssociationEndMember endMember, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", endMember.DeclaringType.FullName, endMember.Name, keyName);
}

public static string CreateReferenceValueLookupKey(NavigationProperty navProp, string keyName)
{
    return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navProp.Name, keyName);
}

public IEnumerable<string> GetTablesMappedTo(string inputFile, EntityType entityType)
{
    return GetTablesMappedTo(inputFile, entityType, HostResolvePath);
}
public static IEnumerable<string> GetTablesMappedTo(string inputFile, EntityType entityType, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityTypeLoop.NamespaceName, ".", entityTypeLoop.Name, @"(?:\))?$")));
        if (entityTypeMapping != null)
            foreach (var mappingFragment in entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)))
                yield return mappingFragment.Attribute("StoreEntitySet").Value;
    }	
}

public IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, string table)
{
    return GetDependentTablesAssociation(inputFile, table, HostResolvePath);
}
public static IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, string table, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    foreach (var association in runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)))
    {
        XElement end;
        if ((end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(r => r.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Principal", ssdl_ns)).Attribute("Role").Value)
            yield return association;
    }
}

public IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, List<string> tables, string table)
{
    return GetDependentTablesAssociation(inputFile, tables, table, HostResolvePath);
}
public static IEnumerable<XElement> GetDependentTablesAssociation(string inputFile, List<string> tables, string table, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    foreach (var association in runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)))
    {
        XElement end;
        if ((end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(e => e.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Principal", ssdl_ns)).Attribute("Role").Value && tables.Contains(Regex.Match(association.Elements(XName.Get("End", ssdl_ns)).First(e => e != end).Attribute("Type").Value, "[^.]+$").Value))
            yield return association;
    }
}

public IEnumerable<string> TableWithoutPrincipal(string inputFile, List<string> tables)
{
    return TableWithoutPrincipal(inputFile, tables, HostResolvePath);
}
public static IEnumerable<string> TableWithoutPrincipal(string inputFile, List<string> tables, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    return tables.Where(table => ! runtime.Element(XName.Get("StorageModels", edm_ns)).Element(XName.Get("Schema", ssdl_ns)).Elements(XName.Get("Association", ssdl_ns)).Any(association => 
    {
        XElement end;
        return (end = association.Elements(XName.Get("End", ssdl_ns)).FirstOrDefault(e => e.Attribute("Type").Value.EndsWith("." + table))) != null && end.Attribute("Role").Value == association.Element(XName.Get("ReferentialConstraint", ssdl_ns)).Element(XName.Get("Dependent", ssdl_ns)).Attribute("Role").Value && tables.Contains(Regex.Match(association.Elements(XName.Get("End", ssdl_ns)).First(e => e != end).Attribute("Type").Value, "[^.]+$").Value);
    }));
}

public string GetMappedColumn(string inputFile, EntityType entityType, string table, EdmMember prop)
{
    return GetMappedColumn(inputFile, entityType, table, prop, HostResolvePath);
}
public static string GetMappedColumn(string inputFile, EntityType entityType, string table, EdmMember prop, Func<string, string> hostResolvePath)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    var edm_ns = GetEDM_NS(root);
    string msl_ns = GetMSL_NS(root);
    string ssdl_ns = GetSSDL_NS(root);
    var runtime = root.Element(XName.Get("Runtime", edm_ns));
    if (entityType != null)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityType.NamespaceName, ".", entityType.Name, @"(?:\))?$")));
        if (entityTypeMapping == null)
            return null;
        var storeEntitySetMapping = entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)).FirstOrDefault(mf => mf.Attribute("StoreEntitySet").Value == table);
        if (storeEntitySetMapping == null)
        { 
            if (entityType.BaseType == null)
                return null;
            return GetMappedColumn(inputFile, (EntityType)entityType.BaseType, table, prop, hostResolvePath);
        }
        return storeEntitySetMapping.Elements(XName.Get("ScalarProperty", msl_ns)).First(sp => sp.Attribute("Name").Value == prop.Name).Attribute("ColumnName").Value;
    }
    return null;
}

public bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop)
{
    return IsHorizontalEntitySplittingCondition(inputFile, entityType, prop, HostResolvePath);
}
public void GetEdmxRuntimeAndEDMAndMSLNamespaces(string inputFile, out string edm_ns, out string msl_ns, out XElement runtime)
{
    GetEdmxRuntimeAndEDMAndMSLNamespaces(inputFile, HostResolvePath, out edm_ns, out msl_ns, out runtime);
}
public static void GetEdmxRuntimeAndEDMAndMSLNamespaces(string inputFile, Func<string, string> hostResolvePath, out string edm_ns, out string msl_ns, out XElement runtime)
{
    var root = XElement.Load(hostResolvePath(inputFile));
    edm_ns = GetEDM_NS(root);
    msl_ns = GetMSL_NS(root);
    runtime = root.Element(XName.Get("Runtime", edm_ns));
}
public static bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop, Func<string, string> hostResolvePath)
{
    string edm_ns, msl_ns;
    XElement runtime;
    GetEdmxRuntimeAndEDMAndMSLNamespaces(inputFile, hostResolvePath, out edm_ns, out msl_ns, out runtime);
    return IsHorizontalEntitySplittingCondition(inputFile, entityType, prop, edm_ns, msl_ns, runtime);
}
public static bool IsHorizontalEntitySplittingCondition(string inputFile, EntityType entityType, EdmMember prop, string edm_ns, string msl_ns, XElement runtime)
{
    for (var entityTypeLoop = entityType ; entityTypeLoop != null ; entityTypeLoop = (EntityType)entityTypeLoop.BaseType)
    {
        var entityTypeMapping = runtime.Element(XName.Get("Mappings", edm_ns)).Element(XName.Get("Mapping", msl_ns)).Descendants(XName.Get("EntityTypeMapping", msl_ns)).FirstOrDefault(etm => Regex.IsMatch(etm.Attribute("TypeName").Value, string.Concat(@"^(?:IsTypeOf\()?", entityType.NamespaceName, ".", entityType.Name, @"(?:\))?$")));
        if (entityTypeMapping == null)
            return false;
        if (entityTypeMapping.Elements(XName.Get("MappingFragment", msl_ns)).Any(mf => mf.Elements(XName.Get("Condition", msl_ns)).Any(c => 
            {
                var nameAttribute = c.Attribute("Name");
                if (nameAttribute == null)
                    return false;
                if (nameAttribute.Value == prop.Name)
                    return true;
                return false;
            })))
            return true;
    }
    return false;
}

public static void GetNavigationPropertyReferentialConstraintsEnumerables(NavigationProperty navigationProperty, out IEnumerable<EdmProperty> fromEnumerable, out IEnumerable<EdmProperty> toEnumerable)
{
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerables(navigationProperty, out referentialConstraint, out fromEnumerable, out toEnumerable);
}
public static void GetNavigationPropertyReferentialConstraintsEnumerables(NavigationProperty navigationProperty, out ReferentialConstraint referentialConstraint, out IEnumerable<EdmProperty> fromEnumerable, out IEnumerable<EdmProperty> toEnumerable)
{
    var association = (AssociationType)navigationProperty.RelationshipType;
    referentialConstraint = association.ReferentialConstraints.FirstOrDefault();
    if (referentialConstraint != null)
    {
        if (navigationProperty.FromEndMember == referentialConstraint.FromRole)
        {
            fromEnumerable = referentialConstraint.FromProperties;
            toEnumerable = referentialConstraint.ToProperties; 
        }
        else
        {
            fromEnumerable = referentialConstraint.ToProperties;
            toEnumerable = referentialConstraint.FromProperties; 
        }
        return;
    }
    fromEnumerable = new EdmProperty[0];
    toEnumerable = new EdmProperty[0];
}

public static void GetNavigationPropertyReferentialConstraintsEnumerators(NavigationProperty navigationProperty, out IEnumerator<EdmProperty> fromEnumerator, out IEnumerator<EdmProperty> toEnumerator)
{
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerators(navigationProperty, out referentialConstraint, out fromEnumerator, out toEnumerator);
}
public static void GetNavigationPropertyReferentialConstraintsEnumerators(NavigationProperty navigationProperty, out ReferentialConstraint referentialConstraint, out IEnumerator<EdmProperty> fromEnumerator, out IEnumerator<EdmProperty> toEnumerator)
{
    IEnumerable<EdmProperty> fromEnumerable, toEnumerable;
    GetNavigationPropertyReferentialConstraintsEnumerables(navigationProperty, out referentialConstraint, out fromEnumerable, out toEnumerable);
    fromEnumerator = fromEnumerable.GetEnumerator();
    toEnumerator = toEnumerable.GetEnumerator();
}

public static  bool IsStruct(EdmProperty property)
{
    return IsStruct(property.TypeUsage);
}
public static bool IsStruct(TypeUsage type)
{
    switch (type.ToString())
    {
        case "Edm.Byte":
        case "Edm.DateTime":
        case "Edm.DateTimeOffset":
        case "Edm.Time":
        case "Edm.Decimal":
        case "Edm.Double":
        case "Edm.Single":
        case "Edm.Int16":
        case "Edm.Int32":
        case "Edm.Int64":
        case "Edm.SByte":
            return true;
    }
    return false;
}

public static IEnumerable<Tuple<string, string>> GetKeysProperties(CodeGenerationTools code, EntityType entityType, int? index = null)
{
    foreach (var km in entityType.KeyMembers)
    {
        string typeName = code.Escape(km.TypeUsage);
        string key = string.Concat(code.Escape(entityType), index, code.Escape(km));
        yield return new Tuple<string, string>(typeName, key);
    }
} 

public bool HasPublicManyToManyRelationship(EdmxElements edmxElements)
{
    return edmxElements.EntityTypes.Any(e => IsPublic(e) && e.NavigationProperties.Any(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many));
}

public IEnumerable<string> WriteKeysTypes(EdmxElements edmxElements, EntityFrameworkTemplateFileManager fileManager, string entitiesNamespace, string edmxName, string relativePath)
{
    fileManager.StartNewFile("Includes.tt");
    string beginTag = "<" + "#";
    string endTag = "#" + ">";
    var edmxUtilityTTIncludeNameValue = edmxUtilityTTIncludeName;
    if (! string.IsNullOrEmpty(relativePath))
        edmxUtilityTTIncludeNameValue = Regex.Replace(edmxUtilityTTIncludeName, @"^((.?)*)\.ttinclude$", m => string.Concat(relativePath, m.Groups[1].Value, ".merge.ttinclude"));
#>
<#="<" + "#@"#> template language="C#" hostspecific="true"<#=endTag#>
<#="<" + "#@"#> include file="<#=edmxUtilityTTIncludeNameValue#>"<#=endTag#>
<#="<" + "#@"#> output extension=".txt"<#=endTag#>
<#=beginTag#>var fileManager = EntityFrameworkTemplateFileManager.Create(this);<#=endTag#>
<#+
    var code = edmxElements.Code;
    var typeNames = new List<string>();
    string @namespace = edmxElements.NamespaceName + ".Query.Include";
    foreach (EntityType entityType in edmxElements.EntityTypes.Where(e => IsPublic(e)))
    {
        string entityTypeName = code.Escape(entityType);
        foreach (var navigationProperty in entityType.NavigationProperties.Where(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many))
        {
            var typeNameSB = new StringBuilder();
            var properties = new List<Tuple<string, string>>();
            typeNameSB.Append("Include");
            foreach (var p in GetKeysProperties(code, entityType, 1).Union(GetKeysProperties(code, (EntityType)navigationProperty.ToEndMember.GetEntityType(), 2)))
            {
                typeNameSB.Append(p.Item2);
                properties.Add(p);
            }
            string typeName = typeNameSB.ToString();
            if (typeNames.Contains(typeName))
                continue;
            typeNames.Add(typeName);
#>
<#=beginTag#>fileManager.StartNewFile("<#=typeName#>.cs");<#=endTag#>
<#+
            WriteHeader(@namespace, code, "System", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://<#=edmxName#>/QueryInclude")]
public class <#=typeName#>
{
<#+
            foreach (var p in properties)
            {
#>
    [DataMember]
    public <#=p.Item1#> <#=p.Item2#> { get; set; }

<#+
            }
#>
}
<#+
            WriteFooter(@namespace);
            yield return typeName;

            var fromProperties = GetKeysProperties(code, entityType).ToList();
            typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in fromProperties)
                typeNameSB.Append(p.Item2);
            typeNameSB.Append("To");
            var toTypeName = code.Escape(navigationProperty.ToEndMember.GetEntityType());
            typeNameSB.Append(toTypeName);
            typeName = typeNameSB.ToString();

#>
<#=beginTag#>fileManager.StartNewFile("<#=typeName + ".cs"#>");<#=endTag#>
<#+
            WriteHeader(@namespace, code, "System", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://<#=edmxName#>/QueryInclude")]
public class <#=typeName#>
{
<#+
            foreach (var p in fromProperties)
            {
#>
    [DataMember]
    public <#=p.Item1#> <#=p.Item2#> { get; set; }

<#+
            }
#>
    [DataMember]
    public <#=entitiesNamespace#>.<#=toTypeName#> To { get; set; }
}
<#+
            WriteFooter(@namespace);
            yield return typeName;
        }
    }
#>
<#=beginTag#>fileManager.Process();<#=endTag#>
<#+
}

public static IEnumerable<string> GetKeysTypes(EdmxElements edmxElements)
{
    var code = edmxElements.Code;
    var typeNames = new List<string>();
    foreach (EntityType entityType in edmxElements.EntityTypes.Where(e => IsPublic(e)))
    {
        string entityTypeName = code.Escape(entityType);
        foreach (var navigationProperty in entityType.NavigationProperties.Where(np => IsPublic(np) && IsPublic(np) && np.FromEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many && np.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many))
        {
            var typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in GetKeysProperties(code, entityType, 1).Union(GetKeysProperties(code, (EntityType)navigationProperty.ToEndMember.GetEntityType(), 2)))
                typeNameSB.Append(p.Item2);
            string typeName = typeNameSB.ToString();
            if (typeNames.Contains(typeName))
                continue;
            typeNames.Add(typeName);
            yield return typeName;

            var fromProperties = GetKeysProperties(code, entityType).ToList();
            typeNameSB = new StringBuilder();
            typeNameSB.Append("Include");
            foreach (var p in fromProperties)
                typeNameSB.Append(p.Item2);
            typeNameSB.Append("To");
            var toTypeName = code.Escape(navigationProperty.ToEndMember.GetEntityType());
            typeNameSB.Append(toTypeName);
            yield return typeNameSB.ToString();
        }
    }
}

public static class EdmxChanges
{
    public static bool EdmxApplyChanges(string edmxPath, XElement edmx)
    {
        if (File.Exists(edmxPath + ".changes.xml"))
        {
            var changes = XElement.Load(edmxPath + ".changes.xml");
            ApplyChanges(edmx, changes);
            return true;
        }
        return false;
    }

    private static void ApplyChanges(XElement original, XElement change)
    {
        if (original.Name != change.Name || original.Attribute("Name") != null && original.Attribute("Name").Value != change.Attribute("Name").Value)
            throw new NotImplementedException();
        foreach (var addedAttribute in change.Attributes())
        {
            XAttribute originalAttribute = original.Attribute(addedAttribute.Name);
            if (originalAttribute == null)
                original.Add(addedAttribute);
            else
                originalAttribute.Value = addedAttribute.Value;
        }
        foreach (var changesChild in change.Elements())
        {
            var originalChild = original.Elements().FirstOrDefault(o => o.Name == changesChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesChild.Attribute("Name").Value));
            if (originalChild == null)
            {
                switch (changesChild.Name.LocalName)
                {
                    case "add":
                        foreach (var changesSubChild in changesChild.Elements())
                            original.Add(changesSubChild);
                        break;
                    case "remove":
                        foreach (var changesSubChild in changesChild.Elements())
                        {
                            originalChild = original.Elements().First(o => o.Name == changesSubChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesSubChild.Attribute("Name").Value));
                            originalChild.Remove();
                        }
                        break;
                    case "replace":
                        foreach (var changesSubChild in changesChild.Elements())
                        {
                            originalChild = original.Elements().First(o => o.Name == changesSubChild.Name && (o.Attribute("Name") == null || o.Attribute("Name").Value == changesSubChild.Attribute("Name").Value));
                            originalChild.Remove();
                            original.Add(changesSubChild);
                        }
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            else
            {
                ApplyChanges(originalChild, changesChild);
            }
        }
    }
}

void TestKeys(CodeGenerationTools code, EntityType entityType, string e1, string e2, string prefix1 = null, string prefix2 = null)
{
    var keysEnumerator = entityType.KeyMembers.GetEnumerator();
    keysEnumerator.MoveNext();
    for(;;)
    {
        string key = code.Escape(keysEnumerator.Current);
#><#=e1#>.<#=prefix1 ?? ""#><#=key#> == <#=e2#>.<#=prefix2 ?? ""#><#=key#><#+
        if (keysEnumerator.MoveNext())
        {
#> && <#+
        }
        else
            break;		
    }
}


void WriteIncludeTypeKeys(CodeGenerationTools code, EntityType entityType, NavigationProperty navigationProperty)
{
    var entityTypeName = code.Escape(entityType);
    foreach (var km in entityType.KeyMembers)
    {
#><#=entityTypeName#>1<#=code.Escape(km)#><#+
    }
    var toEntityType = navigationProperty.ToEndMember.GetEntityType();
    var toEntityTypeName = code.Escape(toEntityType);
    foreach (var km in toEntityType.KeyMembers)
    {
#><#=toEntityTypeName#>2<#=code.Escape(km)#><#+
    }
}

void WriteIncludeTo(CodeGenerationTools code, EntityType entityType, NavigationProperty navigationProperty)
{
    var entityTypeName = code.Escape(entityType);
    foreach (var km in entityType.KeyMembers)
    {
#><#=entityTypeName#><#=code.Escape(km)#><#+
    }
#>To<#=code.Escape(navigationProperty.ToEndMember.GetEntityType())#><#+
}

void InitKeys(CodeGenerationTools code, EntityType entityType, string e, int? index = null, string prefixName = null)
{
    var keysEnumerator = entityType.KeyMembers.GetEnumerator();
    keysEnumerator.MoveNext();
    for(;;)
    {
        string key = code.Escape(keysEnumerator.Current);
#><#=prefixName ?? ""#><#=index == null ? "" : index.Value.ToString()#><#=key#> = <#=e#>.<#=key#><#+
        if (keysEnumerator.MoveNext())
        {
#>, <#+
        }
        else
            break;		
    }
}

void TestNavigationKeys(CodeGenerationTools code, NavigationProperty navigationProperty, string e1 = "e1", string e2 = "e2")
{
    IEnumerator<EdmProperty> fromEnumerator, toEnumerator;
    ReferentialConstraint referentialConstraint;
    GetNavigationPropertyReferentialConstraintsEnumerators(navigationProperty, out referentialConstraint, out fromEnumerator, out toEnumerator);
    if (referentialConstraint != null)
    {
        bool hasNext = fromEnumerator.MoveNext() & toEnumerator.MoveNext(); 
        while (hasNext)
        {
#><#=e1#>.<#=fromEnumerator.Current#> == <#=e2#>.<#=toEnumerator.Current#><#+
            hasNext = fromEnumerator.MoveNext() & toEnumerator.MoveNext(); 
            if (! hasNext)
                break;
#> && <#+
        }
    }
}
#>
<#+// Copyright (c) Microsoft Corporation.  All rights reserved.

public static Dictionary<string, string> TemplateMetadata = new Dictionary<string, string>();

/// <summary>
/// Responsible for helping to create source code that is
/// correctly formated and functional
/// </summary>
public class CodeGenerationTools
{
	private readonly DynamicTextTransformation _textTransformation;
	private readonly CSharpCodeProvider _code;
	private readonly MetadataTools _ef;

	private CodeGenerationTools()
	{
	}

	/// <summary>
	/// Initializes a new CodeGenerationTools object with the TextTransformation (T4 generated class)
	/// that is currently running
	/// </summary>
	public CodeGenerationTools(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
		_code = new CSharpCodeProvider();
		_ef = new MetadataTools(_textTransformation);
		FullyQualifySystemTypes = false;
		CamelCaseFields = true;
	}

	/// <summary>
	/// When true, all types that are not being generated
	/// are fully qualified to keep them from conflicting with
	/// types that are being generated. Useful when you have
	/// something like a type being generated named System.
	///
	/// Default is false.
	/// </summary>
	public bool FullyQualifySystemTypes { get; set; }

	/// <summary>
	/// When true, the field names are Camel Cased,
	/// otherwise they will preserve the case they
	/// start with.
	///
	/// Default is true.
	/// </summary>
	public bool CamelCaseFields { get; set; }

	/// <summary>
	/// Returns the NamespaceName suggested by VS if running inside VS.  Otherwise, returns
	/// null.
	/// </summary>
	public string VsNamespaceSuggestion()
	{
		string suggestion = _textTransformation.Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint");
		if (String.IsNullOrEmpty(suggestion))
		{
			return null;
		}

		return suggestion;
	}

	/// <summary>
	/// Returns a string that is safe for use as an identifier in C#.
	/// Keywords are escaped.
	/// </summary>
	public string Escape(string name)
	{
		if (name == null)
		{
			return null;
		}

		return _code.CreateEscapedIdentifier(name);
	}

	/// <summary>
	/// Returns the name of the TypeUsage's EdmType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(TypeUsage typeUsage)
	{
		if (typeUsage == null)
		{
			return null;
		}

		if (typeUsage.EdmType is ComplexType ||
			typeUsage.EdmType is EntityType)
		{
			return Escape(typeUsage.EdmType.Name);
		}
		else if (typeUsage.EdmType is SimpleType)
		{
			Type clrType = _ef.UnderlyingClrType(typeUsage.EdmType);
			string typeName = typeUsage.EdmType is EnumType ? Escape(typeUsage.EdmType.Name) : Escape(clrType);
			if (clrType.IsValueType && _ef.IsNullable(typeUsage))
			{
				return String.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName);
			}

			return typeName;
		}
		else if (typeUsage.EdmType is CollectionType)
		{
			return String.Format(CultureInfo.InvariantCulture, "ICollection<{0}>", Escape(((CollectionType)typeUsage.EdmType).TypeUsage));
		}

		throw new ArgumentException("typeUsage");
	}

	/// <summary>
	/// Returns the name of the EdmMember that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return Escape(member.Name);
	}

	/// <summary>
	/// Returns the name of the EdmType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmType type)
	{
		if (type == null)
		{
			return null;
		}

		return Escape(type.Name);
	}

	/// <summary>
	/// Returns the name of the EdmFunction that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EdmFunction function)
	{
		if (function == null)
		{
			return null;
		}

		return Escape(function.Name);
	}

	/// <summary>
	/// Returns the name of the EnumMember that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EnumMember member)
	{
		if (member == null)
		{
			return null;
		}

		return Escape(member.Name);
	}

	/// <summary>
	/// Returns the name of the EntityContainer that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EntityContainer container)
	{
		if (container == null)
		{
			return null;
		}

		return Escape(container.Name);
	}

	/// <summary>
	/// Returns the name of the EntitySet that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return Escape(set.Name);
	}

	/// <summary>
	/// Returns the name of the StructuralType that is safe for
	/// use as an identifier.
	/// </summary>
	public string Escape(StructuralType type)
	{
		if (type == null)
		{
			return null;
		}

		return Escape(type.Name);
	}

	/// <summary>
	/// Returns the NamespaceName with each segment safe to
	/// use as an identifier.
	/// </summary>
	public string EscapeNamespace(string namespaceName)
	{
		if (String.IsNullOrEmpty(namespaceName))
		{
			return namespaceName;
		}

		string[] parts = namespaceName.Split('.');
		namespaceName = String.Empty;
		foreach (string part in parts)
		{
			if (namespaceName != String.Empty)
			{
				namespaceName += ".";
			}

			namespaceName += Escape(part);
		}

		return namespaceName;
	}

	/// <summary>
	/// Returns the name of the EdmMember formatted for
	/// use as a field identifier.
	///
	/// This method changes behavior based on the CamelCaseFields
	/// setting.
	/// </summary>
	public string FieldName(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return FieldName(member.Name);
	}

	/// <summary>
	/// Returns the name of the EntitySet formatted for
	/// use as a field identifier.
	///
	/// This method changes behavior based on the CamelCaseFields
	/// setting.
	/// </summary>
	public string FieldName(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return FieldName(set.Name);

	}

	private string FieldName(string name)
	{
		if (CamelCaseFields)
		{
			return "_" + CamelCase(name);
		}
		else
		{
			return "_" + name;
		}
	}

	/// <summary>
	/// Returns the name of the Type object formatted for
	/// use in source code.
	///
	/// This method changes behavior based on the FullyQualifySystemTypes
	/// setting.
	/// </summary>
	public string Escape(Type clrType)
	{
		return Escape(clrType, FullyQualifySystemTypes);
	}

	/// <summary>
	/// Returns the name of the Type object formatted for
	/// use in source code.
	/// </summary>
	public string Escape(Type clrType, bool fullyQualifySystemTypes)
	{
		if(clrType == null)
		{
			return null;
		}

		string typeName;
		if (fullyQualifySystemTypes)
		{
			typeName = "global::" + clrType.FullName;
		}
		else
		{
			typeName = _code.GetTypeOutput(new CodeTypeReference(clrType));
		}
		return typeName;
	}

	/// <summary>
	/// Returns the abstract option if the entity is Abstract, otherwise returns String.Empty
	/// </summary>
	public string AbstractOption(EntityType entity)
	{
		if (entity.Abstract)
		{
			return "abstract";
		}
		return String.Empty;
	}

	/// <summary>
	/// Returns the passed in identifier with the first letter changed to lowercase
	/// </summary>
	public string CamelCase(string identifier)
	{
		if (String.IsNullOrEmpty(identifier))
		{
			return identifier;
		}

		if (identifier.Length == 1)
		{
			return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
		}

		return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + identifier.Substring(1);
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with a single space concatenated on the end.
	/// </summary>
	public string SpaceAfter(string value)
	{
		return StringAfter(value, " ");
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with a single space concatenated on the end.
	/// </summary>
	public string SpaceBefore(string value)
	{
		return StringBefore(" ", value);
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with append concatenated on the end.
	/// </summary>
	public string StringAfter(string value, string append)
	{
		if (String.IsNullOrEmpty(value))
		{
			return String.Empty;
		}

			return value + append;
	}

	/// <summary>
	/// If the value parameter is null or empty an empty string is returned,
	/// otherwise it retuns value with prepend concatenated on the front.
	/// </summary>
	public string StringBefore(string prepend, string value)
	{
		if (String.IsNullOrEmpty(value))
		{
			return String.Empty;
		}

		return prepend + value;
	}

	/// <summary>
	/// Returns false and shows an error if the supplied type names aren't case-insensitively unique,
	/// otherwise returns true.
	/// </summary>
	public bool VerifyCaseInsensitiveTypeUniqueness(IEnumerable<string> types, string sourceFile)
	{
		return VerifyCaseInsensitiveUniqueness(types, t => string.Format(CultureInfo.CurrentCulture, GetResourceString("Template_CaseInsensitiveTypeConflict"), t), sourceFile);
	}

	/// <summary>
	/// Returns false and shows an error if the supplied strings aren't case-insensitively unique,
	/// otherwise returns true.
	/// </summary>
	private bool VerifyCaseInsensitiveUniqueness(IEnumerable<string> items, Func<string, string> formatMessage, string sourceFile)
	{
		HashSet<string> hash = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
		foreach (string item in items)
		{
			if (!hash.Add(item))
			{
				_textTransformation.Errors.Add(new System.CodeDom.Compiler.CompilerError(sourceFile, -1, -1, "6023", formatMessage(item)));
				return false;
			}
		}
		return true;
	}

	/// <summary>
	/// Returns the names of the items in the supplied collection that correspond to O-Space types.
	/// </summary>
	public IEnumerable<string> GetAllGlobalItems(EdmItemCollection itemCollection)
	{
		return itemCollection.GetItems<GlobalItem>().Where(i => i is EntityType || i is ComplexType || i is EnumType || i is EntityContainer).Select(g => GetGlobalItemName(g));
	}

	/// <summary>
	/// Returns the name of the supplied GlobalItem.
	/// </summary>
	public string GetGlobalItemName(GlobalItem item)
	{
		if (item is EdmType)
		{
			return ((EdmType)item).Name;
		}
		else
		{
			return ((EntityContainer)item).Name;
		}
	}

	/// <summary>
	/// Retuns as full of a name as possible, if a namespace is provided
	/// the namespace and name are combined with a period, otherwise just
	/// the name is returned.
	/// </summary>
	public string CreateFullName(string namespaceName, string name)
	{
		if (String.IsNullOrEmpty(namespaceName))
		{
			return name;
		}

		return namespaceName + "." + name;
	}

	/// <summary>
	/// Retuns a literal representing the supplied value.
	/// </summary>
	public string CreateLiteral(object value)
	{
		if (value == null)
		{
			return string.Empty;
		}

		Type type = value.GetType();
		if (type.IsEnum)
		{
			return type.FullName + "." + value.ToString();
		}
		if (type == typeof(Guid))
		{
			return string.Format(CultureInfo.InvariantCulture, "new Guid(\"{0}\")",
								 ((Guid)value).ToString("D", CultureInfo.InvariantCulture));
		}
		else if (type == typeof(DateTime))
		{
			return string.Format(CultureInfo.InvariantCulture, "new DateTime({0}, DateTimeKind.Unspecified)",
								 ((DateTime)value).Ticks);
		}
		else if (type == typeof(byte[]))
		{
			var arrayInit = string.Join(", ", ((byte[])value).Select(b => b.ToString(CultureInfo.InvariantCulture)).ToArray());
			return string.Format(CultureInfo.InvariantCulture, "new Byte[] {{{0}}}", arrayInit);
		}
		else if (type == typeof(DateTimeOffset))
		{
			var dto = (DateTimeOffset)value;
			return string.Format(CultureInfo.InvariantCulture, "new DateTimeOffset({0}, new TimeSpan({1}))",
								 dto.Ticks, dto.Offset.Ticks);
		}
		else if (type == typeof(TimeSpan))
		{
			return string.Format(CultureInfo.InvariantCulture, "new TimeSpan({0})",
								 ((TimeSpan)value).Ticks);
		}

		var expression = new CodePrimitiveExpression(value);
		var writer = new StringWriter();
		CSharpCodeProvider code = new CSharpCodeProvider();
		code.GenerateCodeFromExpression(expression, writer, new CodeGeneratorOptions());
		return writer.ToString();
	}

	/// <summary>
	/// Returns a resource string from the System.Data.Entity.Design assembly.
	/// </summary>
	public static string GetResourceString(string resourceName, CultureInfo culture = null)
	{
		if(_resourceManager == null)
		{
			_resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design",
				typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
		}

		return _resourceManager.GetString(resourceName, culture);
	}
	static System.Resources.ResourceManager _resourceManager;

	private const string ExternalTypeNameAttributeName = @"http://schemas.microsoft.com/ado/2006/04/codegeneration:ExternalTypeName";

	/// <summary>
	/// Gets the entity, complex, or enum types for which code should be generated from the given item collection.
	/// Any types for which an ExternalTypeName annotation has been applied in the conceptual model
	/// metadata (CSDL) are filtered out of the returned list.
	/// </summary>
	/// <typeparam name="T">The type of item to return.</typeparam>
	/// <param name="itemCollection">The item collection to look in.</param>
	/// <returns>The items to generate.</returns>
	public IEnumerable<T> GetItemsToGenerate<T>(ItemCollection itemCollection) where T: GlobalItem
	{
		return itemCollection.GetItems<T>().Where(i => !i.MetadataProperties.Any(p => p.Name == ExternalTypeNameAttributeName));
	}

	/// <summary>
	/// Returns the escaped type name to use for the given usage of a c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="typeUsage">The c-space type usage to get a name for.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(TypeUsage typeUsage)
	{
		return typeUsage == null ? null : GetTypeName(typeUsage.EdmType, _ef.IsNullable(typeUsage), modelNamespace: null);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(EdmType edmType)
	{
		return GetTypeName(edmType, isNullable: null, modelNamespace: null);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given usage of an c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="typeUsage">The c-space type usage to get a name for.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(TypeUsage typeUsage, string modelNamespace)
	{
		return typeUsage == null ? null : GetTypeName(typeUsage.EdmType, _ef.IsNullable(typeUsage), modelNamespace);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	public string GetTypeName(EdmType edmType, string modelNamespace)
	{
		return GetTypeName(edmType, isNullable: null, modelNamespace: modelNamespace);
	}

	/// <summary>
	/// Returns the escaped type name to use for the given c-space type in o-space. This might be
	/// an external type name if the ExternalTypeName annotation has been specified in the
	/// conceptual model metadata (CSDL).
	/// </summary>
	/// <param name="edmType">The c-space type to get a name for.</param>
	/// <param name="isNullable">Set this to true for nullable usage of this type.</param>
	/// <param name="modelNamespace">If not null and the type's namespace does not match this namespace, then a
	/// fully qualified name will be returned.</param>
	/// <returns>The type name to use.</returns>
	private string GetTypeName(EdmType edmType, bool? isNullable, string modelNamespace)
	{
		if (edmType == null)
		{
			return null;
		}

		var collectionType = edmType as CollectionType;
		if (collectionType != null)
		{
			return String.Format(CultureInfo.InvariantCulture, "ICollection<{0}>", GetTypeName(collectionType.TypeUsage, modelNamespace));
		}

		// Try to get an external type name, and if that is null, then try to get escape the name from metadata,
		// possibly namespace-qualifying it.
		var typeName = Escape(edmType.MetadataProperties
							  .Where(p => p.Name == ExternalTypeNameAttributeName)
							  .Select(p => (string)p.Value)
							  .FirstOrDefault())
			??
			(modelNamespace != null && edmType.NamespaceName != modelNamespace ?
			 CreateFullName(EscapeNamespace(edmType.NamespaceName), Escape(edmType)) :
			 Escape(edmType));

		if (edmType is StructuralType)
		{
			return typeName;
		}

		if (edmType is SimpleType)
		{
			var clrType = _ef.UnderlyingClrType(edmType);
			if (!(edmType is EnumType))
			{
				typeName = Escape(clrType);
			}

			return clrType.IsValueType && isNullable == true ?
				String.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName) :
				typeName;
		}

		throw new ArgumentException("typeUsage");
	}
}

/// <summary>
/// Responsible for making the Entity Framework Metadata more
/// accessible for code generation.
/// </summary>
public class MetadataTools
{
	private readonly DynamicTextTransformation _textTransformation;

	private MetadataTools()
	{
	}

	/// <summary>
	/// Initializes an MetadataTools Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public MetadataTools(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// This method returns the underlying CLR type of the o-space type corresponding to the supplied <paramref name="typeUsage"/>
	/// Note that for an enum type this means that the type backing the enum will be returned, not the enum type itself.
	/// </summary>
	public Type ClrType(TypeUsage typeUsage)
	{
		return UnderlyingClrType(typeUsage.EdmType);
	}

	/// <summary>
	/// This method returns the underlying CLR type given the c-space type.
	/// Note that for an enum type this means that the type backing the enum will be returned, not the enum type itself.
	/// </summary>
	public Type UnderlyingClrType(EdmType edmType)
	{
		var primitiveType = edmType as PrimitiveType;
		if (primitiveType != null)
		{
			return primitiveType.ClrEquivalentType;
		}

		var enumType = edmType as EnumType;
		if (enumType != null)
		{
			return enumType.UnderlyingType.ClrEquivalentType;
		}

		return typeof(object);
	}

	/// <summary>
	/// True if the EdmProperty is a key of its DeclaringType, False otherwise.
	/// </summary>
	public bool IsKey(EdmProperty property)
	{
		if (property != null && property.DeclaringType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
		{
			return ((EntityType)property.DeclaringType).KeyMembers.Contains(property);
		}

		return false;
	}

	/// <summary>
	/// True if the EdmProperty TypeUsage is Nullable, False otherwise.
	/// </summary>
	public bool IsNullable(EdmProperty property)
	{
		return property != null && IsNullable(property.TypeUsage);
	}

	/// <summary>
	/// True if the TypeUsage is Nullable, False otherwise.
	/// </summary>
	public bool IsNullable(TypeUsage typeUsage)
	{
		Facet nullableFacet = null;
		if (typeUsage != null &&
			typeUsage.Facets.TryGetValue("Nullable", true, out nullableFacet))
		{
			return (bool)nullableFacet.Value;
		}

		return false;
	}

	/// <summary>
	/// If the passed in TypeUsage represents a collection this method returns final element
	/// type of the collection, otherwise it returns the value passed in.
	/// </summary>
	public TypeUsage GetElementType(TypeUsage typeUsage)
	{
		if (typeUsage == null)
		{
			return null;
		}

		if (typeUsage.EdmType is CollectionType)
		{
			return GetElementType(((CollectionType)typeUsage.EdmType).TypeUsage);
		}
		else
		{
			return typeUsage;
		}
	}

	/// <summary>
	/// Returns the NavigationProperty that is the other end of the same association set if it is
	/// available, otherwise it returns null.
	/// </summary>
	public NavigationProperty Inverse(NavigationProperty navProperty)
	{
		if(navProperty == null)
		{
			return null;
		}

		EntityType toEntity = navProperty.ToEndMember.GetEntityType();
		return toEntity.NavigationProperties
			.SingleOrDefault(n => Object.ReferenceEquals(n.RelationshipType, navProperty.RelationshipType) && !Object.ReferenceEquals(n, navProperty));
	}

	/// <summary>
	/// Given a property on the dependent end of a referential constraint, returns the corresponding property on the principal end.
	/// Requires: The association has a referential constraint, and the specified dependentProperty is one of the properties on the dependent end.
	/// </summary>
	public EdmProperty GetCorrespondingPrincipalProperty(NavigationProperty navProperty, EdmProperty dependentProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		if (dependentProperty == null)
		{
			throw new ArgumentNullException("dependentProperty");
		}

		ReadOnlyMetadataCollection<EdmProperty> fromProperties = GetPrincipalProperties(navProperty);
		ReadOnlyMetadataCollection<EdmProperty> toProperties = GetDependentProperties(navProperty);
		return fromProperties[toProperties.IndexOf(dependentProperty)];
	}

	/// <summary>
	/// Given a property on the principal end of a referential constraint, returns the corresponding property on the dependent end.
	/// Requires: The association has a referential constraint, and the specified principalProperty is one of the properties on the principal end.
	/// </summary>
	public EdmProperty GetCorrespondingDependentProperty(NavigationProperty navProperty, EdmProperty principalProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		if (principalProperty == null)
		{
			throw new ArgumentNullException("principalProperty");
		}

		ReadOnlyMetadataCollection<EdmProperty> fromProperties = GetPrincipalProperties(navProperty);
		ReadOnlyMetadataCollection<EdmProperty> toProperties = GetDependentProperties(navProperty);
		return toProperties[fromProperties.IndexOf(principalProperty)];
	}

	/// <summary>
	/// Gets the collection of properties that are on the principal end of a referential constraint for the specified navigation property.
	/// Requires: The association has a referential constraint.
	/// </summary>
	public ReadOnlyMetadataCollection<EdmProperty> GetPrincipalProperties(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return ((AssociationType)navProperty.RelationshipType).ReferentialConstraints[0].FromProperties;
	}

	/// <summary>
	/// Gets the collection of properties that are on the dependent end of a referential constraint for the specified navigation property.
	/// Requires: The association has a referential constraint.
	/// </summary>
	public ReadOnlyMetadataCollection<EdmProperty> GetDependentProperties(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return ((AssociationType)navProperty.RelationshipType).ReferentialConstraints[0].ToProperties;
	}

	/// <summary>
	/// True if this entity type requires the HandleCascadeDelete method defined and the method has
	/// not been defined on any base type
	/// </summary>
	public bool NeedsHandleCascadeDeleteMethod(ItemCollection itemCollection, EntityType entity)
	{
		bool needsMethod = ContainsCascadeDeleteAssociation(itemCollection, entity);
		// Check to make sure no base types have already declared this method
		EntityType baseType = entity.BaseType as EntityType;
		while(needsMethod && baseType != null)
		{
			needsMethod = !ContainsCascadeDeleteAssociation(itemCollection, baseType);
			baseType = baseType.BaseType as EntityType;
		}
		return needsMethod;
	}

	/// <summary>
	/// True if this entity type participates in any relationships where the other end has an OnDelete
	/// cascade delete defined, or if it is the dependent in any identifying relationships
	/// </summary>
	private bool ContainsCascadeDeleteAssociation(ItemCollection itemCollection, EntityType entity)
	{
		return itemCollection.GetItems<AssociationType>().Where(a =>
				((RefType)a.AssociationEndMembers[0].TypeUsage.EdmType).ElementType.Name == entity.Name && IsCascadeDeletePrincipal(a.AssociationEndMembers[1]) ||
				((RefType)a.AssociationEndMembers[1].TypeUsage.EdmType).ElementType.Name == entity.Name && IsCascadeDeletePrincipal(a.AssociationEndMembers[0])).Any();
	}

	/// <summary>
	/// True if the source end of the specified navigation property is the principal in an identifying relationship.
	/// or if the source end has cascade delete defined.
	/// </summary>
	public bool IsCascadeDeletePrincipal(NavigationProperty navProperty)
	{
		if (navProperty == null)
		{
			throw new ArgumentNullException("navProperty");
		}

		return IsCascadeDeletePrincipal((AssociationEndMember)navProperty.FromEndMember);
	}

	/// <summary>
	/// True if the specified association end is the principal in an identifying relationship.
	/// or if the association end has cascade delete defined.
	/// </summary>
	public bool IsCascadeDeletePrincipal(AssociationEndMember associationEnd)
	{
		if (associationEnd == null)
		{
			throw new ArgumentNullException("associationEnd");
		}

		return associationEnd.DeleteBehavior == OperationAction.Cascade || IsPrincipalEndOfIdentifyingRelationship(associationEnd);
	}

	/// <summary>
	/// True if the specified association end is the principal end in an identifying relationship.
	/// In order to be an identifying relationship, the association must have a referential constraint where all of the dependent properties are part of the dependent type's primary key.
	/// </summary>
	public bool IsPrincipalEndOfIdentifyingRelationship(AssociationEndMember associationEnd)
	{
		if (associationEnd == null)
		{
			throw new ArgumentNullException("associationEnd");
		}

		ReferentialConstraint refConstraint = ((AssociationType)associationEnd.DeclaringType).ReferentialConstraints.Where(rc => rc.FromRole == associationEnd).SingleOrDefault();
		if (refConstraint != null)
		{
			EntityType entity = refConstraint.ToRole.GetEntityType();
			return !refConstraint.ToProperties.Where(tp => !entity.KeyMembers.Contains(tp)).Any();
		}
		return false;
	}

	/// <summary>
	/// True if the specified association type is an identifying relationship.
	/// In order to be an identifying relationship, the association must have a referential constraint where all of the dependent properties are part of the dependent type's primary key.
	/// </summary>
	public bool IsIdentifyingRelationship(AssociationType association)
	{
		if (association == null)
		{
			throw new ArgumentNullException("association");
		}

		return IsPrincipalEndOfIdentifyingRelationship(association.AssociationEndMembers[0]) || IsPrincipalEndOfIdentifyingRelationship(association.AssociationEndMembers[1]);
	}

	/// <summary>
	/// requires: firstType is not null
	/// effects: if secondType is among the base types of the firstType, return true,
	/// otherwise returns false.
	/// when firstType is same as the secondType, return false.
	/// </summary>
	public bool IsSubtypeOf(EdmType firstType, EdmType secondType)
	{
		if (secondType == null)
		{
			return false;
		}

		// walk up firstType hierarchy list
		for (EdmType t = firstType.BaseType; t != null; t = t.BaseType)
		{
			if (t == secondType)
				return true;
		}
		return false;
	}

	/// <summary>
	/// Returns the subtype of the EntityType in the current itemCollection
	/// </summary>
	public IEnumerable<EntityType> GetSubtypesOf(EntityType type, ItemCollection itemCollection, bool includeAbstractTypes)
	{
		if (type != null)
		{
			IEnumerable<EntityType> typesInCollection = itemCollection.GetItems<EntityType>();
			foreach (EntityType typeInCollection in typesInCollection)
			{
				if (type.Equals(typeInCollection) == false && this.IsSubtypeOf(typeInCollection, type))
				{
					if ( includeAbstractTypes || !typeInCollection.Abstract)
					{
						yield return typeInCollection;
					}
			   }
			}
		}
	}

	public static bool TryGetStringMetadataPropertySetting(MetadataItem item, string propertyName, out string value)
	{
		value = null;
		MetadataProperty property = item.MetadataProperties.FirstOrDefault(p => p.Name == propertyName);
		if (property != null)
		{
			value = (string)property.Value;
		}
		return value != null;
	}
}

/// <summary>
/// Responsible for loading an EdmItemCollection from a .edmx file or .csdl files
/// </summary>
public class MetadataLoader
{
	private readonly DynamicTextTransformation _textTransformation;

	private MetadataLoader()
	{
	}

	/// <summary>
	/// Initializes an MetadataLoader Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public MetadataLoader(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// Load the metadata for Edm, Store, and Mapping collections and register them
	/// with a new MetadataWorkspace, returns false if any of the parts can't be
	/// created, some of the ItemCollections may be registered and usable even if false is
	/// returned
	/// </summary>
	public bool TryLoadAllMetadata(string inputFile, out MetadataWorkspace metadataWorkspace)
	{
		metadataWorkspace = new MetadataWorkspace();

		EdmItemCollection edmItemCollection = CreateEdmItemCollection(inputFile);
		metadataWorkspace.RegisterItemCollection(edmItemCollection);

		StoreItemCollection storeItemCollection = null;
		if (TryCreateStoreItemCollection(inputFile, out storeItemCollection))
		{
			StorageMappingItemCollection storageMappingItemCollection = null;
			if (TryCreateStorageMappingItemCollection(inputFile, edmItemCollection, storeItemCollection, out storageMappingItemCollection))
			{
				metadataWorkspace.RegisterItemCollection(storeItemCollection);
				metadataWorkspace.RegisterItemCollection(storageMappingItemCollection);
				return true;
			}
		}

		return false;
	}

	/// <summary>
	/// Create an EdmItemCollection loaded with the metadata provided
	/// </summary>
	public EdmItemCollection CreateEdmItemCollection(string sourcePath, params string[] referenceSchemas)
	{
		EdmItemCollection edmItemCollection;
		if(TryCreateEdmItemCollection(sourcePath, referenceSchemas, out edmItemCollection))
		{
			return edmItemCollection;
		}

		return new EdmItemCollection();
	}

	/// <summary>
	/// Attempts to create a EdmItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateEdmItemCollection(string sourcePath, out EdmItemCollection edmItemCollection)
	{
		return TryCreateEdmItemCollection(sourcePath, null, out edmItemCollection);
	}

	/// <summary>
	/// Attempts to create a EdmItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateEdmItemCollection(string sourcePath, string[] referenceSchemas, out EdmItemCollection edmItemCollection)
	{
		edmItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		if (referenceSchemas == null)
		{
			referenceSchemas = new string[0];
		}

		ItemCollection itemCollection = null;
		sourcePath = _textTransformation.Host.ResolvePath(sourcePath);
		EdmItemCollectionBuilder collectionBuilder = new EdmItemCollectionBuilder(_textTransformation, referenceSchemas.Select(s => _textTransformation.Host.ResolvePath(s)).Where(s => s != sourcePath));
		if (collectionBuilder.TryCreateItemCollection(sourcePath, out itemCollection))
		{
			edmItemCollection = (EdmItemCollection)itemCollection;
		}

		return edmItemCollection != null;
	}

	/// <summary>
	/// Attempts to create a StoreItemCollection from the specified metadata file
	/// </summary>
	public bool TryCreateStoreItemCollection(string sourcePath, out StoreItemCollection storeItemCollection)
	{
		storeItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		ItemCollection itemCollection = null;
		StoreItemCollectionBuilder collectionBuilder = new StoreItemCollectionBuilder(_textTransformation);
		if (collectionBuilder.TryCreateItemCollection(_textTransformation.Host.ResolvePath(sourcePath), out itemCollection))
		{
			storeItemCollection = (StoreItemCollection)itemCollection;
		}
		return storeItemCollection != null;
	}

	/// <summary>
	/// Attempts to create a StorageMappingItemCollection from the specified metadata file, EdmItemCollection, and StoreItemCollection
	/// </summary>
	public bool TryCreateStorageMappingItemCollection(string sourcePath, EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection, out StorageMappingItemCollection storageMappingItemCollection)
	{
		storageMappingItemCollection = null;

		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return false;
		}

		if (edmItemCollection == null)
		{
			throw new ArgumentNullException("edmItemCollection");
		}

		if (storeItemCollection == null)
		{
			throw new ArgumentNullException("storeItemCollection");
		}

		ItemCollection itemCollection = null;
		StorageMappingItemCollectionBuilder collectionBuilder = new StorageMappingItemCollectionBuilder(_textTransformation, edmItemCollection, storeItemCollection);
		if (collectionBuilder.TryCreateItemCollection(_textTransformation.Host.ResolvePath(sourcePath), out itemCollection))
		{
			storageMappingItemCollection = (StorageMappingItemCollection)itemCollection;
		}
		return storageMappingItemCollection != null;
	}

	/// <summary>
	/// Gets the Model Namespace from the provided schema file.
	/// </summary>
	public string GetModelNamespace(string sourcePath)
	{
		if (!ValidateInputPath(sourcePath, _textTransformation))
		{
			return String.Empty;
		}

		EdmItemCollectionBuilder builder = new EdmItemCollectionBuilder(_textTransformation);
		XElement model;
		if(builder.TryLoadRootElement(_textTransformation.Host.ResolvePath(sourcePath), out model))
		{
			XAttribute attribute = model.Attribute("Namespace");
			if (attribute != null)
			{
				return attribute.Value;
			}
		}

		return String.Empty;
	}

	/// <summary>
	/// Returns true if the specified file path is valid
	/// </summary>
	private static bool ValidateInputPath(string sourcePath, DynamicTextTransformation textTransformation)
	{
		if (String.IsNullOrEmpty(sourcePath))
		{
			throw new ArgumentException("sourcePath");
		}

		if(sourcePath == "$edmxInputFile$")
		{
			textTransformation.Errors.Add(new CompilerError(textTransformation.Host.TemplateFile ?? CodeGenerationTools.GetResourceString("Template_CurrentlyRunningTemplate"), 0, 0, string.Empty,
				CodeGenerationTools.GetResourceString("Template_ReplaceVsItemTemplateToken")));
			return false;
		}

		return true;
	}

	/// <summary>
	/// Base class for ItemCollectionBuilder classes that
	/// loads the specific types of metadata
	/// </summary>
	private abstract class ItemCollectionBuilder
	{
		private readonly DynamicTextTransformation _textTransformation;
		private readonly string _fileExtension;
		private readonly string _edmxSectionName;
		private readonly string  _rootElementName;

		/// <summary>
		/// FileExtension for individual (non-edmx) metadata file for this
		/// specific ItemCollection type
		/// </summary>
		public string FileExtension
		{
			get { return _fileExtension; }
		}

		/// <summary>
		/// The name of the XmlElement in the .edmx <Runtime> element
		/// to find this ItemCollection's metadata
		/// </summary>
		public string EdmxSectionName
		{
			get { return _edmxSectionName; }
		}

		/// <summary>
		/// The name of the root element of this ItemCollection's metadata
		/// </summary>
		public string RootElementName
		{
			get { return _rootElementName; }
		}

		/// <summary>
		/// Method to build the appropriate ItemCollection
		/// </summary>
		protected abstract ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors);

		/// <summary>
		/// Ctor to setup the ItemCollectionBuilder members
		/// </summary>
		protected ItemCollectionBuilder(DynamicTextTransformation textTransformation, string fileExtension, string edmxSectionName, string rootElementName)
		{
			_textTransformation = textTransformation;
			_fileExtension = fileExtension;
			_edmxSectionName = edmxSectionName;
			_rootElementName = rootElementName;
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected abstract string GetNamespace(SchemaConstants constants);

		/// <summary>
		/// Try to create an ItemCollection loaded with the metadata provided
		/// </summary>
		public bool TryCreateItemCollection(string sourcePath, out ItemCollection itemCollection)
		{
			itemCollection = null;

			if (!ValidateInputPath(sourcePath, _textTransformation))
			{
				return false;
			}

			XElement schemaElement = null;
			if (TryLoadRootElement(sourcePath, out schemaElement))
			{
				List<XmlReader> readers = new List<XmlReader>();
				try
				{
					var providerManifestToken = schemaElement.Attribute("ProviderManifestToken");
					int providerManifestTokenValue;
					if (providerManifestToken != null && int.TryParse(providerManifestToken.Value, out providerManifestTokenValue) && providerManifestTokenValue > 2008)
						providerManifestToken.Value = "2008";
					readers.Add(schemaElement.CreateReader());
					IList<EdmSchemaError> errors = null;

					ItemCollection tempItemCollection = CreateItemCollection(readers, out errors);
					if (ProcessErrors(errors, sourcePath))
					{
						return false;
					}

					itemCollection = tempItemCollection;
					return true;
				}
				finally
				{
					foreach (XmlReader reader in readers)
					{
						((IDisposable)reader).Dispose();
					}
				}
			}

			return false;
		}

		/// <summary>
		/// Tries to load the root element from the metadata file provided
		/// </summary>
		public bool TryLoadRootElement(string sourcePath, out XElement schemaElement)
		{
			schemaElement = null;
			string extension = Path.GetExtension(sourcePath);
			if (extension.Equals(".edmx", StringComparison.InvariantCultureIgnoreCase))
			{
				return TryLoadRootElementFromEdmx(sourcePath, out schemaElement);
			}
			else if(extension.Equals(FileExtension, StringComparison.InvariantCultureIgnoreCase))
			{
				// load from single metadata file (.csdl, .ssdl, or .msl)
				schemaElement = XElement.Load(sourcePath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);
				return true;
			}

			return false;
		}

		/// <summary>
		/// Tries to load the root element from the provided edmxDocument
		/// </summary>
		private bool TryLoadRootElementFromEdmx(XElement edmxDocument, SchemaConstants schemaConstants, string sectionName, string rootElementName, out XElement rootElement)
		{
			rootElement = null;

			XNamespace edmxNs = schemaConstants.EdmxNamespace;
			XNamespace sectionNs = GetNamespace(schemaConstants);

			XElement runtime = edmxDocument.Element(edmxNs  + "Runtime");
			if (runtime == null)
			{
				return false;
			}

			XElement section = runtime.Element(edmxNs + sectionName);
			if (section == null)
			{
				return false;
			}

			string templateVersion;

			if (!TemplateMetadata.TryGetValue(MetadataConstants.TT_TEMPLATE_VERSION, out templateVersion))
			{
				templateVersion = MetadataConstants.DEFAULT_TEMPLATE_VERSION;
			}

			if (schemaConstants.MinimumTemplateVersion > new Version(templateVersion))
			{
				_textTransformation.Errors.Add(new CompilerError(
					_textTransformation.Host.TemplateFile ?? CodeGenerationTools.GetResourceString("Template_CurrentlyRunningTemplate"), 0, 0, string.Empty,
						CodeGenerationTools.GetResourceString("Template_UnsupportedSchema"))
				{IsWarning = true});
			}

			rootElement = section.Element(sectionNs + rootElementName);
			return rootElement != null;
		}

		/// <summary>
		/// Tries to load the root element from the provided .edmx metadata file
		/// </summary>
		private bool TryLoadRootElementFromEdmx(string edmxPath, out XElement rootElement)
		{
			rootElement = null;

			XElement element = XElement.Load(edmxPath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);

			EdmxChanges.EdmxApplyChanges(edmxPath, element);

			return TryLoadRootElementFromEdmx(element, MetadataConstants.V3_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement)
				|| TryLoadRootElementFromEdmx(element, MetadataConstants.V2_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement)
				|| TryLoadRootElementFromEdmx(element, MetadataConstants.V1_SCHEMA_CONSTANTS, EdmxSectionName, RootElementName, out rootElement);
		}

		/// <summary>
		/// Takes an Enumerable of EdmSchemaErrors, and adds them
		/// to the errors collection of the template class
		/// </summary>
		private bool ProcessErrors(IEnumerable<EdmSchemaError> errors, string sourceFilePath)
		{
			bool foundErrors = false;
			foreach (EdmSchemaError error in errors)
			{
				CompilerError newError = new CompilerError(error.SchemaLocation, error.Line, error.Column,
												 error.ErrorCode.ToString(CultureInfo.InvariantCulture),
												 error.Message);
				newError.IsWarning = error.Severity == EdmSchemaErrorSeverity.Warning;
				foundErrors |= error.Severity == EdmSchemaErrorSeverity.Error;
				if (error.SchemaLocation == null)
				{
					newError.FileName = sourceFilePath;
				}
				_textTransformation.Errors.Add(newError);
			}

			return foundErrors;
		}
	}

	/// <summary>
	/// Builder class for creating a StorageMappingItemCollection
	/// </summary>
	private class StorageMappingItemCollectionBuilder : ItemCollectionBuilder
	{
		private readonly EdmItemCollection _edmItemCollection;
		private readonly StoreItemCollection _storeItemCollection;

		public StorageMappingItemCollectionBuilder(DynamicTextTransformation textTransformation, EdmItemCollection edmItemCollection, StoreItemCollection storeItemCollection)
			: base(textTransformation, MetadataConstants.MSL_EXTENSION, MetadataConstants.MSL_EDMX_SECTION_NAME, MetadataConstants.MSL_ROOT_ELEMENT_NAME)
		{
			_edmItemCollection = edmItemCollection;
			_storeItemCollection = storeItemCollection;
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			return MetadataItemCollectionFactory.CreateStorageMappingItemCollection(_edmItemCollection, _storeItemCollection, readers, out errors);
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.MslNamespace;
		}
	}

	/// <summary>
	/// Builder class for creating a StoreItemCollection
	/// </summary>
	private class StoreItemCollectionBuilder : ItemCollectionBuilder
	{
		public StoreItemCollectionBuilder(DynamicTextTransformation textTransformation)
			: base(textTransformation, MetadataConstants.SSDL_EXTENSION, MetadataConstants.SSDL_EDMX_SECTION_NAME, MetadataConstants.SSDL_ROOT_ELEMENT_NAME)
		{
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			return MetadataItemCollectionFactory.CreateStoreItemCollection(readers, out errors);
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.SsdlNamespace;
		}
	}

	/// <summary>
	/// Builder class for creating a EdmItemCollection
	/// </summary>
	private class EdmItemCollectionBuilder : ItemCollectionBuilder
	{
		private List<string> _referenceSchemas = new List<string>();

		public EdmItemCollectionBuilder(DynamicTextTransformation textTransformation)
			: base(textTransformation, MetadataConstants.CSDL_EXTENSION, MetadataConstants.CSDL_EDMX_SECTION_NAME, MetadataConstants.CSDL_ROOT_ELEMENT_NAME)
		{
		}

		public EdmItemCollectionBuilder(DynamicTextTransformation textTransformation, IEnumerable<string> referenceSchemas)
			: this(textTransformation)
		{
			_referenceSchemas.AddRange(referenceSchemas);
		}

		protected override ItemCollection CreateItemCollection(IEnumerable<XmlReader> readers, out IList<EdmSchemaError> errors)
		{
			List<XmlReader> ownedReaders = new List<XmlReader>();
			List<XmlReader> allReaders = new List<XmlReader>();
			try
			{
				allReaders.AddRange(readers);
				foreach (string path in _referenceSchemas.Distinct())
				{
					XElement reference;
					if(TryLoadRootElement(path, out reference))
					{
						XmlReader reader = reference.CreateReader();
						allReaders.Add(reader);
						ownedReaders.Add(reader);
					}
				}

				return MetadataItemCollectionFactory.CreateEdmItemCollection(allReaders, out errors);
			}
			finally
			{
				foreach (XmlReader reader in ownedReaders)
				{
					((IDisposable)reader).Dispose();
				}
			}
		}

		/// <summary>
		/// Selects a namespace from the supplied constants.
		/// </summary>
		protected override string GetNamespace(SchemaConstants constants)
		{
			return constants.CsdlNamespace;
		}
	}
}

/// <summary>
/// Responsible for encapsulating the retrieval and translation of the CodeGeneration
/// annotations in the EntityFramework Metadata to a form that is useful in code generation.
/// </summary>
public static class Accessibility
{
	private const string GETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:GetterAccess";
	private const string SETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:SetterAccess";
	private const string TYPE_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:TypeAccess";
	private const string METHOD_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:MethodAccess";
	private const string ACCESS_PROTECTED = "Protected";
	private const string ACCESS_INTERNAL = "Internal";
	private const string ACCESS_PRIVATE = "Private";
	private static readonly Dictionary<string, int> AccessibilityRankIdLookup = new Dictionary<string, int>
		{
			{ "private", 1},
			{ "internal", 2},
			{ "protected", 3},
			{ "public", 4},
		};

	/// <summary>
	/// Gets the accessibility that should be applied to a type being generated from the provided GlobalItem.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForType(GlobalItem item)
	{
		if (item == null)
		{
			return null;
		}

		return GetAccessibility(item, TYPE_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return propertyAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a Read-Only property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForReadOnlyProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return GetAccessibility(member, GETTER_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a property being
	/// generated from the provided EntitySet.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForReadOnlyProperty(EntitySet set)
	{
		if (set == null)
		{
			return null;
		}

		return GetAccessibility(set, GETTER_ACCESS);
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the property level for a Write-Only property being
	/// generated from the provided EdmMember.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForWriteOnlyProperty(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		return GetAccessibility(member, SETTER_ACCESS);
	}


	/// <summary>
	/// Gets the accessibility that should be applied at the get level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to empty if no annotation is found or the accessibility is the same as the property level.
	/// </summary>
	public static string ForGetter(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return getterAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied at the set level for a property being
	/// generated from the provided EdmMember.
	///
	/// defaults to empty if no annotation is found or the accessibility is the same as the property level.
	/// </summary>
	public static string ForSetter(EdmMember member)
	{
		if (member == null)
		{
			return null;
		}

		string getterAccess, setterAccess, propertyAccess;
		CalculatePropertyAccessibility(member, out propertyAccess, out getterAccess, out setterAccess);
		return setterAccess;
	}

	/// <summary>
	/// Gets the accessibility that should be applied to a method being generated from the provided EdmFunction.
	///
	/// defaults to public if no annotation is found.
	/// </summary>
	public static string ForMethod(EdmFunction function)
	{
		if (function == null)
		{
			return null;
		}

		return GetAccessibility(function, METHOD_ACCESS);
	}

	private static void CalculatePropertyAccessibility(MetadataItem item,
		out string propertyAccessibility,
		out string getterAccessibility,
		out string setterAccessibility)
	{
		getterAccessibility = GetAccessibility(item, GETTER_ACCESS);
		int getterRank = AccessibilityRankIdLookup[getterAccessibility];

		setterAccessibility = GetAccessibility(item, SETTER_ACCESS);
		int setterRank = AccessibilityRankIdLookup[setterAccessibility];

		int propertyRank = Math.Max(getterRank, setterRank);
		if (setterRank == propertyRank)
		{
			setterAccessibility = String.Empty;
		}

		if (getterRank == propertyRank)
		{
			getterAccessibility = String.Empty;
		}

		propertyAccessibility = AccessibilityRankIdLookup.Where(v => v.Value == propertyRank).Select(v => v.Key).Single();
	}

	private static string GetAccessibility(MetadataItem item, string name)
	{
		string accessibility;
		if (MetadataTools.TryGetStringMetadataPropertySetting(item, name, out accessibility))
		{
			return TranslateUserAccessibilityToCSharpAccessibility(accessibility);
		}

		return "public";
	}

	private static string TranslateUserAccessibilityToCSharpAccessibility(string userAccessibility)
	{
		if (userAccessibility == ACCESS_PROTECTED)
		{
			return "protected";
		}
		else if (userAccessibility == ACCESS_INTERNAL)
		{
			return "internal";
		}
		else if (userAccessibility == ACCESS_PRIVATE)
		{
			return "private";
		}
		else
		{
			// default to public
			return "public";
		}
	}
}

/// <summary>
/// Responsible for creating source code regions in code when the loop inside
/// actually produces something.
/// </summary>
public class CodeRegion
{
	private const int STANDARD_INDENT_LENGTH = 4;

	private readonly DynamicTextTransformation _textTransformation;
	private int _beforeRegionLength;
	private int _emptyRegionLength;
	private int _regionIndentLevel = -1;

	/// <summary>
	/// Initializes an CodeRegion instance with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	public CodeRegion(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
	}

	/// <summary>
	/// Initializes an CodeRegion instance with the
	/// TextTransformation (T4 generated class) that is currently running,
	/// and the indent level to start the first region at.
	/// </summary>
	public CodeRegion(object textTransformation, int firstIndentLevel)
		: this(textTransformation)
	{
		if (firstIndentLevel < 0)
		{
			throw new ArgumentException("firstIndentLevel");
		}

		_regionIndentLevel = firstIndentLevel - 1;
	}

	/// <summary>
	/// Starts the begining of a region
	/// </summary>
	public void Begin(string regionName)
	{
		if (regionName == null)
		{
			throw new ArgumentNullException("regionName");
		}

		Begin(regionName, 1);
	}

	/// <summary>
	/// Start the begining of a region, indented
	/// the numbers of levels specified
	/// </summary>
	public void Begin(string regionName, int levelsToIncreaseIndent)
	{
		if (regionName == null)
		{
			throw new ArgumentNullException("regionName");
		}

		_beforeRegionLength = _textTransformation.GenerationEnvironment.Length;
		_regionIndentLevel += levelsToIncreaseIndent;
		_textTransformation.Write(GetIndent(_regionIndentLevel));
		_textTransformation.WriteLine("#region " + regionName);
		_emptyRegionLength = _textTransformation.GenerationEnvironment.Length;
	}

	/// <summary>
	/// Ends a region, or totaly removes it if nothing
	/// was generted since the begining of the region.
	/// </summary>
	public void End()
	{
		End(1);
	}

	/// <summary>
	/// Ends a region, or totaly removes it if nothing
	/// was generted since the begining of the region, also outdents
	/// the number of levels specified.
	/// </summary>
	public void End(int levelsToDecrease)
	{
		int indentLevel = _regionIndentLevel;
		_regionIndentLevel -= levelsToDecrease;

		if (_emptyRegionLength == _textTransformation.GenerationEnvironment.Length)
			_textTransformation.GenerationEnvironment.Length = _beforeRegionLength;
		else
		{
			_textTransformation.WriteLine(String.Empty);
			_textTransformation.Write(GetIndent(indentLevel));
			_textTransformation.WriteLine("#endregion");
			_textTransformation.WriteLine(String.Empty);
		}
	}

	/// <summary>
	/// Gets the current indent level that the next end region statement will be written
	/// at
	/// </summary>
	public int CurrentIndentLevel { get { return _regionIndentLevel; } }

	/// <summary>
	/// Get a string of spaces equivelent to the number of indents
	/// desired.
	/// </summary>
	public static string GetIndent(int indentLevel)
	{
		if (indentLevel < 0)
		{
			throw new ArgumentException("indentLevel");
		}

		return String.Empty.PadLeft(indentLevel * STANDARD_INDENT_LENGTH);
	}
}


/// <summary>
/// Responsible for collecting together the actual method parameters
/// and the parameters that need to be sent to the Execute method.
/// </summary>
public class FunctionImportParameter
{
	public FunctionParameter Source { get; set; }
	public string RawFunctionParameterName { get; set; }
	public string FunctionParameterName { get; set; }
	public string FunctionParameterType { get; set; }
	public string LocalVariableName { get; set; }
	public string RawClrTypeName { get; set; }
	public string ExecuteParameterName { get; set; }
	public string EsqlParameterName { get; set; }
	public bool NeedsLocalVariable { get; set; }
	public bool IsNullableOfT { get; set; }


	/// <summary>
	/// Creates a set of FunctionImportParameter objects from the parameters passed in.
	/// </summary>
	public static IEnumerable<FunctionImportParameter> Create(IEnumerable<FunctionParameter> parameters, CodeGenerationTools code, MetadataTools ef)
	{
		if (parameters == null)
		{
			throw new ArgumentNullException("parameters");
		}

		if (code == null)
		{
			throw new ArgumentNullException("code");
		}

		if (ef == null)
		{
			throw new ArgumentNullException("ef");
		}

		UniqueIdentifierService unique = new UniqueIdentifierService();
		List<FunctionImportParameter> importParameters = new List<FunctionImportParameter>();
		foreach (FunctionParameter parameter in parameters)
		{
			FunctionImportParameter importParameter = new FunctionImportParameter();
			importParameter.Source = parameter;
			importParameter.RawFunctionParameterName = unique.AdjustIdentifier(code.CamelCase(parameter.Name));
			importParameter.FunctionParameterName = code.Escape(importParameter.RawFunctionParameterName);
			if (parameter.Mode == ParameterMode.In)
			{
				TypeUsage typeUsage = parameter.TypeUsage;
				importParameter.NeedsLocalVariable = true;
				importParameter.FunctionParameterType = code.GetTypeName(typeUsage);
				importParameter.EsqlParameterName = parameter.Name;
				Type clrType = ef.UnderlyingClrType(parameter.TypeUsage.EdmType);
				importParameter.RawClrTypeName = typeUsage.EdmType is EnumType ? code.GetTypeName(typeUsage.EdmType) : code.Escape(clrType);
				importParameter.IsNullableOfT = clrType.IsValueType;
			}
			else
			{
				importParameter.NeedsLocalVariable = false;
				importParameter.FunctionParameterType = "ObjectParameter";
				importParameter.ExecuteParameterName = importParameter.FunctionParameterName;
			}
			importParameters.Add(importParameter);
		}

		// we save the local parameter uniquification for a second pass to make the visible parameters
		// as pretty and sensible as possible
		for (int i = 0; i < importParameters.Count; i++)
		{
			FunctionImportParameter importParameter = importParameters[i];
			if (importParameter.NeedsLocalVariable)
			{
				importParameter.LocalVariableName = unique.AdjustIdentifier(importParameter.RawFunctionParameterName + "Parameter");
				importParameter.ExecuteParameterName = importParameter.LocalVariableName;
			}
		}

		return importParameters;
	}

	//
	// Class to create unique variables within the same scope
	//
	private sealed class UniqueIdentifierService
	{
		private readonly HashSet<string> _knownIdentifiers;

		public UniqueIdentifierService()
		{
			_knownIdentifiers = new HashSet<string>(StringComparer.Ordinal);
		}

		/// <summary>
		/// Given an identifier, makes it unique within the scope by adding
		/// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
		/// </summary>
		public string AdjustIdentifier(string identifier)
		{
			// find a unique name by adding suffix as necessary
			int numberOfConflicts = 0;
			string adjustedIdentifier = identifier;

			while (!_knownIdentifiers.Add(adjustedIdentifier))
			{
				++numberOfConflicts;
				adjustedIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
			}

			return adjustedIdentifier;
		}
	}
}

/// <summary>
/// Responsible for marking the various sections of the generation,
/// so they can be split up into separate files
/// </summary>
public class EntityFrameworkTemplateFileManager
{
	/// <summary>
	/// Creates the VsEntityFrameworkTemplateFileManager if VS is detected, otherwise
	/// creates the file system version.
	/// </summary>
	public static EntityFrameworkTemplateFileManager Create(object textTransformation)
	{
		DynamicTextTransformation transformation = DynamicTextTransformation.Create(textTransformation);
		IDynamicHost host = transformation.Host;

#if !PREPROCESSED_TEMPLATE
		var hostServiceProvider = host.AsIServiceProvider();

		if (hostServiceProvider != null)
		{
			EnvDTE.DTE dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));

			if (dte != null)
			{
				return new VsEntityFrameworkTemplateFileManager(transformation);
			}
		}
#endif
		return new EntityFrameworkTemplateFileManager(transformation);
	}

	private sealed class Block
	{
		public String Name;
		public int Start, Length;
	}

	private readonly List<Block> files = new List<Block>();
	private readonly Block footer = new Block();
	private readonly Block header = new Block();
	private readonly DynamicTextTransformation _textTransformation;

	// reference to the GenerationEnvironment StringBuilder on the
	// TextTransformation object
	private readonly StringBuilder _generationEnvironment;

	private Block currentBlock;

	/// <summary>
	/// Initializes an EntityFrameworkTemplateFileManager Instance  with the
	/// TextTransformation (T4 generated class) that is currently running
	/// </summary>
	private EntityFrameworkTemplateFileManager(object textTransformation)
	{
		if (textTransformation == null)
		{
			throw new ArgumentNullException("textTransformation");
		}

		_textTransformation = DynamicTextTransformation.Create(textTransformation);
		_generationEnvironment = _textTransformation.GenerationEnvironment;
	}

	/// <summary>
	/// Marks the end of the last file if there was one, and starts a new
	/// and marks this point in generation as a new file.
	/// </summary>
	public void StartNewFile(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}

		CurrentBlock = new Block { Name = name };
	}

	public void StartFooter()
	{
		CurrentBlock = footer;
	}

	public void StartHeader()
	{
		CurrentBlock = header;
	}

	public void EndBlock()
	{
		if (CurrentBlock == null)
		{
			return;
		}

		CurrentBlock.Length = _generationEnvironment.Length - CurrentBlock.Start;

		if (CurrentBlock != header && CurrentBlock != footer)
		{
			files.Add(CurrentBlock);
		}

		currentBlock = null;
	}

	/// <summary>
	/// Produce the template output files.
	/// </summary>
	public virtual IEnumerable<string> Process(bool split = true)
	{
		var generatedFileNames = new List<string>();

		if (split)
		{
			EndBlock();

			var headerText = _generationEnvironment.ToString(header.Start, header.Length);
			var footerText = _generationEnvironment.ToString(footer.Start, footer.Length);
			var outputPath = Path.GetDirectoryName(_textTransformation.Host.TemplateFile);

			files.Reverse();

			foreach (var block in files)
			{
				var fileName = Path.Combine(outputPath, block.Name);
				var content = headerText + _generationEnvironment.ToString(block.Start, block.Length) + footerText;

				generatedFileNames.Add(fileName);
				CreateFile(fileName, content);
				_generationEnvironment.Remove(block.Start, block.Length);
			}
		}

		return generatedFileNames;
	}

	protected virtual void CreateFile(string fileName, string content)
	{
		if (IsFileContentDifferent(fileName, content))
		{
			File.WriteAllText(fileName, content);
		}
	}

	protected bool IsFileContentDifferent(String fileName, string newContent)
	{
		return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
	}

	private Block CurrentBlock
	{
		get { return currentBlock; }
		set
		{
			if (CurrentBlock != null)
			{
				EndBlock();
			}

			if (value != null)
			{
				value.Start = _generationEnvironment.Length;
			}

			currentBlock = value;
		}
	}

#if !PREPROCESSED_TEMPLATE
	private sealed class VsEntityFrameworkTemplateFileManager : EntityFrameworkTemplateFileManager
	{
		private EnvDTE.ProjectItem templateProjectItem;
		private EnvDTE.DTE dte;
		private Action<string> checkOutAction;
		private Action<IEnumerable<string>> projectSyncAction;

		/// <summary>
		/// Creates an instance of the VsEntityFrameworkTemplateFileManager class with the IDynamicHost instance
		/// </summary>
		public VsEntityFrameworkTemplateFileManager(object textTemplating)
			: base(textTemplating)
		{
			var hostServiceProvider = _textTransformation.Host.AsIServiceProvider();
			if (hostServiceProvider == null)
			{
				throw new ArgumentNullException("Could not obtain hostServiceProvider");
			}

			dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
			if (dte == null)
			{
				throw new ArgumentNullException("Could not obtain DTE from host");
			}

			templateProjectItem = dte.Solution.FindProjectItem(_textTransformation.Host.TemplateFile);

			checkOutAction = fileName => dte.SourceControl.CheckOutItem(fileName);
			projectSyncAction = keepFileNames => ProjectSync(templateProjectItem, keepFileNames);
		}

		public override IEnumerable<string> Process(bool split)
		{
			if (templateProjectItem.ProjectItems == null)
			{
				return new List<string>();
			}

			var generatedFileNames = base.Process(split);

			projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));

			return generatedFileNames;
		}

		protected override void CreateFile(string fileName, string content)
		{
			if (IsFileContentDifferent(fileName, content))
			{
				CheckoutFileIfRequired(fileName);
				File.WriteAllText(fileName, content);
			}
		}

		private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<string> keepFileNames)
		{
			var keepFileNameSet = new HashSet<string>(keepFileNames);
			var projectFiles = new Dictionary<string, EnvDTE.ProjectItem>();
			var originalOutput = Path.GetFileNameWithoutExtension(templateProjectItem.FileNames[0]);

			foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
			{
				projectFiles.Add(projectItem.FileNames[0], projectItem);
			}

			// Remove unused items from the project
			foreach (var pair in projectFiles)
			{
				if (!keepFileNames.Contains(pair.Key)
					&& !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalOutput + "."))
				{
					pair.Value.Delete();
				}
			}

			// Add missing files to the project
			foreach (string fileName in keepFileNameSet)
			{
				if (!projectFiles.ContainsKey(fileName))
				{
					templateProjectItem.ProjectItems.AddFromFile(fileName);
				}
			}
		}

		private void CheckoutFileIfRequired(string fileName)
		{
			if (dte.SourceControl == null
				|| !dte.SourceControl.IsItemUnderSCC(fileName)
					|| dte.SourceControl.IsItemCheckedOut(fileName))
			{
				return;
			}

			// run on worker thread to prevent T4 calling back into VS
			checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
		}
	}
#endif
}

/// <summary>
/// Responsible creating an instance that can be passed
/// to helper classes that need to access the TextTransformation
/// members.  It accesses member by name and signature rather than
/// by type.  This is necessary when the
/// template is being used in Preprocessed mode
/// and there is no common known type that can be
/// passed instead
/// </summary>
public class DynamicTextTransformation
{
	private object _instance;
	IDynamicHost _dynamicHost;

	private readonly MethodInfo _write;
	private readonly MethodInfo _writeLine;
	private readonly PropertyInfo _generationEnvironment;
	private readonly PropertyInfo _errors;
	private readonly PropertyInfo _host;

	private DynamicTextTransformation()
	{
	}

	/// <summary>
	/// Creates an instance of the DynamicTextTransformation class around the passed in
	/// TextTransformation shapped instance passed in, or if the passed in instance
	/// already is a DynamicTextTransformation, it casts it and sends it back.
	/// </summary>
	public static DynamicTextTransformation Create(object instance)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}

		DynamicTextTransformation textTransformation = instance as DynamicTextTransformation;
		if (textTransformation != null)
		{
			return textTransformation;
		}

		return new DynamicTextTransformation(instance);
	}

	private DynamicTextTransformation(object instance)
	{
		_instance = instance;
		Type type = _instance.GetType();
		_write = type.GetMethod("Write", new Type[] { typeof(string) });
		_writeLine = type.GetMethod("WriteLine", new Type[] { typeof(string) });
		_generationEnvironment = type.GetProperty("GenerationEnvironment", BindingFlags.Instance | BindingFlags.NonPublic);
		_host = type.GetProperty("Host");
		_errors = type.GetProperty("Errors");
	}

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's GenerationEnvironment property
	/// </summary>
	public StringBuilder GenerationEnvironment { get { return (StringBuilder)_generationEnvironment.GetValue(_instance, null); } }

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's Errors property
	/// </summary>
	public System.CodeDom.Compiler.CompilerErrorCollection Errors { get { return (System.CodeDom.Compiler.CompilerErrorCollection)_errors.GetValue(_instance, null); } }

	/// <summary>
	/// Calls the wrapped TextTranformation instance's Write method.
	/// </summary>
	public void Write(string text)
	{
		_write.Invoke(_instance, new object[] { text });
	}

	/// <summary>
	/// Calls the wrapped TextTranformation instance's WriteLine method.
	/// </summary>
	public void WriteLine(string text)
	{
		_writeLine.Invoke(_instance, new object[] { text });
	}

	/// <summary>
	/// Gets the value of the wrapped TextTranformation instance's Host property
	/// if available (shows up when hostspecific is set to true in the template directive) and returns
	/// the appropriate implementation of IDynamicHost
	/// </summary>
	public IDynamicHost Host
	{
		get
		{
			if (_dynamicHost == null)
			{
				if(_host == null)
				{
					_dynamicHost = new NullHost();
				}
				else
				{
					_dynamicHost = new DynamicHost(_host.GetValue(_instance, null));
				}
			}
			return _dynamicHost;
		}
	}
}


/// <summary>
/// Reponsible for abstracting the use of Host between times
/// when it is available and not
/// </summary>
public interface IDynamicHost
{
	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// </summary>
	string ResolveParameterValue(string id, string name, string otherName);

	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// </summary>
	string ResolvePath(string path);

	/// <summary>
	/// An abstracted call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// </summary>
	string TemplateFile { get; }

	/// <summary>
	/// Returns the Host instance cast as an IServiceProvider
	/// </summary>
	IServiceProvider AsIServiceProvider();
}

/// <summary>
/// Reponsible for implementing the IDynamicHost as a dynamic
/// shape wrapper over the Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost interface
/// rather than type dependent wrapper.  We don't use the
/// interface type so that the code can be run in preprocessed mode
/// on a .net framework only installed machine.
/// </summary>
public class DynamicHost : IDynamicHost
{
	private readonly object _instance;
	private readonly MethodInfo _resolveParameterValue;
	private readonly MethodInfo _resolvePath;
	private readonly PropertyInfo _templateFile;

	private DynamicHost()
	{
	}

	/// <summary>
	/// Creates an instance of the DynamicHost class around the passed in
	/// Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost shapped instance passed in.
	/// </summary>
	public DynamicHost(object instance)
	{
		_instance = instance;
		Type type = _instance.GetType();
		_resolveParameterValue = type.GetMethod("ResolveParameterValue", new Type[] { typeof(string), typeof(string), typeof(string) });
		_resolvePath = type.GetMethod("ResolvePath", new Type[] { typeof(string) });
		_templateFile = type.GetProperty("TemplateFile");

	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// </summary>
	public string ResolveParameterValue(string id, string name, string otherName)
	{
		return (string)_resolveParameterValue.Invoke(_instance, new object[] { id, name, otherName });
	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// </summary>
	public string ResolvePath(string path)
	{
		return (string)_resolvePath.Invoke(_instance, new object[] { path });
	}

	/// <summary>
	/// A call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// </summary>
	public string TemplateFile
	{
		get
		{
			return (string)_templateFile.GetValue(_instance, null);
		}
	}

	/// <summary>
	/// Returns the Host instance cast as an IServiceProvider
	/// </summary>
	public IServiceProvider AsIServiceProvider()
	{
		return _instance as IServiceProvider;
	}
}

/// <summary>
/// Reponsible for implementing the IDynamicHost when the
/// Host property is not available on the TextTemplating type. The Host
/// property only exists when the hostspecific attribute of the template
/// directive is set to true.
/// </summary>
public class NullHost : IDynamicHost
{
	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolveParameterValue
	/// that simply retuns null.
	/// </summary>
	public string ResolveParameterValue(string id, string name, string otherName)
	{
		return null;
	}

	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost ResolvePath
	/// that simply retuns the path passed in.
	/// </summary>
	public string ResolvePath(string path)
	{
		return path;
	}

	/// <summary>
	/// An abstraction of the call to Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost TemplateFile
	/// that returns null.
	/// </summary>
	public string TemplateFile
	{
		get
		{
			return null;
		}
	}

	/// <summary>
	/// Returns null.
	/// </summary>
	public IServiceProvider AsIServiceProvider()
	{
		return null;
	}
}

/// <summary>
/// Responsible for encapsulating the constants defined in Metadata
/// </summary>
public static class MetadataConstants
{
	public const string CSDL_EXTENSION = ".csdl";

	public const string CSDL_EDMX_SECTION_NAME = "ConceptualModels";
	public const string CSDL_ROOT_ELEMENT_NAME = "Schema";
	public const string EDM_ANNOTATION_09_02 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

	public const string SSDL_EXTENSION = ".ssdl";

	public const string SSDL_EDMX_SECTION_NAME = "StorageModels";
	public const string SSDL_ROOT_ELEMENT_NAME = "Schema";

	public const string MSL_EXTENSION = ".msl";

	public const string MSL_EDMX_SECTION_NAME = "Mappings";
	public const string MSL_ROOT_ELEMENT_NAME = "Mapping";

	public const string TT_TEMPLATE_NAME = "TemplateName";
	public const string TT_TEMPLATE_VERSION = "TemplateVersion";
	public const string TT_MINIMUM_ENTITY_FRAMEWORK_VERSION = "MinimumEntityFrameworkVersion";

	public const string DEFAULT_TEMPLATE_VERSION = "5.0";

	public static readonly SchemaConstants V1_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2007/06/edmx",
		"http://schemas.microsoft.com/ado/2006/04/edm",
		"http://schemas.microsoft.com/ado/2006/04/edm/ssdl",
		"urn:schemas-microsoft-com:windows:storage:mapping:CS",
		new Version("3.5"));

	public static readonly SchemaConstants V2_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2008/10/edmx",
		"http://schemas.microsoft.com/ado/2008/09/edm",
		"http://schemas.microsoft.com/ado/2009/02/edm/ssdl",
		"http://schemas.microsoft.com/ado/2008/09/mapping/cs",
		new Version("4.0"));

	public static readonly SchemaConstants V3_SCHEMA_CONSTANTS = new SchemaConstants(
		"http://schemas.microsoft.com/ado/2009/11/edmx",
		"http://schemas.microsoft.com/ado/2009/11/edm",
		"http://schemas.microsoft.com/ado/2009/11/edm/ssdl",
		"http://schemas.microsoft.com/ado/2009/11/mapping/cs",
		new Version("4.5"));
}

public struct SchemaConstants
{
	public SchemaConstants(string edmxNamespace, string csdlNamespace, string ssdlNamespace, string mslNamespace, Version minimumTemplateVersion) : this()
	{
		EdmxNamespace = edmxNamespace;
		CsdlNamespace = csdlNamespace;
		SsdlNamespace = ssdlNamespace;
		MslNamespace = mslNamespace;
		MinimumTemplateVersion = minimumTemplateVersion;
	}

	public string EdmxNamespace { get; private set; }
	public string CsdlNamespace { get; private set; }
	public string SsdlNamespace { get; private set; }
	public string MslNamespace { get; private set; }
	public Version MinimumTemplateVersion { get; private set; }
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

string edmxUtilityTTIncludeName = "WCFAsyncQueryableServices.VS12.Edmx.Utility.ttinclude";

private static string EDM_NS4 = "http://schemas.microsoft.com/ado/2008/10/edmx";
private static string SSDL_NS4 = "http://schemas.microsoft.com/ado/2009/02/edm/ssdl";
private static string CSDL_NS4 = "http://schemas.microsoft.com/ado/2008/09/edm";
private static string MSL_NS4 = "http://schemas.microsoft.com/ado/2008/09/mapping/cs";
private static string annotation_NS4 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

private static string EDM_NS5 = "http://schemas.microsoft.com/ado/2009/11/edmx";
private static string SSDL_NS5 = "http://schemas.microsoft.com/ado/2009/11/edm/ssdl";
private static string CSDL_NS5 = "http://schemas.microsoft.com/ado/2009/11/edm";
private static string MSL_NS5 = "http://schemas.microsoft.com/ado/2009/11/mapping/cs";
private static string annotation_NS5 = "http://schemas.microsoft.com/ado/2009/02/edm/annotation";

public static string GetEDM_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? EDM_NS4 : EDM_NS5;
}

public static string GetSSDL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? SSDL_NS4 : SSDL_NS5;
}

public static string GetCSDL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? CSDL_NS4 : CSDL_NS5;
}

public static string GetMSL_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? MSL_NS4 : MSL_NS5;
}

public static string GetAnnotation_NS(XElement root)
{
	return root.Element(XName.Get("Runtime", EDM_NS5)) == null ? annotation_NS4 : annotation_NS5;
}

public static IEnumerable<EdmType> GetAllTypes(EdmItemCollection itemCollection)
{
	return itemCollection.GetItems<EntityType>().Cast<EdmType>().Union(itemCollection.GetItems<ComplexType>()).Union(itemCollection.GetItems<EnumType>());
}

partial class OriginalValueMembers
{
	IEnumerable<EdmMember> GetRelevantMembersForUpdate(MetadataWorkspace metadataWorkspace, EntitySetBase entitySet, EntityTypeBase entityType, bool partialUpdateSupported)
	{
		return metadataWorkspace.GetRelevantMembersForUpdate(entitySet, entityType, true);   
	}
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.
void WriteClientFxClientContext(string clientFxComponentModelNamespace, string clientFxEntitiesTrackingNamespace, string clientFxClientContextInterfacesNamespace, string expressionVisitorNamespace, string namespaceName = null, bool useAsyncPrefix = true)
{
    string asyncSuffix = useAsyncPrefix ? "Async" : "";
    CodeGenerationTools code = new CodeGenerationTools(this);
    MetadataLoader loader = new MetadataLoader(this);
    CodeRegion region = new CodeRegion(this, 1);
    if (namespaceName == null)
        namespaceName = code.VsNamespaceSuggestion();

    EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

    string expressionNamespace = clientFxClientContextInterfacesNamespace + ".ExpressionSerialization";

    fileManager.StartNewFile("ClientEntitySetBase.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public abstract class ClientEntitySetBase<ClientContext> : IClientEntitySet<ClientContext>, IDisposable, INotifyCollectionChanged
    where ClientContext : class, IClientContext
{
    public ClientEntitySetBase(string entitySetName, ClientContext context, IList entities, HashSet<IObjectWithChangeTracker> hashSet, Func<IObjectWithChangeTracker, object> getEntityKey)
    {
        EntitySetName = entitySetName;
        Context = context;
        Entities = entities;
        HashSet = hashSet;
        GetEntityKey = getEntityKey;
    }
                                        
    ~ClientEntitySetBase()
    {
        Dispose(false);
    }
        
    protected internal virtual bool EntitiesContains(IObjectWithChangeTracker entity)
    {
        return HashSet.Contains(entity);
    }
        
    protected virtual void EntitiesAdd(IObjectWithChangeTracker entity)
    {
        HashSet.Add(entity);
        Entities.Add(entity);
    }
        
    protected virtual void EntitiesRemove(IObjectWithChangeTracker entity)
    {
        HashSet.Remove(entity);
        Entities.Remove(entity);
    }
                                    
    public string EntitySetName { get; private set; }
                                    
    private SerializableExpression _expression;
    protected internal virtual SerializableExpression Expression 
    { 
        get { return _expression ?? (_expression = new SerializableEntitySetExpression(EntitySetName));}
    }
    SerializableExpression IClientEntitySet.Expression
    {
        get { return Expression; }
    }
                                    
    public ClientContext Context { get; private set; }
    IClientContext IClientEntitySet.Context
    {
        get { return Context; }
    }
    private Dictionary<object, IObjectWithChangeTracker> _entitiesDico;
    private Dictionary<object, IObjectWithChangeTracker> EntitiesDico 
    {
        get { return _entitiesDico ?? (_entitiesDico = new Dictionary<object, IObjectWithChangeTracker>()); }
    }
    protected internal IList Entities { get; private set; }
    protected internal HashSet<IObjectWithChangeTracker> HashSet { get; private set; }
    public Func<IObjectWithChangeTracker, object> GetEntityKey { get; private set; }
    
    protected virtual bool Add(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        entity.ChangeTracker.ChangeTrackingEnabled = true;
        entity.ChangeTracker.State = ObjectState.Added;
        return AddEntity(entity, checkIfAlreadyExist);
    }
                
    protected virtual bool Attach(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        entity.ChangeTracker.AcceptChanges();
        entity.ChangeTracker.ChangeTrackingEnabled = true;
        return AddEntity(entity, checkIfAlreadyExist);
    }
                
    protected bool AddEntity(IObjectWithChangeTracker entity, bool checkIfAlreadyExist = true)
    {
        if (checkIfAlreadyExist && EntitiesContains(entity))
                return false;
        bool notifyCollectionChanged = false;
        int? index = 0;
        var entityKey = GetEntityKey(entity);
                                   
        IObjectWithChangeTracker entityInEntitySet;
        if (checkIfAlreadyExist && (entityInEntitySet = Entities.Cast<IObjectWithChangeTracker>().FirstOrDefault(e => e == entity || GetEntityKey(e).Equals(entityKey))) != null && (entityInEntitySet == entity || !(entity.HasTemporaryKey && entity.ChangeTracker.State == ObjectState.Added)))
        {
            if (entityInEntitySet == entity)
                    return false;
            throw new InvalidOperationException("Another entity with the same key already exists in the context");
        }
        else
        {
            EntitiesAdd(entity);
            index = GetIndex(entity);
            notifyCollectionChanged = true;
        }
        entity.StateChanged += EntityStateChanged;
        if (notifyCollectionChanged)
                NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, entity, index.Value));
        return true;
    }
        
    protected virtual bool Replace(ref IObjectWithChangeTracker entity)
    {
        var entityKey = GetEntityKey(entity);
        var entityDeleted = Entities.Cast<IObjectWithChangeTracker>().FirstOrDefault(e => (GetEntityKey(e).Equals(entityKey)) && (e.ChangeTracker.State == ObjectState.Deleted));
        if (entityDeleted != null)
            return AttachDeletedEntity(ref entity, entityDeleted);
        return Add(entity);
    }
            
    protected virtual bool AttachDeletedEntity(ref IObjectWithChangeTracker entity, IObjectWithChangeTracker entityDeleted)
    {
        entity = entityDeleted;
        return Attach(entity, true);
    }
                        
    void EntityStateChanged(IObjectWithChangeTracker entity, ObjectState state)
    {
        switch (state)
        {
            case ObjectState.CascadeDeleted:
                RemoveCascade(entity);
                break;
        }
    }
                                        
    protected virtual void Remove(IObjectWithChangeTracker entity)
    {
        if (entity.ChangeTracker.State == ObjectState.Added)
            Detach(entity);
        else
            entity.ChangeTracker.State = ObjectState.Deleted;
        int? index;
        index = GetIndex(entity);
        if (index.HasValue)
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity, index.Value));
    }
                                        
    protected virtual void RemoveCascade(IObjectWithChangeTracker entity)
    {
        if (entity.ChangeTracker.State == ObjectState.Added)
            Detach(entity);
        else if (entity.ChangeTracker.State != ObjectState.CascadeDeleted)
        {
            entity.StateChanged -= EntityStateChanged;
            entity.ChangeTracker.State = ObjectState.CascadeDeleted;
            entity.StateChanged += EntityStateChanged;
        }
        int? index = GetIndex(entity);
        if (index.HasValue)
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity, index.Value));
    }
                        
    private int? GetIndex(IObjectWithChangeTracker entity)
    {
        int index = 0;
        foreach (var e in Entities.OfType<IObjectWithChangeTracker>().Where(e => (e.ChangeTracker.State & ObjectState.Deleted) == 0 || e == entity))
        {
            if (e == entity)
                return index;
            index++;
        }
        return null;
    }
                                        
    protected virtual void Detach(IObjectWithChangeTracker entity)
    {
        entity.ChangeTracker.DetachedPreviousState = entity.ChangeTracker.State; 
        int? index;
        entity.StateChanged -= EntityStateChanged;
        index = GetIndex(entity);
        EntitiesRemove(entity);
        entity.ChangeTracker.AcceptChanges(false);
        entity.ChangeTracker.State = ObjectState.Detached;
        entity.ChangeTracker.ChangeTrackingEnabled = false;
        if (index.HasValue)
            NotifyCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, entity, index.Value));
    }
                                        
    void IClientEntitySet<ClientContext>.Add(IObjectWithChangeTracker entity)
    {
        Add(entity);
    }
            
    public void AddWithoutCheckingIfAlreadyExist(IObjectWithChangeTracker entity)
    {
        Add(entity, false);
    }							
                
    void IClientEntitySet<ClientContext>.Attach(IObjectWithChangeTracker entity)
    {
        Attach(entity);
    }
                
    public void AttachWithoutCheckingIfAlreadyExist(IObjectWithChangeTracker entity)
    {
        Attach(entity, false);
    }
                                        
    void IClientEntitySet<ClientContext>.Remove(IObjectWithChangeTracker entity)
    {
        Remove(entity);
    }
                                        
    void IClientEntitySet<ClientContext>.Detach(IObjectWithChangeTracker entity)
    {
        Detach(entity);
    }
        
    void IClientEntitySet<ClientContext>.Replace(ref IObjectWithChangeTracker entity)
    {
        Replace(ref entity);
    }
                                        
    public bool AttachWithoutChangingState(IObjectWithChangeTracker entity, ObjectState? defaultState = ObjectState.Unchanged)
    {
        if (EntitiesContains(entity))
            return false;
        if (entity.ChangeTracker.State == ObjectState.Detached)
        {
            entity.ChangeTracker.ChangeTrackingEnabled = true;
            if (entity.ChangeTracker.IsAttaching)
            {
                entity.ChangeTracker.State = ObjectState.Unchanged;
                entity.ChangeTracker.IsAttaching = false;
            }
            else
                entity.ChangeTracker.State = defaultState ?? ObjectState.Added;
        }
        AddEntity(entity);
        if (entity.ChangeTracker.State == ObjectState.Added)
            OnAdded(entity);
        else
            OnAttached(entity);
        return true;
    }
    protected virtual void OnAdded(IObjectWithChangeTracker entity)
    {
    }
    protected virtual void OnAttached(IObjectWithChangeTracker entity)
    {
    }
    public virtual int Count
    {
        get
        {
            var enumerator = GetEnumerable().GetEnumerator();
            int value = 0;
            while (enumerator.MoveNext()) value++;
            return value;
        }
    }
                            
    protected IEnumerable<IObjectWithChangeTracker> AllEntities
    {
        get
        {
            if (Entities == null)
                return new IObjectWithChangeTracker[0];
            return Entities.Cast<IObjectWithChangeTracker>();
        }
    }
                                        
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
    protected virtual IEnumerable GetEnumerable()
    {
        return Entities.OfType<IObjectWithChangeTracker>().Where(e => (e.ChangeTracker.State & ObjectState.Deleted) == 0);
    }
    protected abstract Type GetEntityType();
                                        
    public event NotifyCollectionChangedEventHandler CollectionChanged;
    protected void NotifyCollectionChanged(NotifyCollectionChangedEventArgs arg)
    {
        if (CollectionChanged != null)
            CollectionChanged(this, arg);
    }
                                        
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
                                        
    protected internal virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            foreach (var entity in AllEntities.ToList())
            {
                entity.ChangeTracker.AcceptChanges(false); 
                entity.ChangeTracker.ChangeTrackingEnabled = false;
                entity.StateChanged -= EntityStateChanged;
                entity.ChangeTracker.ClientContextDispose();
            }
            _entitiesDico = null;
            GetEntityKey = null;
        }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("ClientEntitySet.cs");
WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public class ClientEntitySet<ClientContext, EntityType> : ClientEntitySetBase<ClientContext>, IClientEntitySet<ClientContext, EntityType>, IEnumerable<EntityType>
    where ClientContext : class, IClientContext
    where EntityType : class, IObjectWithChangeTracker
{
    private HashSet<EntityType> _hashSet = new HashSet<EntityType>();
    private List<KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>> _entitiesStateChanged = new List<KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>>();
    
    public ClientEntitySet(string entitySetName, ClientContext context, Func<EntityType, object> getEntityKey)
        : base(entitySetName, context, new List<EntityType>(), new HashSet<IObjectWithChangeTracker>(), e => getEntityKey((EntityType)e))
    {
    }

    protected ClientEntitySet(string entitySetName, ClientContext context, IList entities, HashSet<IObjectWithChangeTracker> hashSet, Func<IObjectWithChangeTracker, object> getEntityKey)
        : base(entitySetName, context, entities, hashSet, getEntityKey)
    {
    }
    
    public new IEnumerable<EntityType> AllEntities
    {
        get { return base.AllEntities.OfType<EntityType>(); }
    }
    
    public virtual void Add(EntityType entity)
    {
        if (base.Add(entity))
            OnEntityAdded(entity);
    }
    
    public virtual void AddWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        if (base.Add(entity, false))
            OnEntityAdded(entity);
    }
    
    public virtual void Attach(EntityType entity)
    {
        if (base.Attach(entity))
            OnEntityAttached(entity);
    }
    
    public virtual void AttachWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        if (base.Attach(entity, false))
            OnEntityAttached(entity);
    }
    
    public virtual void Remove(EntityType entity)
    {
        OnEntityRemoving(entity);
        base.Remove(entity);
        OnEntityRemoved(entity);
    }
    
    public virtual void RemoveCascade(EntityType entity)
    {
        OnEntityRemoving(entity);
        base.RemoveCascade(entity);
        OnEntityRemoved(entity);
    }
    
    public virtual void Detach(EntityType entity)
    {
        base.Detach(entity);
    }
    
    protected override void EntitiesAdd(IObjectWithChangeTracker entity)
    {
        base.EntitiesAdd(entity);
        EventHandler<ObjectStateChangedEventArgs> entityChangeTrackerObjectStateChanged = null;
        entityChangeTrackerObjectStateChanged = (_, e) =>
            {
                if (e.NewState == ObjectState.Detached)
                {
                    entity.ChangeTracker.ObjectStateChanged -= entityChangeTrackerObjectStateChanged;
                    var entityStateChanged = _entitiesStateChanged.FirstOrDefault(esc => esc.Key == e);
                    if (entityStateChanged.Key != null)
                        _entitiesStateChanged.Remove(entityStateChanged);
                    OnEntityDetached((EntityType)entity);
                }
            };
        entity.ChangeTracker.ObjectStateChanged += entityChangeTrackerObjectStateChanged;
        _entitiesStateChanged.Add(new KeyValuePair<IObjectWithChangeTracker, EventHandler<ObjectStateChangedEventArgs>>(entity, entityChangeTrackerObjectStateChanged));
    }
    
    public bool Contains(EntityType entity)
    {
        return EntitiesContains(entity);
    }
    
    public virtual void Replace(ref EntityType entity)
    {            
        IObjectWithChangeTracker owct = entity;
        if (base.Replace(ref owct))
        {
            if (owct == entity)
                OnEntityAdded(entity);
            else
                OnEntityAttached((EntityType)owct);
        }

        entity = (EntityType)owct;
    }
    
    protected override bool AttachDeletedEntity(ref IObjectWithChangeTracker entity, IObjectWithChangeTracker entityDeleted)
    {
        var originalEntity = entity;
        var result = base.AttachDeletedEntity(ref entity, entityDeleted);
        if (result)
            OnEntityReplaced((EntityType)entityDeleted, (EntityType)originalEntity);
        else
            OnEntityAdded((EntityType)entityDeleted);
        return result;
    }
    
    protected virtual void OnEntityAdded(EntityType entity)
    {
        if (EntityAdded != null)
            EntityAdded(entity);
    }
    public event Action<EntityType> EntityAdded;
    protected override void OnAdded(IObjectWithChangeTracker entity)
    {
        base.OnAdded(entity);
        OnEntityAdded((EntityType)entity);
    }
    
    protected virtual void OnEntityAttached(EntityType entity)
    {
        var isInitializingRelationships = entity.IsInitializingRelationships;
        entity.IsInitializingRelationships = true;
        if (EntityAttached != null)
            EntityAttached(entity);
        entity.IsInitializingRelationships = isInitializingRelationships;
    }
    public event Action<EntityType> EntityAttached;
        
    protected override void OnAttached(IObjectWithChangeTracker entity)
    {
        base.OnAttached(entity);
        OnEntityAttached((EntityType)entity);
    }
    
    protected virtual void OnEntityRemoving(EntityType entity)
    {
        if (EntityRemoving != null)
            EntityRemoving(entity);
    }
    public event Action<EntityType> EntityRemoving;
    
    protected virtual void OnEntityRemoved(EntityType entity)
    {
        if (EntityRemoved != null)
            EntityRemoved(entity);
    }
    public event Action<EntityType> EntityRemoved;
    
    protected virtual void OnEntityDetached(EntityType entity)
    {
        if (EntityDetached != null)
            EntityDetached(entity);
    }
    public event Action<EntityType> EntityDetached;
    
    protected virtual void OnEntityReplaced(EntityType entityRemoved, EntityType entity)
    {
        if (EntityReplaced != null)
            EntityReplaced(entityRemoved, entity);
    }
    public event Action<EntityType, EntityType> EntityReplaced;
    
    public virtual EntityType this[int index]
    {
        get { return (EntityType)Entities[index]; }
    }
    
    protected new virtual IEnumerable<EntityType> GetEnumerable()
    {
        return base.GetEnumerable().OfType<EntityType>();
    }
    
    public IEnumerator<EntityType> GetEnumerator()
    {
        return GetEnumerable().Cast<EntityType>().GetEnumerator();
    }
    
    protected override Type GetEntityType()
    {
        return typeof(EntityType);
    }

    protected internal override void Dispose(bool disposing)
    {
        if (disposing)
        {
            foreach (var item in _entitiesStateChanged)
                item.Key.ChangeTracker.ObjectStateChanged -= item.Value;
            _entitiesStateChanged.Clear();
        }
        base.Dispose(disposing);
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("ClientSubEntitySet.cs");
WriteHeader(namespaceName, code, "System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public class ClientSubEntitySet<ClientContext, EntityType, EntityTypeBase> : ClientEntitySet<ClientContext, EntityType>, IEnumerable<EntityType>, IDisposable
    where ClientContext : class, IClientContext
    where EntityTypeBase : class, IObjectWithChangeTracker
    where EntityType : class, EntityTypeBase
{
    private ClientEntitySet<ClientContext, EntityTypeBase> _entitySet;
            
    public ClientSubEntitySet(ClientEntitySet<ClientContext, EntityTypeBase> entitySet)
        : base(entitySet.EntitySetName, entitySet.Context, entitySet.Entities, entitySet.HashSet, e => entitySet.GetEntityKey(e))
    {
        _entitySet = entitySet;
        _entitySet.CollectionChanged += EntitySetCollectionChanged;
        _entitySet.EntityRemoving += EntitySetEntityRemoving;
    }
            
    private SerializableExpression _expression;
    protected internal override SerializableExpression Expression 
    { 
        get { return _expression ?? (_expression = new SerializableMethodCallExpression(null, new[] { base.Expression }, typeof(Queryable).GetMethod("OfType").MakeGenericMethod(typeof(EntityType)))); }
    }
            
    private void EntitySetCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
        NotifyCollectionChanged(e);
    }
    
    private void EntitySetEntityRemoving(EntityTypeBase entity)
    {
        var entityAsEntityType = entity as EntityType;
        if (entityAsEntityType != null)
            OnEntityRemoving(entityAsEntityType);
    }
            
    public override void Add(EntityType entity)
    {
        _entitySet.Add(entity);
        OnEntityAdded(entity);
    }
            
    public override void Attach(EntityType entity)
    {
        _entitySet.Attach(entity);
        OnEntityAttached(entity);
    }
            
    public override void AttachWithoutCheckingIfAlreadyExist(EntityType entity)
    {
        _entitySet.Attach(entity);
        OnEntityAttached(entity);
    }
            
    public override void Remove(EntityType entity)
    {
        _entitySet.Remove(entity);
        OnEntityRemoved(entity);
    }
            
    public override void Detach(EntityType entity)
    {
        _entitySet.Detach(entity);
        OnEntityDetached(entity);
    }
            
    public override EntityType this[int index]
    {
        get
        {
            return GetEnumerable().ElementAt(index);
        }
    }
            
    public override int Count
    {
        get
        {
            return GetEnumerable().Count();
        }
    }
            
    protected override IEnumerable<EntityType> GetEnumerable()
    {
        return _entitySet.OfType<EntityType>();
    }
            
    IEnumerator<EntityType> IEnumerable<EntityType>.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerable().GetEnumerator();
    }
            
    protected internal override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _entitySet.CollectionChanged -= EntitySetCollectionChanged;
            _entitySet.EntityRemoving -= EntitySetEntityRemoving;
            _entitySet = null;
        }
        base.Dispose(disposing);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ExpressionExtension.cs");
    WriteHeader(namespaceName + ".ExpressionSerialization", code, "System", "System.Linq.Expressions");
#>
public static class ExpressionExtension
{
    public static Expression ReplaceExpression(this Expression expression, Expression source, Expression replace)
    {
        return ReplaceExpression(expression, e => e == source ? replace : e);
    }
                    
    public static Expression ReplaceExpression(this Expression expression, Func<Expression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceExpressionFunc = replace }.Visit(expression);
    }
                
    public static Expression ReplaceParameter(this Expression expression, ParameterExpression parameter, Expression replace)
    {
        return ReplaceParameter(expression, n => n == parameter ? replace : n);
    }
                
    public static Expression ReplaceParameter(this Expression expression, Func<ParameterExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceParameterFunc = replace }.Visit(expression);
    }
                
    public static Expression ReplaceBodyParameter(this LambdaExpression expression, Expression replace)
    {
        return ReplaceParameter(expression.Body, n => n == expression.Parameters[0] ? replace : n);
    }
                
    public static Expression ReplaceMethodCall(this Expression expression, MethodCallExpression methodCall, Expression replace)
    {
        return ReplaceMethodCall(expression, n => n == methodCall ? replace : n);
    }
                
    public static Expression ReplaceMethodCall(this Expression expression, Func<MethodCallExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceMethodCallFunc = replace }.Visit(expression);
    }
            
    public static Expression ReplaceConstant(this Expression expression, ConstantExpression constant, Expression replace)
    {
        return ReplaceConstant(expression, n => n == constant ? replace : n);
    }
            
    public static Expression ReplaceConstant(this Expression expression, Func<ConstantExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceConstantFunc = replace }.Visit(expression);
    }
        
    public static Expression ReplaceInvocation(this Expression expression, InvocationExpression invocation, Expression replace)
    {
        return ReplaceInvocation(expression, n => n == invocation ? replace : n);
    }
        
    public static Expression ReplaceInvocation(this Expression expression, Func<InvocationExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceInvocationFunc = replace }.Visit(expression);
    }
        
    public static Expression ReplaceBinary(this Expression expression, BinaryExpression invocation, Expression replace)
    {
        return ReplaceBinary(expression, n => n == invocation ? replace : n);
    }
        
    public static Expression ReplaceBinary(this Expression expression, Func<BinaryExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceBinaryFunc = replace }.Visit(expression);
    }
    
    public static Expression ReplaceMember(this Expression expression, MemberExpression invocation, Expression replace)
    {
        return ReplaceMember(expression, n => n == invocation ? replace : n);
    }
    
    public static Expression ReplaceMember(this Expression expression, Func<MemberExpression, Expression> replace)
    {
        return new ExpressionReplaceRewriter { ReplaceMemberFunc = replace }.Visit(expression);
    }
                
    public class ExpressionReplaceRewriter : ExpressionVisitor
    {
        public Func<Expression, Expression> ReplaceExpressionFunc { get; set; }
        public override Expression Visit(Expression node)
        {
            if (ReplaceExpressionFunc != null)
            {
                var value = ReplaceExpressionFunc(node);
                if (value != node)
                    return value;
            }
            return base.Visit(node);
        }
                
        public Func<ParameterExpression, Expression> ReplaceParameterFunc { get; set; }
        protected override Expression VisitParameter(ParameterExpression node)
        {
            if (ReplaceParameterFunc != null)
            {
                var value = ReplaceParameterFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitParameter(node);
        }
                
        public Func<MethodCallExpression, Expression> ReplaceMethodCallFunc { get; set; }
        protected override Expression VisitMethodCall(MethodCallExpression node)
        {
            if (ReplaceMethodCallFunc != null)
            {
                var value = ReplaceMethodCallFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitMethodCall(node);
        }
            
        public Func<ConstantExpression, Expression> ReplaceConstantFunc { get; set; }
        protected override Expression VisitConstant(ConstantExpression node)
        {
            if (ReplaceConstantFunc != null)
            {
                var value = ReplaceConstantFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitConstant(node);
        }
        
        public Func<InvocationExpression, Expression> ReplaceInvocationFunc { get; set; }
        protected override Expression VisitInvocation(InvocationExpression node)
        {
            if (ReplaceInvocationFunc != null)
            {
                var value = ReplaceInvocationFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitInvocation(node);
        }
        
        public Func<BinaryExpression, Expression> ReplaceBinaryFunc { get; set; }
        protected override Expression VisitBinary(BinaryExpression node)
        {
            if (ReplaceBinaryFunc != null)
            {
                var value = ReplaceBinaryFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitBinary(node);
        }
    
        public Func<MemberExpression, Expression> ReplaceMemberFunc { get; set; }
        protected override Expression VisitMember(MemberExpression node)
        {
            if (ReplaceMemberFunc != null)
            {
                var value = ReplaceMemberFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitMember(node);
        }
    }
}
<#+
WriteFooter(namespaceName + ".ExpressionSerialization");

fileManager.StartNewFile("AsyncQueryableExtensions.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Linq.Expressions", "System.Reflection", "System.Threading.Tasks", expressionNamespace, namespaceName + ".ExpressionSerialization", clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace);
#>
public static class AsyncQueryableExtensions
{
    public static Task<IEnumerable<T>> Execute<#=asyncSuffix#><T>(this IAsyncQueryable<T> query, MergeOption? mergeOption = null)
    {
        return query.Context.ExecuteQuery<#=asyncSuffix#>(query, mergeOption);
    }
    public static Task<T> Execute<#=asyncSuffix#><T>(this IAsyncQueryableValue<T> query, MergeOption? mergeOption = null)
    {
        return query.Context.ExecuteQuery<#=asyncSuffix#>(query, mergeOption);
    }
        
    public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> All<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethod("All").MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Any<TSource>(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Any<TSource>(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryableValue<bool> Any<TSource>(IAsyncQueryable<TSource> source, SerializableExpression serializablePredicate)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Any" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average(this IAsyncQueryable<decimal?> source)
    {
        return Average<decimal?>(source);
    }
    public static IAsyncQueryableValue<decimal> Average(this IAsyncQueryable<decimal> source)
    {
        return Average<decimal>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<double?> source)
    {
        return Average<double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<double> source)
    {
        return Average<double>(source);
    }
    public static IAsyncQueryableValue<float?> Average(this IAsyncQueryable<float?> source)
    {
        return Average<float?>(source);
    }
    public static IAsyncQueryableValue<float> Average(this IAsyncQueryable<float> source)
    {
        return Average<float>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<int?> source)
    {
        return Average<int?, double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<int> source)
    {
        return Average<int, double>(source);
    }
    public static IAsyncQueryableValue<double?> Average(this IAsyncQueryable<long?> source)
    {
        return Average<long?, double?>(source);
    }
    public static IAsyncQueryableValue<double> Average(this IAsyncQueryable<long> source)
    {
        return Average<long, double>(source);
    }
    private static IAsyncQueryableValue<T> Average<T>(this IAsyncQueryable<T> source)
    {
        return Average<T, T>(source);
    }
    private static IAsyncQueryableValue<TResult> Average<TSource, TResult>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters()[0].ParameterType == typeof(IQueryable<TSource>))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
    {
        return Average<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
    {
        return Average<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
    {
        return Average<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
    {
        return Average<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
    {
        return Average<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
    {
        return Average<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
    {
        return Average<TSource, int?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
    {
        return Average<TSource, int, double>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
    {
        return Average<TSource, long?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
    {
        return Average<TSource, long, double>(source, selector);
    }
    private static IAsyncQueryableValue<T> Average<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        return Average<TSource, T, T>(source, selector);
    }
    private static IAsyncQueryableValue<TResult> Average<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
    {
        return AverageAsyncQueryable<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
    {
        return AverageAsyncQueryable<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
    {
        return AverageAsyncQueryable<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
    {
        return AverageAsyncQueryable<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
    {
        return AverageAsyncQueryable<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
    {
        return AverageAsyncQueryable<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
    {
        return AverageAsyncQueryable<TSource, int?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
    {
        return AverageAsyncQueryable<TSource, int, double>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
    {
        return AverageAsyncQueryable<TSource, long?, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Average<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
    {
        return AverageAsyncQueryable<TSource, long, double>(source, selector);
    }
    private static IAsyncQueryableValue<T> AverageAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        return AverageAsyncQueryable<TSource, T, T>(source, selector);
    }
    private static IAsyncQueryableValue<TResult> AverageAsyncQueryable<TSource, T, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Average" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Cast<TResult>(this IAsyncQueryable source)
    {
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Cast").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
    }
        
    public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, T value)
    {
        return new AsyncQueryableValue<bool>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(value, typeof(T)) }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<bool> Contains<T>(this IAsyncQueryable<T> source, IAsyncQueryableValue<T> value)
    {
        return new AsyncQueryableValue<bool>(source.Context, Contains<T>(source.Expression, value.Expression), source.ParameterMode);
    }
    public static SerializableExpression Contains<T>(SerializableExpression source, SerializableExpression value)
    {
        return new SerializableMethodCallExpression(null, new[] { source, value }, typeof(Queryable).GetMethods().First(m => m.Name == "Contains" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(T)));
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<int> Count<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<int>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Count" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> DefaultIfEmpty<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "DefaultIfEmpty" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Distinct<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Except<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Except" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> First<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "First" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> FirstOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "FirstOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TKey>>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<IGrouping<TKey, TSource>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<int?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<uint?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<short?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ushort?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<byte?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<long?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<ulong?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<decimal?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<double?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<char?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<DateTime?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TimeSpan?>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> GroupJoin<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<string>, TResult>> resultSelector)
    {
        return GroupJoin<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    private static IAsyncQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "GroupJoin" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Intersect<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Intersect" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IAsyncQueryable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, inner.Expression, serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int, TKey>> innerKeySelector, Expression<Func<TOuter, int, TResult>> resultSelector)
    {
        return Join<TOuter, int, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint, TKey>> innerKeySelector, Expression<Func<TOuter, uint, TResult>> resultSelector)
    {
        return Join<TOuter, uint, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short, TKey>> innerKeySelector, Expression<Func<TOuter, short, TResult>> resultSelector)
    {
        return Join<TOuter, short, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort, TKey>> innerKeySelector, Expression<Func<TOuter, ushort, TResult>> resultSelector)
    {
        return Join<TOuter, ushort, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte, TKey>> innerKeySelector, Expression<Func<TOuter, byte, TResult>> resultSelector)
    {
        return Join<TOuter, byte, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long, TKey>> innerKeySelector, Expression<Func<TOuter, long, TResult>> resultSelector)
    {
        return Join<TOuter, long, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong, TKey>> innerKeySelector, Expression<Func<TOuter, ulong, TResult>> resultSelector)
    {
        return Join<TOuter, ulong, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal, TKey>> innerKeySelector, Expression<Func<TOuter, decimal, TResult>> resultSelector)
    {
        return Join<TOuter, decimal, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double, TKey>> innerKeySelector, Expression<Func<TOuter, double, TResult>> resultSelector)
    {
        return Join<TOuter, double, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char, TKey>> innerKeySelector, Expression<Func<TOuter, char, TResult>> resultSelector)
    {
        return Join<TOuter, char, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime, TResult>> resultSelector)
    {
        return Join<TOuter, DateTime, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan, TResult>> resultSelector)
    {
        return Join<TOuter, TimeSpan, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<int?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<int?, TKey>> innerKeySelector, Expression<Func<TOuter, int?, TResult>> resultSelector)
    {
        return Join<TOuter, int?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<uint?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<uint?, TKey>> innerKeySelector, Expression<Func<TOuter, uint?, TResult>> resultSelector)
    {
        return Join<TOuter, uint?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<short?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<short?, TKey>> innerKeySelector, Expression<Func<TOuter, short?, TResult>> resultSelector)
    {
        return Join<TOuter, short?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ushort?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ushort?, TKey>> innerKeySelector, Expression<Func<TOuter, ushort?, TResult>> resultSelector)
    {
        return Join<TOuter, ushort?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<byte?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<byte?, TKey>> innerKeySelector, Expression<Func<TOuter, byte?, TResult>> resultSelector)
    {
        return Join<TOuter, byte?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<long?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<long?, TKey>> innerKeySelector, Expression<Func<TOuter, long?, TResult>> resultSelector)
    {
        return Join<TOuter, long?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<ulong?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<ulong?, TKey>> innerKeySelector, Expression<Func<TOuter, ulong?, TResult>> resultSelector)
    {
        return Join<TOuter, ulong?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<decimal?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<decimal?, TKey>> innerKeySelector, Expression<Func<TOuter, decimal?, TResult>> resultSelector)
    {
        return Join<TOuter, decimal?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<double?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<double?, TKey>> innerKeySelector, Expression<Func<TOuter, double?, TResult>> resultSelector)
    {
        return Join<TOuter, double?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<char?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<char?, TKey>> innerKeySelector, Expression<Func<TOuter, char?, TResult>> resultSelector)
    {
        return Join<TOuter, char?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<DateTime?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<DateTime?, TKey>> innerKeySelector, Expression<Func<TOuter, DateTime?, TResult>> resultSelector)
    {
        return Join<TOuter, DateTime?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TimeSpan?> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TimeSpan?, TKey>> innerKeySelector, Expression<Func<TOuter, TimeSpan?, TResult>> resultSelector)
    {
        return Join<TOuter, TimeSpan?, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    public static IAsyncQueryable<TResult> Join<TOuter, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<string> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<string, TKey>> innerKeySelector, Expression<Func<TOuter, string, TResult>> resultSelector)
    {
        return Join<TOuter, string, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector);
    }
    private static IAsyncQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IAsyncQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
    {
        var serializableOuterKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableOuterKeySelectorReference, outer.ParameterMode, outer.Context).Visit(outerKeySelector);
        var serializableInnerKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableInnerKeySelectorReference, outer.ParameterMode, outer.Context).Visit(innerKeySelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, outer.ParameterMode, outer.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(outer.Context, new SerializableMethodCallExpression(null, new[] { outer.Expression, outer.ParameterMode == ParameterMode.OnDefinition ? new SerializableConstantExpression(inner, typeof(IEnumerable<TInner>)) : new SerializableConstantExpression((Delegate)(Func<IEnumerable<TInner>>)(() => inner), typeof(IEnumerable<TInner>)), serializableOuterKeySelectorReference.Value, serializableInnerKeySelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Join" && m.GetParameters().Length == 5).MakeGenericMethod(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult))), outer.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Last<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Last" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> LastOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LastOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<long> LongCount<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<long>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "LongCount" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Max<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TResult> Max<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Max" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Min<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TResult> Min<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Min" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> OfType<TResult>(this IAsyncQueryable source)
    {
        if (source.Type == typeof(TResult))
            return (IAsyncQueryable<TResult>)source;
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("OfType").MakeGenericMethod(typeof(TResult))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties.Where(p => typeof(TResult).GetProperty(p) != null), source.SelectedProperties.Where(p => typeof(TResult).GetProperty(p) != null));
    }
        
    public static IAsyncQueryable<TSource> OrderBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> OrderByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "OrderByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Reverse<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethod("Reverse").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<TResult>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<TResult> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<TResult>>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<TResult>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<IEnumerable<TResult>> Select<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
    {
        if (selector.Body == selector.Parameters[0])
            return (IAsyncQueryable<IEnumerable<TResult>>)source;
        var memberInit = selector.Body as MemberInitExpression;
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<IEnumerable<TResult>>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Select" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(IEnumerable<TResult>))), source.ParameterMode, selectedProperties: memberInit == null ? null : memberInit.Bindings.Select(mb => mb.Member.Name));
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TResult>>> selector)
    {
        var serializableSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableSelectorReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
    {
        var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
    {
        var serializableCollectionSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableCollectionSelectorReference, source.ParameterMode, source.Context).Visit(collectionSelector);
        ((SerializableLambdaExpression)serializableCollectionSelectorReference.Value).ReturnType = new SerializableType(typeof(IEnumerable<TCollection>));
        var serializableResultSelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableResultSelectorReference, source.ParameterMode, source.Context).Visit(resultSelector);
        return new AsyncQueryable<TResult>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableCollectionSelectorReference.Value, serializableResultSelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 3 && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TCollection), typeof(TResult))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Single<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Single" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source)
    {
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> SingleOrDefault<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return new AsyncQueryableValue<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "SingleOrDefault" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Skip<TSource>(this IAsyncQueryable<TSource> source, int count)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Skip").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum(this IAsyncQueryable<decimal?> source)
    {
        return Sum<decimal?>(source);
    }
    public static IAsyncQueryableValue<decimal> Sum(this IAsyncQueryable<decimal> source)
    {
        return Sum<decimal>(source);
    }
    public static IAsyncQueryableValue<double?> Sum(this IAsyncQueryable<double?> source)
    {
        return Sum<double?>(source);
    }
    public static IAsyncQueryableValue<double> Sum(this IAsyncQueryable<double> source)
    {
        return Sum<double>(source);
    }
    public static IAsyncQueryableValue<float?> Sum(this IAsyncQueryable<float?> source)
    {
        return Sum<float?>(source);
    }
    public static IAsyncQueryableValue<float> Sum(this IAsyncQueryable<float> source)
    {
        return Sum<float>(source);
    }
    public static IAsyncQueryableValue<int?> Sum(this IAsyncQueryable<int?> source)
    {
        return Sum<int?>(source);
    }
    public static IAsyncQueryableValue<int> Sum(this IAsyncQueryable<int> source)
    {
        return Sum<int>(source);
    }
    public static IAsyncQueryableValue<long?> Sum(this IAsyncQueryable<long?> source)
    {
        return Sum<long?>(source);
    }
    public static IAsyncQueryableValue<long> Sum(this IAsyncQueryable<long> source)
    {
        return Sum<long>(source);
    }
    private static IAsyncQueryableValue<T> Sum<T>(this IAsyncQueryable<T> source)
    {
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters()[0].ParameterType == typeof(IQueryable<T>))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
    {
        return Sum<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
    {
        return Sum<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
    {
        return Sum<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, double>> selector)
    {
        return Sum<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
    {
        return Sum<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, float>> selector)
    {
        return Sum<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
    {
        return Sum<TSource, int?>(source, selector);
    }
    public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, int>> selector)
    {
        return Sum<TSource, int>(source, selector);
    }
    public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
    {
        return Sum<TSource, long?>(source, selector);
    }
    public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, long>> selector)
    {
        return Sum<TSource, long>(source, selector);
    }
    private static IAsyncQueryableValue<T> Sum<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, T>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryableValue<decimal?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal?>>> selector)
    {
        return SumAsyncQueryable<TSource, decimal?>(source, selector);
    }
    public static IAsyncQueryableValue<decimal> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<decimal>>> selector)
    {
        return SumAsyncQueryable<TSource, decimal>(source, selector);
    }
    public static IAsyncQueryableValue<double?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double?>>> selector)
    {
        return SumAsyncQueryable<TSource, double?>(source, selector);
    }
    public static IAsyncQueryableValue<double> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<double>>> selector)
    {
        return SumAsyncQueryable<TSource, double>(source, selector);
    }
    public static IAsyncQueryableValue<float?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float?>>> selector)
    {
        return SumAsyncQueryable<TSource, float?>(source, selector);
    }
    public static IAsyncQueryableValue<float> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<float>>> selector)
    {
        return SumAsyncQueryable<TSource, float>(source, selector);
    }
    public static IAsyncQueryableValue<int?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int?>>> selector)
    {
        return SumAsyncQueryable<TSource, int?>(source, selector);
    }
    public static IAsyncQueryableValue<int> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<int>>> selector)
    {
        return SumAsyncQueryable<TSource, int>(source, selector);
    }
    public static IAsyncQueryableValue<long?> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long?>>> selector)
    {
        return SumAsyncQueryable<TSource, long?>(source, selector);
    }
    public static IAsyncQueryableValue<long> Sum<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<long>>> selector)
    {
        return SumAsyncQueryable<TSource, long>(source, selector);
    }
    private static IAsyncQueryableValue<T> SumAsyncQueryable<TSource, T>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<T>>> selector)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(selector);
        return new AsyncQueryableValue<T>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializablePredicateReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "Sum" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.ToString() == string.Format("System.Linq.Expressions.Expression`1[System.Func`2[TSource,{0}]]", typeof(T).ToString())).MakeGenericMethod(typeof(TSource))), source.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Take<TSource>(this IAsyncQueryable<TSource> source, int count)
    {
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, new SerializableConstantExpression(count, typeof(int)) }, typeof(Queryable).GetMethod("Take").MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> ThenBy<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenBy" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> ThenByDescending<TSource, TKey>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
    {
        var serializableKeySelectorReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableKeySelectorReference, source.ParameterMode, source.Context).Visit(keySelector);
        return new AsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, serializableKeySelectorReference.Value }, typeof(Queryable).GetMethods().First(m => m.Name == "ThenByDescending" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource), typeof(TKey))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> Union<TSource>(this IAsyncQueryable<TSource> source1, IAsyncQueryable<TSource> source2)
    {
        return new AsyncQueryable<TSource>(source1.Context, new SerializableMethodCallExpression(null, new[] { source1.Expression, source2.Expression }, typeof(Queryable).GetMethods().First(m => m.Name == "Union" && m.GetParameters().Length == 2).MakeGenericMethod(typeof(TSource))), source1.ParameterMode);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Where(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(this IAsyncQueryable<TSource> source, Expression<Func<TSource, IAsyncQueryableValue<bool>>> predicate)
    {
        var serializablePredicateReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializablePredicateReference, source.ParameterMode, source.Context).Visit(predicate);
        return Where(source, serializablePredicateReference.Value);
    }
        
    public static IAsyncQueryable<TSource> Where<TSource>(IAsyncQueryable<TSource> source, SerializableExpression predicate)
    {
        return CreateAsyncQueryable<TSource>(source.Context, new SerializableMethodCallExpression(null, new[] { source.Expression, predicate }, typeof(Queryable).GetMethods().First(m => m.Name == "Where" && m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2).MakeGenericMethod(typeof(TSource))), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
        
        
    public static Expression<Func<T, bool>> BuildOr<T>(IEnumerable<Expression<Func<T, bool>>> exps)
    {
        if (exps == null || !exps.Any())
            return Expression.Lambda<Func<T, bool>>(Expression.Constant(true, typeof(bool)), Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N")));
        var parameterExpression = Expression.Parameter(typeof(T), "p" + Guid.NewGuid().ToString("N"));
        return Expression.Lambda<Func<T, bool>>(exps.Select(e => e.ReplaceBodyParameter(parameterExpression)).Aggregate((e1, e2) => Expression.OrElse(e1, e2)), parameterExpression);
    }
        
        
        
        
    public static IAsyncQueryable<TSource> Include<TSource, TInclude>(IAsyncQueryable<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
    {
        return CreateAsyncQueryable<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> Include<TSource, TInclude>(IAsyncQueryableValue<TSource> source, params Func<IAsyncQueryableBase, AsyncQueryableInclude>[] includes)
    {
        return CreateAsyncQueryableValue<TSource>(source.Context, source.Expression, source.ParameterMode, source.Includes.Union(includes), source.WithSpecificationsProperties, source.SelectedProperties);
    }
    
    public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneToMany<OneT, OneT, ManyT>(source, manyEntitySet, exp, anyExp, queryTransform, fkTest, getTrackableCollection);
    }
    
    public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<OneT, ManyT, bool>> anyExp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
            {
                var include = new AsyncQueryableInclude();
                var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
                IAsyncQueryableBase subQuery;
                Func<object, object[], MergeOption, object> load;
                if (onesQueryAsAsyncQueryable == null)
                {
                    subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                    load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
                }
                else
                {
                    subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), manyEntitySet, anyExp, ref queryTransform);
                    if (queryTransform == null || queryTransform.Body is ParameterExpression)
                    {
                        string path = ((MemberExpression)exp.Body).Member.Name;
                        include.Path = path;
                    }
                    load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
                }
                include.Queries = new IAsyncQueryableBase[] { subQuery };
                include.Load = load;
                return include;
            });
    }
        
    public static IAsyncQueryable<OneT> IncludeOneToMany<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<OneBaseT> IncludeOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryable<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            var onesQueryAsAsyncQueryable = onesQuery as IAsyncQueryable<OneBaseT>;
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            if (onesQueryAsAsyncQueryable == null)
            {
                subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), queryTransform);
                load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection);
            }
            else
            {
                subQuery = CreateOneToManyQuery(onesQueryAsAsyncQueryable.OfType<OneT>(), exp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (oneValues, manyValues, mergeOption) => IncludeOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            }
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, Expression<ExpressionT> queryTransform)
        where QueryT : IAsyncQueryableBase
    {
        return CreateQuery<QueryT, ExpressionT>(getQuery, ref queryTransform);
    }
        
    private static QueryT CreateQuery<QueryT, ExpressionT>(Func<Expression<ExpressionT>, QueryT> getQuery, ref Expression<ExpressionT> queryTransform)
        where QueryT : IAsyncQueryableBase
    {
        var includeExpressionVisitor = new IncludeExpressionVisitor<QueryT>();
        queryTransform = (Expression<ExpressionT>)includeExpressionVisitor.Visit(queryTransform);
        var value = getQuery(queryTransform);
        foreach (var includeAction in includeExpressionVisitor.IncludeActions)
            value = includeAction(value);
        return value;
    }

    private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, IAsyncQueryable<ManyT> manyEntitySet, Expression<Func<OneT, ManyT, bool>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
    {
        var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
        var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
        var serializableExpReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
        var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
        var serializableExp = Where(manyEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
        {
            switch (anyLambda.Parameters.IndexOf(spe))
            {
                case 0:
                    return oParameter;
                case 1:
                    return mParameter;
                default:
                    throw new InvalidOperationException();
            }
        })), ExpressionType.Quote, typeof(Expression<Func<OneT, bool>>))).Expression));
        return CreateQuery(qt => AddTransformExp<ManyT>(source, (LambdaExpression)qt, serializableExp.Expression), queryTransform);
    }

    private static IAsyncQueryable<T> AddTransformExp<T>(IAsyncQueryable source, LambdaExpression qt, SerializableExpression serializableExp)
    {
        MethodCallExpression qtMethodCall;
        if (qt != null && (qtMethodCall = qt.Body as MethodCallExpression) != null)
        {
            var serializableReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(serializableReference, source.ParameterMode, new Dictionary<ParameterExpression, SerializableParameterExpression>(), source.Context, p => p == qt.Parameters[0] ? serializableExp : null) { UseQueryable = true }.Visit(qtMethodCall);
            var serializableMethodCallExpression = (SerializableMethodCallExpression)serializableReference.Value;
            serializableExp = serializableMethodCallExpression;
        }
        return CreateAsyncQueryable<T>(source.Context, serializableExp, source.ParameterMode);
    }

    private static IAsyncQueryable<ManyT> CreateOneToManyQuery<OneT, ManyT>(IAsyncQueryable<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
    {
        return CreateQuery(qt => CreateAsyncQueryable<ManyT>(source.Context, source.RemoveSelectFromSource().Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
    }
        
    private static IAsyncQueryableValue<ToTResult> CreateOneToOne<FromBaseT, FromT, ToT, ToTResult>(IAsyncQueryableValue<FromBaseT> source, Expression<Func<FromT, ToT>> exp, Func<IAsyncQueryable<ToT>, IAsyncQueryable<ToTResult>> queryTransform)
        where FromT : FromBaseT
    {
        var sourceValue = source.RemoveSelectFromSource();
        var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
        MethodInfo method;
        var baseQuery = CreateToOne<FromBaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<FromT>();
        return CreateAsyncQueryableValue<ToTResult>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { queryTransform(baseQuery.Select(exp)).Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(ToTResult))), source.ParameterMode);
    }
        
    private static SerializableExpression AddOfType<BaseT, T>(IAsyncQueryableValue<BaseT> source)
        where T : BaseT
    {
        if (typeof(BaseT) == typeof(T))
            return source.Expression;
        var sourceValue = source.RemoveSelectFromSource();
        var serializableMethodCallExpression = (SerializableMethodCallExpression)sourceValue.Expression;
        MethodInfo method;
        var baseQuery = CreateToOne<BaseT>(sourceValue, serializableMethodCallExpression, out method).OfType<T>();
        return new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { baseQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)));
    }
        
    private static IAsyncQueryable<FromT> CreateToOne<FromT>(IAsyncQueryableBase source, SerializableMethodCallExpression serializableMethodCallExpression, out MethodInfo method)
    {
        switch (serializableMethodCallExpression.MemberName)
        {
            case "First":
            case "FirstOrDefault":
            case "Single":
            case "SingleOrDefault":
            case "Last":
            case "LastOrDefault":
                var baseQuery = CreateAsyncQueryable<FromT>(source.Context, serializableMethodCallExpression.Parameters[0], source.ParameterMode);
                switch (serializableMethodCallExpression.Parameters.Count)
                {
                    case 1:
                        method = serializableMethodCallExpression.Method;
                        break;
                    case 2:
                        method = serializableMethodCallExpression.Method.DeclaringType.GetMethods().First(m => m.Name == serializableMethodCallExpression.Method.Name && m.GetParameters().Length == 1);
                        baseQuery = AsyncQueryableExtensions.Where(baseQuery, serializableMethodCallExpression.Parameters[1]);
                        break;
                    default:
                        throw new NotImplementedException();
                }
                return baseQuery.RemoveSelectFromSource();
            default:
                throw new NotImplementedException();
        }
    }
        
    private static IEnumerable<ManyT> IncludeOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        if (mergeOption == MergeOption.NoTracking)
        {
            var ones = ((IEnumerable<object>)oneValues).Cast<OneT>();
            foreach (var one in ones)
                foreach (var manyEntity in many.Where(m => fkTest(one, m)))
                    getTrackableCollection(one).Attach(manyEntity);
        }
        return many;
    }
        
    public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    public static IAsyncQueryableValue<OneT> IncludeOneOneToMany<OneT, ManyT>(IAsyncQueryableValue<OneT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<OneBaseT> IncludeOneOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<OneBaseT> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<OneBaseT, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<OneBaseT>)onesQuery, exp, q => q.Select(qt)), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeOneOneToMany(oneValues, manyValues, mergeOption, getTrackableCollection, manyToMany);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static object IncludeOneOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var one = (OneT)oneValues;
        if (one == null)
            return null;
        var many = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        if (mergeOption == MergeOption.NoTracking || manyToMany)
            foreach (var manyElt in many)
                getTrackableCollection(one).Attach(manyElt);
        return many;
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyOneToMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateManyOneToMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeManyOneToMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, IEnumerable<ManyT>>> queryTransform)
        where OneT : OneBaseT
    {
        return CreateQuery(qt =>
        {
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
            if (qt != null)
                exp = Expression.Lambda<Func<OneT, IEnumerable<ManyT>>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "SelectMany" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, exp), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var value = ((IEnumerable<object>)manyValues[0]).Cast<ManyT>();
        if (mergeOption == MergeOption.NoTracking)
        {
            object oneValue = ((IEnumerable<object>)oneValues).Cast<OneT>();
            var ones = ((IEnumerable<object>)oneValue).Cast<OneT>();
            foreach (var one in ones)
                foreach (var manyEntity in value.Where(m => fkTest(one, m)))
                    getTrackableCollection(one).Attach(manyEntity);
        }
        return value;
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneT>> IncludeManyOneToOneMany<OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyOneToOneMany<OneT, OneT, ManyT>(source, exp, queryTransform, fkTest, getTrackableCollection, manyToMany);
    }
        
    public static IAsyncQueryableValue<IEnumerable<OneBaseT>> IncludeManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection, bool manyToMany = false)
        where OneT : OneBaseT
        where OneBaseT : IEntity
        where ManyT : IEntity
    {
        return Include<IEnumerable<OneBaseT>, ManyT>(source, onesQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateManyOneToOneMany((IAsyncQueryableValue<IEnumerable<OneBaseT>>)source, exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (oneValues, manyValues, mergeOption) => IncludeManyOneToOneMany(oneValues, manyValues, mergeOption, fkTest, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ManyT>> CreateManyOneToOneMany<OneBaseT, OneT, ManyT>(IAsyncQueryableValue<IEnumerable<OneBaseT>> source, Expression<Func<OneT, IEnumerable<ManyT>>> exp, ref Expression<Func<IEnumerable<ManyT>, ManyT>> queryTransform)
        where OneT : OneBaseT
    {
        return CreateQuery(qt =>
        {
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<OneBaseT>>(source, serializableMethodCallExpression, out method).Select(os => os.OfType<OneT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<OneT>), "e" + Guid.NewGuid().ToString("N"));
            var expOne = Expression.Lambda<Func<OneT, ManyT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<OneT>, IEnumerable<ManyT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(OneT), typeof(ManyT)), selectParameter, expOne), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ManyT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ManyT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToOneMany<OneT, ManyT>(object oneValues, object[] manyValues, MergeOption mergeOption, Func<OneT, ManyT, bool> fkTest, Func<OneT, IEntityCollection<ManyT>> getTrackableCollection)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var many = ((IEnumerable<object>)manyValues).Cast<ManyT>();
        if (mergeOption == MergeOption.NoTracking)
        {
            var ones = ((IEnumerable<object>)oneValues).Cast<OneT>();
            foreach (var one in ones)
                foreach (var manyEntity in many.Where(m => fkTest(one, m)))
                    getTrackableCollection(one).Attach(manyEntity);
        }
        return many;
    }
        
    public static IAsyncQueryable<ManyT> IncludeManyToOne<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeManyToOne<ManyT, ManyT, OneT>(source, onesEntitySet, exp, anyExp, queryTransform, fkTest, setOne);
    }
        
    public static IAsyncQueryable<ManyBaseT> IncludeManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryable<ManyBaseT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT>> exp, Expression<Func<ManyT, OneT, bool>> anyExp, Expression<Func<OneT, OneT>> queryTransform, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where ManyBaseT : IEntity
        where ManyT : ManyBaseT
        where OneT : IEntity
    {
        return Include<ManyBaseT, OneT>(source, manyQuery =>
        {
            var include = new AsyncQueryableInclude();
            var manyQueryAsAsyncQueryable = manyQuery as IAsyncQueryable<ManyBaseT>;
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            if (manyQueryAsAsyncQueryable == null)
            {
                subQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<ManyBaseT>)manyQuery), exp, q => q), queryTransform);
                load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
            }
            else
            {
                subQuery = CreateManyToOneQuery(manyQueryAsAsyncQueryable.OfType<ManyT>(), onesEntitySet, anyExp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                load = (manyValues, oneValues, mergeOption) => IncludeManyToOne(manyValues, oneValues, mergeOption, fkTest, setOne);
            }
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryable<OneT> CreateManyToOneQuery<ManyT, OneT>(IAsyncQueryable<ManyT> source, IAsyncQueryable<OneT> onesEntitySet, Expression<Func<ManyT, OneT, bool>> exp, ref Expression<Func<OneT, OneT>> queryTransform)
    {
        var oParameter = new SerializableParameterExpression { Name = "o" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(OneT)) };
        var mParameter = new SerializableParameterExpression { Name = "m" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ManyT)) };
        var serializableExpReference = new Reference<SerializableExpression>();
        new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(exp);
        var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
        var serializableExp = Where(onesEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { oParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { mParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
            {
                switch (anyLambda.Parameters.IndexOf(spe))
                {
                    case 0:
                        return mParameter;
                    case 1:
                        return oParameter;
                    default:
                        throw new InvalidOperationException();
                }
            })), ExpressionType.Quote, typeof(Expression<Func<ManyT, bool>>))).Expression));
        return CreateQuery(qt => AddTransformExp<OneT>(source, (LambdaExpression)qt, serializableExp.Expression), queryTransform);
    }
        
    private static object IncludeManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Func<ManyT, OneT, bool> fkTest, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        var ones = ((IEnumerable<object>)oneValues[0]).Cast<OneT>();
        if (mergeOption == MergeOption.NoTracking)
        {
            var many = ((IEnumerable<object>)manyValues).Cast<ManyT>();
            foreach (var manyElt in many)
            {
                var one = ones.Where(e => e != null).FirstOrDefault(e => fkTest(manyElt, e));
                if (one != null)
                {
                    manyElt.IsInitializingRelationships = true;
                    setOne(manyElt, one);
                    manyElt.IsInitializingRelationships = false;
                }
            }
        }
        return ones;
    }
        
    private static object IncludeOneManyToOne<ManyT, OneT>(object manyValues, object[] oneValues, MergeOption mergeOption, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        OneT one = (OneT)oneValues[0];
        if (mergeOption == MergeOption.NoTracking)
        {
            if (manyValues == null)
                return null;
            ManyT many = (ManyT)manyValues;
            if (one != null)
            {
                many.IsInitializingRelationships = true;
                setOne(many, one);
                many.IsInitializingRelationships = false;
            }
        }
        return one;
    }
        
    public static IAsyncQueryableValue<ManyT> IncludeOneManyToOne<ManyT, OneT>(IAsyncQueryableValue<ManyT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : IEntity
    {
        return IncludeOneManyToOne<ManyT, ManyT, OneT>(source, exp, queryTransform, setOne);
    }
        
    public static IAsyncQueryableValue<ManyBaseT> IncludeOneManyToOne<ManyBaseT, ManyT, OneT>(IAsyncQueryableValue<ManyBaseT> source, Expression<Func<ManyT, OneT>> exp, Expression<Func<OneT, OneT>> queryTransform, Action<ManyT, OneT> setOne)
        where OneT : IEntity
        where ManyT : ManyBaseT
        where ManyBaseT : IEntity
    {
        return Include<ManyBaseT, OneT>(source, manyQuery =>
        {
            var include = new AsyncQueryableInclude();
            IAsyncQueryableBase subQuery;
            Func<object, object[], MergeOption, object> load;
            subQuery = CreateQuery(qt => CreateOneToOne((IAsyncQueryableValue<ManyBaseT>)manyQuery, exp, q => q), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            load = (manyValues, oneValues, mergeOption) => IncludeOneManyToOne(manyValues, oneValues, mergeOption, setOne);
            include.Queries = new IAsyncQueryableBase[] { subQuery };
            include.Load = load;
            return include;
        });
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : IEntity
        where ToT : IEntity
    {
        return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toEntitySet, exp, getCollectionExp, anyExp, queryTransform, getKeysQuery, fromFkTest, toFkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform, Func<IAsyncQueryable<FromT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : IEntity
    {
        return Include<FromBaseT, ToT>(source, fromQuery =>
            {
                var include = new AsyncQueryableInclude();
                var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
                IAsyncQueryableBase toQuery;
                Func<object, object[], MergeOption, object> load;
                if (fromBaseQueryAsAsyncQueryable == null)
                {
                    toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => qt == null ? q.Select(e => e.Select(e2 => e2)) : q.Select(qt).Select(e => e.Select(e2 => e2))), queryTransform);
                    load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                    return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
                }
                var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
                toQuery = CreateManyToManyQuery(fromQueryAsAsyncQueryable, toEntitySet, exp, getCollectionExp, anyExp, ref queryTransform);
                if (queryTransform == null || queryTransform.Body is ParameterExpression)
                {
                    string path = ((MemberExpression)exp.Body).Member.Name;
                    include.Path = path;
                }
                var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable);
                if (queryTransform != null)
                {
                    var selectManyCollectionSelectorExpression = (SerializableLambdaExpression)((SerializableMethodCallExpression)keysQuery.Expression).Parameters[1];
                    var serializableCollectionSelectorReferenceTransform = new Reference<SerializableExpression>();
                    new SerializableExpressionBuilder(serializableCollectionSelectorReferenceTransform, source.ParameterMode, source.Context).Visit(queryTransform);
                    var queryTransformLambda = (SerializableLambdaExpression)serializableCollectionSelectorReferenceTransform.Value;
                    selectManyCollectionSelectorExpression.Body = queryTransformLambda.ReplaceBodyParameter(selectManyCollectionSelectorExpression.Body);
                }
                load = (fromValues, toValues, mergeOption) => IncludeManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                include.Queries = new IAsyncQueryableBase[] { toQuery, keysQuery.RemoveSelectFromSource() };
                include.Load = load;
                return include;
            });
    }
        
    private static IAsyncQueryable<ToT> CreateManyToManyQuery<FromT, ToT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toEntitySet, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<FromT, TrackableCollectionBase<ToT>>> getCollectionExp, Expression<Func<TrackableCollectionBase<ToT>, ToT, bool>> anyExp, ref Expression<Func<IEnumerable<ToT>, IEnumerable<ToT>>> queryTransform)
        where FromT : IEntity
        where ToT : IEntity
    {
        return CreateQuery(qt =>
            {
                var toParameter = new SerializableParameterExpression { Name = "t" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(ToT)) };
                IAsyncQueryable<ToT> toQuery;
                if (qt == null)
                {
                    var fromParameter = new SerializableParameterExpression { Name = "f" + Guid.NewGuid().ToString("N"), Type = new SerializableType(typeof(FromT)) };
                    var serializableExpReference = new Reference<SerializableExpression>();
                    new SerializableExpressionBuilder(serializableExpReference, source.ParameterMode, source.Context).Visit(anyExp);
                    var anyLambda = (SerializableLambdaExpression)serializableExpReference.Value;
                    toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Any(source, new SerializableUnaryExpression(new SerializableLambdaExpression(new List<SerializableParameterExpression>() { fromParameter }, new SerializableType(typeof(bool)), anyLambda.Body.ReplaceParameter(spe =>
                    {
                        switch (anyLambda.Parameters.IndexOf(spe))
                        {
                            case 0:
                                var serializablegetCollectionExpReference = new Reference<SerializableExpression>();
                                new SerializableExpressionBuilder(serializablegetCollectionExpReference, source.ParameterMode, source.Context).Visit(getCollectionExp);
                                var getSerializableCollectionExp = (SerializableLambdaExpression)serializablegetCollectionExpReference.Value;
                                return getSerializableCollectionExp.ReplaceBodyParameter(fromParameter);
                            case 1:
                                return toParameter;
                            default:
                                throw new InvalidOperationException();
                        }
                    })), ExpressionType.Quote, typeof(Expression<Func<ToT, bool>>))).Expression));
                }
                else
                    toQuery = Where(toEntitySet, new SerializableLambdaExpression(new List<SerializableParameterExpression>() { toParameter }, new SerializableType(typeof(bool)), Contains<ToT>(source.Select(exp).Select(qt).SelectMany(e => e).Expression, toParameter)));
                return CreateAsyncQueryable<ToT>(source.Context, toQuery.Expression, source.ParameterMode);
            }, ref queryTransform);
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : IEntity
        where ToT : class, IEntity
    {
        return IncludeManyToOneMany<FromT, FromT, ToT, KeysT>(source, exp, queryTransform, getKeysQuery, getTo, getFromKey, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToOneMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, Expression<Func<FromT, IEnumerable<ToT>>> exp, Expression<Func<IEnumerable<ToT>, ToT>> queryTransform, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : class, IEntity
    {
        return Include<FromBaseT, ToT>(source, fromQuery =>
        {
            var include = new AsyncQueryableInclude();
            var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
            IAsyncQueryableBase toQuery;
            Func<object, object[], MergeOption, object> load;
            if (fromBaseQueryAsAsyncQueryable == null)
            {
                toQuery = CreateQuery(qt => CreateOneToOne(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), exp, q => q.Select(qt)), queryTransform);
                load = (fromValues, toValues, mergeOption) => IncludeOneOneToMany(fromValues, toValues, mergeOption, getTrackableCollection, true);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
            }
            var fromQueryAsAsyncQueryable = fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>();
            toQuery = CreateQuery(qt => CreateAsyncQueryable<ToT>(source.Context, fromQueryAsAsyncQueryable.Select(exp).Select(qt).Expression, source.ParameterMode), ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            ToT toT = null;
            var keysQuery = getKeysQuery(fromQueryAsAsyncQueryable, toT);
            var select = (SerializableMethodCallExpression)keysQuery.Expression;
            var selectLambda = (SerializableLambdaExpression)select.Parameters[1];
            var keysCtor = (SerializableConstructorExpression)((SerializableLambdaExpression)select.Parameters[1]).Body;
            var keysCtorToArg = keysCtor.Arguments.Last();
            var expSerializableExpressionReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(expSerializableExpressionReference, source.ParameterMode, source.Context).Visit(exp);
            var expLambda = (SerializableLambdaExpression)expSerializableExpressionReference.Value;
            var queryTransformSerializableExpressionReference = new Reference<SerializableExpression>();
            new SerializableExpressionBuilder(queryTransformSerializableExpressionReference, source.ParameterMode, source.Context).Visit(queryTransform);
            var queryTransformLambdaSerializableExpression = (SerializableLambdaExpression)queryTransformSerializableExpressionReference.Value;
            keysCtorToArg = queryTransformLambdaSerializableExpression.ReplaceBodyParameter(expLambda.ReplaceBodyParameter(selectLambda.Parameters[0]));
            keysCtor.Arguments[keysCtor.Arguments.Count - 1] = keysCtorToArg;
        
            keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQuery.Expression, keysQuery.ParameterMode, toQuery.Includes);
        
            load = (fromValues, toValues, mergeOption) => IncludeManyToOneMany<FromT, ToT, KeysT>(fromValues, toValues, getTo, getFromKey, getTrackableCollection);
            include.Queries = new IAsyncQueryableBase[] { keysQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static object IncludeManyToOneMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, ToT> getTo, Func<KeysT, FromT, bool> getFromKey, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var keys = ((IEnumerable<object>)toValues[0]).Cast<KeysT>().ToList();
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var tos = new List<ToT>();
        foreach (var key in keys)
        {
            var to = getTo(key);
            if (to != null)
            {
                getTrackableCollection(froms.FirstOrDefault(f => getFromKey(key, f))).Attach(getTo(key));
                tos.Add(to);
            }
        }
        return tos;
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : IEntity
    {
        return IncludeManyToMany<FromT, FromT, ToT, KeysT>(source, toQuery, getKeysQuery, getKeysQueryForOne, fromFkTest, toFkTest, getTrackableCollection);
    }
        
    public static IAsyncQueryable<FromBaseT> IncludeManyToMany<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryable<FromBaseT> source, IAsyncQueryable<ToT> toQuery, Func<IAsyncQueryable<FromT>, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQueryForOne, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, FromBaseT
        where FromBaseT : class, IEntity
        where ToT : IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromBaseT, ToT>(source, fromQuery =>
        {
            var fromBaseQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromBaseT>;
            Func<object, object[], MergeOption, object> load;
            IAsyncQueryable<KeysT> keysQuery;
            if (fromBaseQueryAsAsyncQueryable == null)
            {
                keysQuery = CreateOneManyToManyKeysQuery(((IAsyncQueryableValue<FromBaseT>)fromQuery).RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQueryForOne);
                load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            }
            keysQuery = getKeysQuery(fromBaseQueryAsAsyncQueryable.RemoveSelectFromSource().OfType<FromT>(), toQuery.RemoveSelectFromSource());
            load = (fromValues, toValues, mergeOption) => IncludeManyToMany<FromT, ToT, KeysT>(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
            return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
        });
    }
        
    public static IAsyncQueryable<FromT> IncludeManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryable<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
        {
            Func<object, object[], MergeOption, object> load;
            IAsyncQueryableBase keysQuery;
            var fromQueryAsAsyncQueryable = fromQuery as IAsyncQueryable<FromT>;
            if (fromQueryAsAsyncQueryable == null)
            {
                keysQuery = CreateOneManyToOneManyKeysQuery(((IAsyncQueryableValue<FromT>)fromQuery).RemoveSelectFromSource(), toQuery, getKeysQuery);
                load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery }, Load = load };
            }
            keysQuery = CreateManyToOneManyKeysQuery(fromQueryAsAsyncQueryable.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
            load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
            return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
        });
    }
        
    public static IAsyncQueryableValue<FromT> IncludeOneManyToMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToMany(fromValues, toValues, fromFkTest, toFkTest, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
    }
        
    public static IAsyncQueryableValue<FromT> IncludeOneManyToOneMany<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> source, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        if (source.Context != toQuery.Context)
            throw new InvalidOperationException();
        return Include<FromT, ToT>(source, fromQuery =>
            {
                var keysQuery = CreateOneManyToOneManyKeysQuery(source.RemoveSelectFromSource(), toQuery.RemoveSelectFromSource(), getKeysQuery);
                Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeOneManyToOneMany(fromValues, toValues, getTrackableCollection);
                return new AsyncQueryableInclude { Queries = new IAsyncQueryableBase[] { toQuery, keysQuery }, Load = load };
            });
    }
        
    private static IAsyncQueryable<KeysT> CreateOneManyToManyKeysQuery<FromBaseT, FromT, ToT, KeysT>(IAsyncQueryableValue<FromBaseT> fromQuery, IAsyncQueryable<ToT> toQuery, Func<FromT, IAsyncQueryable<ToT>, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : class, FromBaseT
        where FromBaseT : class, IEntity
        where ToT : IEntity
    {
        FromT fromT = null;
        var keysQuery = getKeysQuery(fromT, toQuery);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == fromT)
                return new RemoveSelect().Visit(AddOfType<FromBaseT, FromT>(fromQuery));
            return constant;
        });
        return CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
    }
        
    private static IAsyncQueryable<KeysT> CreateManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryable<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : IEntity
        where ToT : class, IEntity
    {
        ToT toT = null;
        var keysQuery = getKeysQuery(fromQuery.RemoveSelectFromSource(), toT);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == toT)
                return toQuery.Expression;
            return constant;
        });
        keysQuery = CreateAsyncQueryable<KeysT>(keysQuery.Context, keysQueryExpression, keysQuery.ParameterMode);
        return keysQuery;
    }
        
    private static IAsyncQueryableValue<KeysT> CreateOneManyToOneManyKeysQuery<FromT, ToT, KeysT>(IAsyncQueryableValue<FromT> fromQuery, IAsyncQueryableValue<ToT> toQuery, Func<IAsyncQueryable<FromT>, ToT, IAsyncQueryable<KeysT>> getKeysQuery)
        where FromT : class, IEntity
        where ToT : class, IEntity
    {
        fromQuery = fromQuery.RemoveSelectFromSource();
        MethodInfo method;
        var fromQueryAsAsyncQueryable = CreateToOne<FromT>(fromQuery, (SerializableMethodCallExpression)fromQuery.Expression, out method);
        ToT toT = null;
        var keysQuery = getKeysQuery(CreateAsyncQueryable<FromT>(fromQuery.Context, fromQueryAsAsyncQueryable.Expression, fromQuery.ParameterMode), toT);
        var keysQueryExpression = keysQuery.Expression.ReplaceConstant(constant =>
        {
            if (constant.Value == toT)
                return toQuery.Expression;
            return constant;
        });
        return CreateAsyncQueryableValue<KeysT>(keysQuery.Context, new SerializableMethodCallExpression(null, new[] { keysQueryExpression }, method.MakeGenericMethod(typeof(KeysT))), keysQuery.ParameterMode);
    }
        
    private static object IncludeManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            FromT fromValue = froms.FirstOrDefault(f => fromFkTest(key, f));
            ToT toValue;
            if (fromValue != null && (toValue = tos.FirstOrDefault(t => toFkTest(key, t))) != null)
                getTrackableCollection(fromValue).Attach(toValue);
        }
        return tos;
    }
        
    private static object IncludeManyToOneManyTask<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>().ToList();
        var to = (ToT)toValues[0];
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            var @from = froms.FirstOrDefault(f => fromFkTest(key, f));
            if (@from != null && toFkTest(key, to))
                getTrackableCollection(@from).Attach(to);
        }
        return to;
    }
        
    private static object IncludeOneManyToMany<FromT, ToT, KeysT>(object fromValues, object[] toValues, Func<KeysT, FromT, bool> fromFkTest, Func<KeysT, ToT, bool> toFkTest, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var @from = (FromT)fromValues;
        var tos = ((IEnumerable<object>)toValues[0]).Cast<ToT>().ToList();
        var keys = ((IEnumerable<object>)toValues[1]).Cast<KeysT>();
        foreach (var key in keys)
        {
            var toValue = tos.FirstOrDefault(t => toFkTest(key, t));
            if (toValue != null && fromFkTest(key, @from))
                getTrackableCollection(@from).Attach(toValue);
        }
        return tos;
    }
        
    private static object IncludeOneManyToOneMany<FromT, ToT>(object fromValues, object[] toValues, Func<FromT, IEntityCollection<ToT>> getTrackableCollection)
    {
        var fromValue = (FromT)fromValues;
        var toValue = (ToT)toValues[0];
        getTrackableCollection(fromValue).Attach(toValue);
        return toValue;
    }
        
    public static IAsyncQueryableValue<IEnumerable<FromT>> IncludeManyOneToOne<FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : IEntity
        where ToT : IEntity
    {
        return IncludeManyOneToOne<FromT, FromT, ToT>(source, exp, queryTransform, fkTest, setTo);
    }
        
    public static IAsyncQueryableValue<IEnumerable<FromBaseT>> IncludeManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, Expression<Func<ToT, ToT>> queryTransform, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : FromBaseT
        where FromBaseT : IEntity
        where ToT : IEntity
    {
        return Include<IEnumerable<FromBaseT>, ToT>(source, fromQuery =>
        {
            var include = new AsyncQueryableInclude();
            var toQuery = CreateManyOneToOne(((IAsyncQueryableValue<IEnumerable<FromBaseT>>)source).RemoveSelectFromSource(), exp, ref queryTransform);
            if (queryTransform == null || queryTransform.Body is ParameterExpression)
            {
                string path = ((MemberExpression)exp.Body).Member.Name;
                include.Path = path;
            }
            Func<object, object[], MergeOption, object> load = (fromValues, toValues, mergeOption) => IncludeManyOneToOne(fromValues, toValues, mergeOption, fkTest, setTo);
            include.Queries = new IAsyncQueryableBase[] { toQuery };
            include.Load = load;
            return include;
        });
    }
        
    private static IAsyncQueryableValue<IEnumerable<ToT>> CreateManyOneToOne<FromBaseT, FromT, ToT>(IAsyncQueryableValue<IEnumerable<FromBaseT>> source, Expression<Func<FromT, ToT>> exp, ref Expression<Func<ToT, ToT>> queryTransform)
        where FromT : FromBaseT
    {
        source = source.RemoveSelectFromSource();
        return CreateQuery(qt =>
        {
            if (qt == null)
                qt = e => e;
            var serializableMethodCallExpression = (SerializableMethodCallExpression)source.Expression;
            MethodInfo method;
            var baseQuery = CreateToOne<IEnumerable<FromBaseT>>(source, serializableMethodCallExpression, out method).Select(fs => fs.OfType<FromT>());
            var selectParameter = Expression.Parameter(typeof(IEnumerable<FromT>), "e" + Guid.NewGuid().ToString("N"));
            var expTo = Expression.Lambda<Func<FromT, ToT>>(qt.ReplaceBodyParameter(exp.Body), exp.Parameters[0]);
            var manyQuery = baseQuery.Select(Expression.Lambda<Func<IEnumerable<FromT>, IEnumerable<ToT>>>(Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Distinct" && m.GetParameters().Length == 1).MakeGenericMethod(typeof(ToT)), Expression.Call(typeof(Enumerable).GetMethods().First(m => m.Name == "Select" && m.GetParameters().Length == 2 && m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2).MakeGenericMethod(typeof(FromT), typeof(ToT)), selectParameter, expTo)), selectParameter));
            return CreateAsyncQueryableValue<IEnumerable<ToT>>(source.Context, new SerializableMethodCallExpression(serializableMethodCallExpression.Source, new[] { manyQuery.Expression }, method.GetGenericMethodDefinition().MakeGenericMethod(typeof(IEnumerable<ToT>))), source.ParameterMode);
        }, ref queryTransform);
    }
        
    private static object IncludeManyOneToOne<FromT, ToT>(object fromValues, object[] toValues, MergeOption mergeOption, Func<FromT, ToT, bool> fkTest, Action<FromT, ToT> setTo)
        where FromT : IEntity
        where ToT : IEntity
    {
        var tos = ((IEnumerable<object>)toValues).Cast<ToT>();
        var froms = ((IEnumerable<object>)fromValues).Cast<FromT>();
        if (mergeOption == MergeOption.NoTracking)
        {
            foreach (var from in froms)
                foreach (var to in tos.Where(m => fkTest(from, m)))
                {
                    if (to != null)
                    {
                        to.IsInitializingRelationships = true;
                        setTo(from, to);
                        to.IsInitializingRelationships = false;
                    }
                }
        }
        return tos;
    }
        
    private static IAsyncQueryable<T> RemoveSelectFromSource<T>(this IAsyncQueryable<T> source)
    {
        if (source == null)
            return null;
        return CreateAsyncQueryable<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    private static IAsyncQueryableValue<T> RemoveSelectFromSource<T>(this IAsyncQueryableValue<T> source)
    {
        if (source == null)
            return null;
        return CreateAsyncQueryableValue<T>(source.Context, new RemoveSelect().Visit(source.Expression), source.ParameterMode, source.Includes, source.WithSpecificationsProperties, source.SelectedProperties);
    }
        
    public static IAsyncQueryable<TSource> CreateAsyncQueryable<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
    {
        return new AsyncQueryable<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
    }
        
    public static IAsyncQueryableValue<TSource> CreateAsyncQueryableValue<TSource>(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
    {
        return new AsyncQueryableValue<TSource>(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties);
    }
        
    public static IAsyncQueryable<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryable<QueryT> query)
    {
        return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<OldT> query)
    {
        return ReplaceType<OldT, NewT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryable<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryable<NewT> query)
    {
        return ReplaceType<NewT, NewT, OldT, NewT>(query);
    }
        
    private static IAsyncQueryable<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryable<OldQueryT> query)
    {
        return CreateAsyncQueryable<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
    }
        
    public static IAsyncQueryableValue<QueryT> ReplaceType<QueryT, OldT, NewT>(this IAsyncQueryableValue<QueryT> query)
    {
        return ReplaceType<QueryT, QueryT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<OldT> query)
    {
        return ReplaceType<OldT, NewT, OldT, NewT>(query);
    }
        
    public static IAsyncQueryableValue<NewT> ReplaceType<OldT, NewT>(this IAsyncQueryableValue<NewT> query)
    {
        return ReplaceType<NewT, NewT, OldT, NewT>(query);
    }
        
    private static IAsyncQueryableValue<NewQueryT> ReplaceType<OldQueryT, NewQueryT, OldT, NewT>(IAsyncQueryableValue<OldQueryT> query)
    {
        return CreateAsyncQueryableValue<NewQueryT>(query.Context, new ReplaceTypeRewriter<OldT, NewT>().Visit(query.Expression), query.ParameterMode, query.Includes, query.WithSpecificationsProperties, query.SelectedProperties);
    }
        
    public static T AsObject<T>(this IAsyncQueryableValue<T> asyncQueryableValue)
    {
        throw new InvalidOperationException("This method could only be used inside a LINQ To WAQS expression");
    }
        
    private class RemoveSelect : SerializableExpressionRewriter
    {
        protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
        {
            if (expression.MemberName == "Select" && expression.GenericArguments.Count == 2 && expression.GenericArguments[0].Type == expression.GenericArguments[1].Type && new[] { typeof(Queryable), typeof(Enumerable) }.Contains(expression.Method.DeclaringType))
            {
                var lambda = (SerializableLambdaExpression)expression.Parameters[1];
                var serializableMemberInit = lambda.Body as SerializableMemberInitExpression;
                if (serializableMemberInit != null && serializableMemberInit.Setters.All(s =>
                    {
                        var propGet = s.Value as SerializablePropertyGetterExpression;
                        return propGet != null && propGet.Source == lambda.Parameters[0] && propGet.MemberName == s.MemberName;
                    }))
                    return expression.Parameters[0];
            }
            return base.VisitMethodCall(expression);
        }
    }
}
<#+
WriteFooter(expressionNamespace);

fileManager.StartNewFile("AsyncQueryableBase.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
internal abstract class AsyncQueryableBase : IAsyncQueryableBase
{
    public AsyncQueryableBase(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes, IEnumerable<string> withSpecificationsProperties, IEnumerable<string> selectedProperties)
    {
        Context = context;
        Expression = expression;
        ParameterMode = parameterMode;
        Includes = includes ?? Enumerable.Empty<Func<IAsyncQueryableBase, AsyncQueryableInclude>>();
        WithSpecificationsProperties = withSpecificationsProperties ?? Enumerable.Empty<string>();
        SelectedProperties = selectedProperties ?? Enumerable.Empty<string>();
    }
    
    public IClientContextBase Context { get; private set; }
    public SerializableExpression Expression { get; private set; }
    public ParameterMode ParameterMode { get; private set; }
    public abstract Type Type { get; }
    public IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> Includes { get; private set; }
    public IEnumerable<string> WithSpecificationsProperties { get; private set; }
    public IEnumerable<string> SelectedProperties { get; private set; }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("AsyncQueryable.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace, clientFxClientContextInterfacesNamespace + ".Querying");
#>
internal class AsyncQueryable<T> : AsyncQueryableBase, IAsyncQueryable<T>
{
    public AsyncQueryable(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        : base(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties)
    {
    }

    public async Task<IEnumerable<T>> Execute<#=asyncSuffix#>(MergeOption? mergeOption = null, Func<bool> cancel = null)
    {
        return await Context.ExecuteQuery<#=asyncSuffix#><T>(this, mergeOption, cancel);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, null, identifiers, null);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, Func<bool> cancel, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, null, identifiers, cancel);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, mergeOption, identifiers, null);
    }

    public async Task<QueryPage<T>> LoadPage<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, Func<bool> cancel, params LoadPageParameter[] identifiers)
    {
        return await LoadPageInternal<#=asyncSuffix#>(pageSize, mergeOption, identifiers, cancel);
    }

    private async Task<QueryPage<T>> LoadPageInternal<#=asyncSuffix#>(int pageSize, MergeOption? mergeOption, LoadPageParameter[] identifiers, Func<bool> cancel)
    {
        return await Context.LoadPage<#=asyncSuffix#><T>(pageSize, this, identifiers, mergeOption, cancel);
    }

    public async Task<IEnumerable<T>> LoadPage<#=asyncSuffix#>(int pageSize, int pageIndex, MergeOption? mergeOption, Func<bool> cancel = null)
    {
        return await Context.LoadPage<#=asyncSuffix#>(pageSize, this.Skip(pageIndex * pageSize).Take(pageSize), null, mergeOption, cancel);
    }

    public override Type Type
    {
        get { return typeof(T); }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("AsyncQueryableValue.cs");
WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Threading.Tasks", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
internal class AsyncQueryableValue<T> : AsyncQueryableBase, IAsyncQueryableValue<T>
{
    public AsyncQueryableValue(IClientContextBase context, SerializableExpression expression, ParameterMode parameterMode, IEnumerable<Func<IAsyncQueryableBase, AsyncQueryableInclude>> includes = null, IEnumerable<string> withSpecificationsProperties = null, IEnumerable<string> selectedProperties = null)
        : base(context, expression, parameterMode, includes, withSpecificationsProperties, selectedProperties)
    {
    }

    public async Task<T> Execute<#=asyncSuffix#>(MergeOption? mergeOption = null, Func<bool> cancel = null)
    {
        return await Context.ExecuteQuery<#=asyncSuffix#><T>(this, mergeOption, cancel);
    }

    public override Type Type
    {
        get { return typeof(T); }
    }
}
<#+
WriteFooter(namespaceName);

fileManager.StartNewFile("RefreshMode.cs");
WriteHeader(namespaceName, code);
#>
public enum RefreshMode
{
    Client,
    Server
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ClientEntitySetExtensions.cs");
    var usings = new List<string>() { "System", "System.Collections.Generic", "System.Linq", clientFxEntitiesTrackingNamespace, expressionNamespace, clientFxClientContextInterfacesNamespace };
    AddClientEntitySetExtensionsUsings(usings);
    WriteHeader(namespaceName, code, usings.ToArray());
    string concurrentDictionary = GetConcurrentDictionary();
    bool concurrentDictionaryTry = GetConcurrentDictionaryTry();
#>
public static partial class ClientEntitySetExtensions
{
    public static IAsyncQueryable<TSource> AsAsyncQueryable<TContext, TSource>(this IClientEntitySet<TContext, TSource> entitySet)
        where TContext : class, IClientContext
        where TSource : IObjectWithChangeTracker
    {
        return AsAsyncQueryable(entitySet, ParameterMode.OnDefinition);
    }
    public static IAsyncQueryable<TSource> AsAsyncQueryable<TContext, TSource>(this IClientEntitySet<TContext, TSource> entitySet, ParameterMode parameterMode)
        where TContext : class, IClientContext
        where TSource : IObjectWithChangeTracker
    {
        return new AsyncQueryable<TSource>(entitySet.Context, entitySet.Expression, parameterMode);
    }

    private static <#=concurrentDictionary#><Type, <#=concurrentDictionary#><int, WeakReference>> _entitySetPerEntity = new <#=concurrentDictionary#><Type, <#=concurrentDictionary#><int, WeakReference>>();
        
    public static bool AddEntityInDico(IClientEntitySet entitySet, IObjectWithChangeTracker entity)
    {
        if (entity == null)
            return false;
        int entityHashCode = entity.GetHashCode();
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        var entityType = entity.GetType();
        if (!_entitySetPerEntity.TryGetValue(entityType, out entitySetPerEntityForEntityType))
        {
            entitySetPerEntityForEntityType = new <#=concurrentDictionary#><int, WeakReference>();
            entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityHashCode, new WeakReference(entitySet));
            _entitySetPerEntity.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityType, entitySetPerEntityForEntityType);
            return true;
        }
        WeakReference entitySetInDico = null;
        if (entitySetPerEntityForEntityType.TryGetValue(entityHashCode, out entitySetInDico))
        {
            if (!entitySetInDico.IsAlive)
            {
<#+
        if (concurrentDictionaryTry)
        {
#>
                WeakReference _;
<#+
        }
#>
                entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(entityHashCode<#=concurrentDictionaryTry ? ", out _" : ""#>);
            }
            else
            {
                if (entitySetInDico.Target != entitySet)
                    throw new InvalidOperationException("An entity can be attached only on one context");
                return false;
            }
        }
        entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Add(entityHashCode, new WeakReference(entitySet));
        return true;
    }
        
    public static IClientEntitySet GetClientEntitySet(IObjectWithChangeTracker entity)
    {
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        if (!_entitySetPerEntity.TryGetValue(entity.GetType(), out entitySetPerEntityForEntityType))
            return null;
        WeakReference value = null;
        if (entitySetPerEntityForEntityType.TryGetValue(entity.GetHashCode(), out value) && value.IsAlive)
            return (IClientEntitySet)value.Target;
        return null;
    }
        
    public static void RemoveEntityInDico(IObjectWithChangeTracker entity)
    {
        <#=concurrentDictionary#><int, WeakReference> entitySetPerEntityForEntityType;
        if (!_entitySetPerEntity.TryGetValue(entity.GetType(), out entitySetPerEntityForEntityType))
            return;
<#+
        if (concurrentDictionaryTry)
        {
#>
        WeakReference _;
<#+
        }
#>
        entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(entity.GetHashCode()<#=concurrentDictionaryTry ? ", out _" : ""#>);
    }
        
    public static void ClearDico(IClientContext context)
    {
        foreach (var entitySetPerEntityForEntityType in _entitySetPerEntity.Values)
            foreach (var e in entitySetPerEntityForEntityType.Where(kv => !kv.Value.IsAlive || ((IClientEntitySet)kv.Value.Target).Context == context).Select(kv => kv.Key).ToList())
            {
<#+
        if (concurrentDictionaryTry)
        {
#>
                WeakReference _;
<#+
        }
#>
                entitySetPerEntityForEntityType.<#=concurrentDictionaryTry ? "Try" : ""#>Remove(e<#=concurrentDictionaryTry ? ", out _" : ""#>);
            }
    }
    
    public static bool Contains<ClientContext, EntityType>(ClientEntitySet<ClientContext, EntityType> entitySet, EntityType entity)
        where ClientContext : class, IClientContext
        where EntityType : class, IObjectWithChangeTracker
    {
        return entitySet.EntitiesContains(entity);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResult.cs");
    string queryResultNamespace = namespaceName + ".QueryResult";
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WCFAsyncQueryableServices/QueryResult")]
public class QueryResult
{
    [DataMember]
    public List<QueryResultRecord> Records { get; set; }

    [DataMember]
    public QueryResultRecord Record { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResultRecord.cs");
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WCFAsyncQueryableServices/QueryResult")]
public class QueryResultRecord
{
    [DataMember]
    public List<QueryResultProperty> Properties { get; set; }
    
    [DataMember]
    public string SerializedValue { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("QueryResultProperty.cs");
    WriteHeader(queryResultNamespace, code, "System.Collections.Generic", "System.Runtime.Serialization");
#>
[DataContract(Namespace = "http://WCFAsyncQueryableServices/QueryResult")]
public class QueryResultProperty
{
    [DataMember]
    public string PropertyName { get; set; }

    [DataMember]
    public string SerializedValue { get; set; }

    [DataMember]
    public QueryResultRecord Value { get; set; }

    [DataMember]
    public List<QueryResultRecord> Values { get; set; } 
}
<#+
    WriteFooter(queryResultNamespace);

    fileManager.StartNewFile("QueryPage.cs");
    WriteHeader(namespaceName, code, "System.Collections", "System.Collections.Generic");
#>
public class QueryPage<T> : IEnumerable<T>
{
    private IEnumerable<T> _enumerable;

    public QueryPage(int pageIndex, IEnumerable<T> enumerable)
    {
        PageIndex = pageIndex;
        _enumerable = enumerable;
    }

    public int PageIndex { get; private set; }

    public IEnumerator<T> GetEnumerator()
    {
        return _enumerable.GetEnumerator();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
<#+
    WriteFooter(namespaceName);

    string faultNamespace = namespaceName + ".Fault";
    fileManager.StartNewFile("FaultDetail.cs");
    WriteHeader(faultNamespace, code, "System.Runtime.Serialization", "System.ServiceModel");
#>
[DataContract(Namespace = "http://WCFAsyncQueryableServices/Fault")]
public partial class FaultDetail
{
    [DataMember]
    public string ErrorType { get; set; }

    [DataMember]
    public string ErrorMessage { get; set; }
}
<#+
    WriteFooter(faultNamespace);

    fileManager.StartNewFile("ErrorCollection.cs");
    WriteHeader(faultNamespace, code, "System.Runtime.Serialization", clientFxClientContextInterfacesNamespace + ".Errors");
#>
[DataContract(Namespace = "http://WCFAsyncQueryableServices/Fault")]
public class ErrorCollection
{
    [DataMember]
    public Error[] Errors { get; set; }
}
<#+
    WriteFooter(faultNamespace);

    fileManager.StartNewFile("ParameterMode.cs");
    WriteHeader(namespaceName, code);
#>
public enum ParameterMode
{
    OnDefinition,
    OnExecution
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("Grouping.cs");
    WriteHeader(namespaceName, code, "System.Collections", "System.Collections.Generic", "System.Linq");
#>
public class Grouping<TKey, TElement> : IGrouping<TKey, TElement>
{
    public Grouping(TKey key, List<TElement> elements)
    {
        Key = key;
        _elements = elements;
    }

    private List<TElement> _elements;
    private List<TElement> Elements
    {
        get { return _elements ?? (_elements = new List<TElement>()); }
    }

    public TKey Key { get; set; }

    public IEnumerator<TElement> GetEnumerator()
    {
        return Elements.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("IncludeMethodAttribute.cs");
    WriteHeader(namespaceName, code, "System");
#>
public class IncludeMethodAttribute : Attribute
{
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("Reference.cs");
    WriteHeader(namespaceName, code);
#>
public class Reference<T>
{
    public Reference()
    {
    }
    public Reference(T value)
    {
        Value = value;
    }
    public T Value { get; set; }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("IncludeExpressionVisitor.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Linq.Expressions", "System.Reflection", clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace);
#>
public class IncludeExpressionVisitor<QueryType> : <#=expressionVisitorNamespace == null ? "" : expressionVisitorNamespace + "."#>ExpressionVisitor
{
    private List<Func<IAsyncQueryableBase, QueryType>> _includeActions = new List<Func<IAsyncQueryableBase, QueryType>>();
        
    public IEnumerable<Func<IAsyncQueryableBase, QueryType>> IncludeActions
    {
        get { return _includeActions; }
    }
        
    protected override Expression VisitMethodCall(MethodCallExpression node)
    {
        if (node.Method.GetCustomAttributes(false).OfType<IncludeMethodAttribute>().Any())
        {
            MethodInfo method = node.Method;
            List<Expression> parameters = null;
            var queryParameter = Expression.Parameter(typeof(IAsyncQueryableBase), "p" + Guid.NewGuid().ToString());

            var includeMethod = method.DeclaringType.GetMethods(BindingFlags.Public | BindingFlags.Static).FirstOrDefault(m =>
                {
                    var parametersLoop = new List<Expression>();
                    if (m.Name != method.Name)
                        return false;
                    var methodParametersEnumerator = method.GetParameters().Cast<ParameterInfo>().GetEnumerator();
                    var mParametersEnumerator = m.GetParameters().Cast<ParameterInfo>().GetEnumerator();
                    var nodeArgumentsEnumerator = node.Arguments.GetEnumerator();
                    int parameterIndex = 0;
                    while (methodParametersEnumerator.MoveNext())
                    {
                        nodeArgumentsEnumerator.MoveNext();
                        if (!mParametersEnumerator.MoveNext())
                            return false;
                        var methodParameterType = methodParametersEnumerator.Current.ParameterType;
                        var mParameterType = mParametersEnumerator.Current.ParameterType;
                        if (parameterIndex == 0)
                        {
                            parameterIndex++;
                            if (methodParameterType.IsGenericType && methodParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>) || !methodParameterType.IsGenericType && typeof(IEntity).IsAssignableFrom(methodParameterType))
                            {
                                if (mParameterType == typeof(QueryType))
                                    parametersLoop.Add(Expression.Convert(queryParameter, typeof(QueryType)));
                                else
                                    return false;
                            }
                            else
                                return false;
                        }
                        else if (methodParameterType == mParameterType)
                            parametersLoop.Add(nodeArgumentsEnumerator.Current);
                        else
                            return false;
                    }
                    if (mParametersEnumerator.MoveNext())
                        return false;
                    parameters = parametersLoop;
                    return true;
                });

            if (includeMethod == null)
            {
                if (typeof(IAsyncQueryableValue).IsAssignableFrom(typeof(QueryType)))
                    throw new NotImplementedException("Not implemented yet. Use Take(1) instead of First or Single");
                throw new NotImplementedException();
            }
        
            _includeActions.Add(Expression.Lambda<Func<IAsyncQueryableBase, QueryType>>(
                <#=ExpressionCall("includeMethod", "parameters")#>, queryParameter).Compile());
            return Visit(node.Arguments[0]);
        }
        return base.VisitMethodCall(node);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("SerializableExpressionExtension.cs");
    WriteHeader(namespaceName, code, "System", expressionNamespace, clientFxClientContextInterfacesNamespace);
#>
public static class SerializableExpressionExtension
{
    public static SerializableExpression ReplaceParameter(this SerializableExpression expression, SerializableParameterExpression parameter, SerializableExpression replace)
    {
        return ReplaceParameter(expression, n => n == parameter ? replace : n);
    }

    public static SerializableExpression ReplaceParameter(this SerializableExpression expression, Func<SerializableParameterExpression, SerializableExpression> replace)
    {
        return new SerializableExpressionReplaceRewriter { ReplaceParameterFunc = replace }.Visit(expression);
    }

    public static SerializableExpression ReplaceBodyParameter(this SerializableLambdaExpression expression, SerializableExpression replace)
    {
        return ReplaceParameter(expression.Body, n => n == expression.Parameters[0] ? replace : n);
    }

    public static SerializableExpression ReplaceConstant(this SerializableExpression expression, SerializableConstantExpression constant, SerializableExpression replace)
    {
        return ReplaceConstant(expression, n => n == constant ? replace : n);
    }

    public static SerializableExpression ReplaceConstant(this SerializableExpression expression, Func<SerializableConstantExpression, SerializableExpression> replace)
    {
        return new SerializableExpressionReplaceRewriter { ReplaceConstantFunc = replace }.Visit(expression);
    }
                
    public class SerializableExpressionReplaceRewriter : SerializableExpressionRewriter
    {
        internal Func<SerializableParameterExpression, SerializableExpression> ReplaceParameterFunc { get; set; }
        protected internal override SerializableExpression VisitParameter(SerializableParameterExpression node)
        {
            if (ReplaceParameterFunc != null)
            {
                var value = ReplaceParameterFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitParameter(node);
        }

        internal Func<SerializableConstantExpression, SerializableExpression> ReplaceConstantFunc { get; set; }
        protected internal override SerializableExpression VisitConstant(SerializableConstantExpression node)
        {
            if (ReplaceConstantFunc != null)
            {
                var value = ReplaceConstantFunc(node);
                if (value != node)
                    return value;
            }
            return base.VisitConstant(node);
        }
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ReplaceTypeRewriter.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Linq", "System.Reflection", expressionNamespace);
#>
public class ReplaceTypeRewriter<OldT, NewT> : SerializableExpressionRewriter
{
    protected internal override SerializableExpression VisitConditional(SerializableConditionalExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableConditionalExpression(Visit(expression.TestExpression), Visit(expression.IfTrueExpression), Visit(expression.IfFalseExpression), new SerializableType(newType));
        return base.VisitConditional(expression);
    }

    protected internal override SerializableExpression VisitConstant(SerializableConstantExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
        {
            if (expression.Delegate != null)
                return new SerializableConstantExpression(expression.Delegate, newType);
            return new SerializableConstantExpression(expression.Value, newType);
        }
        return base.VisitConstant(expression);
    }

    protected internal override SerializableExpression VisitConstructor(SerializableConstructorExpression expression)
    {
        bool argumentTypeChanged = false;
        var argumentTypes = new List<SerializableType>(expression.ArgumentTypes);
        Type newType;
        for (int argumentTypeIndex = 0; argumentTypeIndex < argumentTypes.Count; argumentTypeIndex++)
            if ((newType = ReplaceType(argumentTypes[argumentTypeIndex].Type)) != argumentTypes[argumentTypeIndex].Type)
            {
                argumentTypes[argumentTypeIndex] = new SerializableType(newType);
                argumentTypeChanged = true;
            }
        if ((newType = ReplaceType(expression.Type.Type)) != expression.Type.Type || argumentTypeChanged)
            return new SerializableConstructorExpression(new SerializableType(newType), argumentTypes, expression.Arguments.Select(a => Visit(a)).ToList());
        return base.VisitConstructor(expression);
    }

    protected internal override SerializableExpression VisitLambda(SerializableLambdaExpression expression)
    {
        Type newType = ReplaceType(expression.ReturnType.Type);
        if (newType != expression.ReturnType.Type)
            return new SerializableLambdaExpression(expression.Parameters.Select(p => (SerializableParameterExpression)Visit(p)).ToList(), new SerializableType(newType), Visit(expression.Body));
        return base.VisitLambda(expression);
    }

    protected internal override SerializableExpression VisitPropertyGetter(SerializablePropertyGetterExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        if (newType != expression.MemberDeclaringType.Type)
            return new SerializablePropertyGetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name));
        return base.VisitPropertyGetter(expression);
    }

    protected internal override SerializableExpression VisitPropertySetter(SerializablePropertySetterExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        if (newType != expression.MemberDeclaringType.Type)
            return new SerializablePropertySetterExpression(Visit(expression.Source), newType.GetProperty(expression.Property.Name), Visit(expression.Value));
        return base.VisitPropertySetter(expression);
    }

    protected internal override SerializableExpression VisitMethodCall(SerializableMethodCallExpression expression)
    {
        Type newType = ReplaceType(expression.MemberDeclaringType.Type);
        MethodInfo method;
        if (newType == expression.MemberDeclaringType.Type)
        {
            method = expression.Method;
            if (!method.IsGenericMethod)
                return base.VisitMethodCall(expression);
            method = method.GetGenericMethodDefinition();
        }
        else
            method = newType.GetMethod(expression.Method.Name, expression.Method.GetParameters().Select(p => ReplaceType(p.ParameterType)).ToArray());
        if (method.IsGenericMethod)
            method = method.MakeGenericMethod(expression.GenericArguments.Select(ga => ReplaceType(ga.Type)).ToArray());
        return new SerializableMethodCallExpression(Visit(expression.Source), expression.Parameters.Select(p => Visit(p)), method);
    }

    protected internal override SerializableExpression VisitParameter(SerializableParameterExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableParameterExpression { Name = expression.Name, Type = new SerializableType(newType) };
        return base.VisitParameter(expression);
    }

    protected internal override SerializableExpression VisitUnary(SerializableUnaryExpression expression)
    {
        Type newType = ReplaceType(expression.Type.Type);
        if (newType != expression.Type.Type)
            return new SerializableUnaryExpression(expression.Operand, expression.NodeType, new SerializableType(newType));
        return base.VisitUnary(expression);
    }

    protected internal override SerializableExpression VisitTypeBinary(SerializableTypeBinaryExpression expression)
    {
        Type newType = ReplaceType(expression.TypeOperand.Type);
        if (newType != expression.TypeOperand.Type)
            return new SerializableTypeBinaryExpression(expression.Expression, expression.NodeType, new SerializableType(newType));
        return base.VisitTypeBinary(expression);
    }

    private static Type ReplaceType(Type type)
    {
        if (type == typeof(OldT))
            return typeof(NewT);
        if (type.IsGenericType)
            return type.GetGenericTypeDefinition().MakeGenericType(type.GetGenericArguments().Select(t => ReplaceType(t)).ToArray());
        return type;
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("PaginatedQuery.cs");
    WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Collections.ObjectModel", "System.Threading.Tasks", "System.Windows", clientFxComponentModelNamespace, clientFxClientContextInterfacesNamespace, clientFxClientContextInterfacesNamespace + ".Querying");
#>
public class PaginatedQuery : BindableObject
{
    public const int DefaultPageSizeConst = 20;
    private static int? _defaultPageSize;
    public static int DefaultPageSize
    {
        get { return _defaultPageSize ?? DefaultPageSizeConst; }
        set { _defaultPageSize = value; }
    }
}
        
public class PaginatedQuery<T> : PaginatedQuery, IPaginatedQuery
{
    private IAsyncQueryable<T> _query;
    private MergeOption? _mergeOption;
    private Action<int, IEnumerable<T>> _getValues;
    private Action _callBack;
    
    public PaginatedQuery(IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null, Action<int, IEnumerable<T>> getValues = null, Action callBack = null)
    {
        _query = query;
        PageSize = pageSize ?? DefaultPageSize;
        _mergeOption = mergeOption;
        _callBack = callBack;
        _getValues = getValues ?? ((pageIndex, values) =>
            {
                if (pageIndex != PageIndex)
                    return;
                Items.Clear();
                foreach (T value in values)
                    Items.Add(value);
                if (_callBack != null)
                    _callBack();
            });
    }
        
    public int PageSize { get; private set; }
        
    private int _pageIndex = 1;
    public int PageIndex
    {
        get { return _load ? _pageIndex : 0; }
        set
        {
            _pageIndex = value;
            NotifyPropertyChanged.RaisePropertyChanged(() => PageIndex);
            if (PageIndexChanged != null)
                PageIndexChanged();
            LoadPage(value);
        }
    }
        
    public event Action PageIndexChanged;
        
    private int? _count;
    private bool _isCounting = false;
    public int? Count
    {
        get
        {
            if (_load && _count == null && !_isCounting)
            {
                _isCounting = true;
                InitCount<#=asyncSuffix#>().ConfigureAwait(true);
            }
            return _count;
        }
        private set
        {
            _count = value;
            _isCounting = false;
            NotifyPropertyChanged.RaisePropertyChanged(() => Count);
            NotifyPropertyChanged.RaisePropertyChanged(() => MaxPage);
        }
    }
        
    public async Task InitCount<#=asyncSuffix#>()
    {
        Count = await _query.Count().Execute<#=asyncSuffix#>();
    }
        
    public int MaxPage
    {
        get { return (((Count ?? 1) - 1) / PageSize) + 1; }
    }
        
    private ObservableCollection<T> _items;
    public ObservableCollection<T> Items
    {
        get { return _items ?? (_items = new ObservableCollection<T>()); }
    }
    
    private bool _load;
    public PaginatedQuery<T> LoadPage(int? pageIndex = null, Action callBack = null)
    {
        _load = true;
        LoadPageBody<#=asyncSuffix#>(pageIndex, callBack).ConfigureAwait(true);
        return this;
    }
    private async Task LoadPageBody<#=asyncSuffix#>(int? pageIndex, Action callBack)
    {
        Items.Clear();
        int pageIndexValue = pageIndex ?? PageIndex;
        _getValues(pageIndexValue, await _query.Skip((pageIndexValue - 1) * PageSize).Take(PageSize).Execute<#=asyncSuffix#>(_mergeOption));
    }
        
    private LoadPageParameter[] _identifiers;
    public PaginatedQuery<T> LoadPage(params LoadPageParameter[] identifiers)
    {
        _load = true;
        Items.Clear();
        _identifiers = identifiers;
        LoadPageInternal<#=asyncSuffix#>(identifiers).ConfigureAwait(true);
        return this;
    }
    private async Task LoadPageInternal<#=asyncSuffix#>(params LoadPageParameter[] identifiers)
    {
        var result = await _query.LoadPage<#=asyncSuffix#>(PageSize, _mergeOption, identifiers);
        if (_identifiers == identifiers)
        {
            _pageIndex = result.PageIndex + 1;
            NotifyPropertyChanged.RaisePropertyChanged(() => PageIndex);
            if (PageIndexChanged != null)
                PageIndexChanged();
            Items.Clear();
            foreach (T value in result)
                Items.Add(value);
            if (_callBack != null)
                _callBack();
        }
    }
}
        
public static class PaginatedQueryExtension
{
    public static PaginatedQuery<T> ToPaginatedQuery<T>(this IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null, Action<int, IEnumerable<T>> getValues = null, Action callBack = null)
    {
        return new PaginatedQuery<T>(query, pageSize, mergeOption, getValues, callBack);
    }
}
<#+
    WriteFooter(namespaceName);

    fileManager.StartNewFile("ProxyHelper.cs");
    WriteHeader(namespaceName, code, "System", "System.ServiceModel", "System.Threading.Tasks");
#>
public static class ProxyHelper
{
    public static async Task<TResult> ExecuteFunc<#=asyncSuffix#><T, TResult>(Func<T> factory, Func<T, Task<TResult>> action, int nbRetryOnTimeout = 0)
        where T : ICommunicationObject, IDisposable
    {
        for (int tryIndex = 1; ; tryIndex++)
            using (var service = factory())
            {
                try
                {
                    var value = await action(service);
                    service.Close();
                    return value;
                }
                catch (TimeoutException te)
                {
                    service.Abort();
                    if (tryIndex > nbRetryOnTimeout)
                        throw te;
                }
                catch (Exception e)
                {
                    service.Abort();
                    throw e;
                }
            }
    }

    public static async Task ExecuteAction<#=asyncSuffix#><T>(Func<T> factory, Func<T, Task> action, int nbRetryOnTimeout = 0)
        where T : ICommunicationObject, IDisposable
    {
        for (int tryIndex = 1; ; tryIndex++)
            using (var service = factory())
            {
                try
                {
                    await action(service);
                    service.Close();
                    return;
                }
                catch (TimeoutException te)
                {
                    service.Abort();
                    if (tryIndex > nbRetryOnTimeout)
                        throw te;
                }
                catch (Exception e)
                {
                    service.Abort();
                    throw e;
                }
            }
    }
}
<#+
    WriteFooter(namespaceName);

    WriteSpecificClasses(fileManager, code, clientFxComponentModelNamespace, clientFxEntitiesTrackingNamespace, clientFxClientContextInterfacesNamespace, namespaceName, asyncSuffix);

    fileManager.Process();
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.

string ExpressionCall(string method, string parameters)
{
	return string.Concat("Expression.Call(", method, ", ", parameters, ")");
}

void AddClientEntitySetExtensionsUsings(List<string> usings)
{
    usings.Add("System.Collections.Concurrent");
}

string GetConcurrentDictionary()
{
    return "ConcurrentDictionary";
}

bool GetConcurrentDictionaryTry()
{
    return true;
}

void WriteSpecificClasses(EntityFrameworkTemplateFileManager fileManager, CodeGenerationTools code, string clientFxComponentModelNamespace, string clientFxEntitiesTrackingNamespace, string clientFxClientContextInterfacesNamespace, string namespaceName, string asyncSuffix)
{
	fileManager.StartNewFile("ByStepQuery.cs");
	WriteHeader(namespaceName, code, "System", "System.Collections.Generic", "System.Collections.ObjectModel", "System.Reactive.Linq", "System.Threading.Tasks", clientFxComponentModelNamespace, clientFxClientContextInterfacesNamespace);
#>
public class ByStepQuery : BindableObject
{
	public const int DefaultPageSizeConst = 20;
	private static int? _defaultPageSize;
	public static int DefaultPageSize
	{
		get { return _defaultPageSize ?? DefaultPageSizeConst; }
		set { _defaultPageSize = value; }
	}
}

public class ByStepQuery<T> : ByStepQuery
{
	private IAsyncQueryable<T> _query;
	private MergeOption? _mergeOption;

	public ByStepQuery(IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null)
	{
		_query = query;
		PageSize = pageSize ?? DefaultPageSize;
		_mergeOption = mergeOption;
	}

	public int PageSize { get; private set; }

	private ObservableCollection<T> _items;
	public ObservableCollection<T> Items
	{
		get { return _items ?? (_items = new ObservableCollection<T>()); }
	}


	public ByStepQuery<T> Load()
	{
		LoadBody();
		return this;
	}
	private void LoadBody()
	{
		IsCompleted = false;
		GetObservable().ObserveOnDispatcher().Subscribe(item => Items.Add(item), e => { throw e; }, () => IsCompleted = true);
	}

	public IObservable<T> GetObservable()
	{
		return Observable.Create<T>(observer => 
			{
				bool cancelled = false;
				Task.Factory.StartNew(() => LoadItems<#=asyncSuffix#>(observer, () => cancelled));
				return () => cancelled = true;
			});
	}

	private async Task LoadItems<#=asyncSuffix#>(IObserver<T> observer, Func<bool> getCancelled)
	{
		int pageIndex = 0;
		int count;
		do
		{
			count = 0;
			if (getCancelled())
				return;
			if (_cancelled)
				break;
			IEnumerable<T> values;
			try
			{
				values = await _query.Skip(pageIndex * PageSize).Take(PageSize).Execute<#=asyncSuffix#>(_mergeOption);
			}
			catch (Exception e)
			{
				observer.OnError(e);
				return;
			}
			if (getCancelled())
				return;
			if (_cancelled)
				break;
			foreach (var value in values)
			{
				count++;
				observer.OnNext(value);
			}
			pageIndex++;
		} while (count == PageSize);
		observer.OnCompleted();
	}

	private bool _cancelled;
	public void Cancel()
	{
		_cancelled = true;
	}

	private bool _isCompleted;
	public bool IsCompleted
	{
		get { return _isCompleted; }
		set 
		{ 
			_isCompleted = value;
			NotifyPropertyChanged.RaisePropertyChanged(() => IsCompleted);
		}
	}
}

public static class ByStepQueryExtension
{
	public static ByStepQuery<T> ToByStepQuery<T>(this IAsyncQueryable<T> query, int? pageSize = null, MergeOption? mergeOption = null)
	{
		return new ByStepQuery<T>(query, pageSize, mergeOption);
	}
}
<#+
	WriteFooter(namespaceName);
}
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.
#>
<#+// Copyright (c) Matthieu MEZIL.  All rights reserved.
#>

